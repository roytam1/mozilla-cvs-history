<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is Sun Microsystems code.
   -
   - The Initial Developer of the Original Code is Sun Microsystems.
   - Portions created by the Initial Developer are Copyright (C) 2006
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Michael Buettner <michael.buettner@sun.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE dialog [
  <!ENTITY % dtd1 SYSTEM "chrome://calendar/locale/global.dtd" > %dtd1;
  <!ENTITY % dtd2 SYSTEM "chrome://calendar/locale/calendar.dtd" > %dtd2;
  <!ENTITY % dtd3 SYSTEM "chrome://calendar/locale/sun-calendar-event-dialog.dtd" > %dtd3;
  <!ENTITY % calendar-event-dialogDTD SYSTEM "chrome://calendar/locale/calendar-event-dialog.dtd"> %calendar-event-dialogDTD;
]>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
  <binding id="attendees-list">
    <content>
      <xul:listbox anonid="listbox" seltype="multiple" rows="-1" flex="1">
        <xul:listcols>
          <xul:listcol/>
          <xul:listcol flex="1"/>
        </xul:listcols>
        <xul:listitem anonid="item" class="addressingWidgetItem" allowevents="true">
          <xul:listcell class="addressingWidgetCell" align="center" pack="center">
            <xul:image id="attendeeCol1#1" anonid="icon"/>
          </xul:listcell>
          <xul:listcell class="addressingWidgetCell">
            <xul:textbox id="attendeeCol2#1"
                         anonid="input"
                         class="plain textbox-addressingWidget uri-element"
                         type="autocomplete"
                         flex="1"
                         searchSessions="addrbook"
                         timeout="300"
                         maxrows="4"
                         autoFill="true"
                         autoFillAfterMatch="true"
                         forceComplete="true"
                         minResultsForPopup="1"
                         ignoreBlurWhileSearching="true"
                         oninput="this.setAttribute('dirty', 'true');">
              <xul:image class="person-icon" onclick="this.parentNode.select();"/>
            </xul:textbox>
          </xul:listcell>
        </xul:listitem>
      </xul:listbox>
    </content>

    <implementation>
      <field name="mMaxAttendees">0</field>
      <field name="mContentHeight">0</field>
      <field name="mRowHeight">0</field>
      <field name="mNumColumns">0</field>
      <field name="mIOService">null</field>
      <field name="mDirectoryServerObserver">null</field>
      <field name="mHeaderParser">null</field>
      <field name="mPrefs">null</field>
      <field name="mIsOffline">0</field>
      <field name="mLDAPSession">null</field>
      <field name="mSessionAdded">0</field>
      <field name="mOrganizerID">null</field>
      <field name="mIsReadOnly">false</field>
      <field name="mIsInvitation">false</field>
      <field name="mPopupOpen">false</field>

      <constructor><![CDATA[
        this.mMaxAttendees = 0;

        var self = this;
        var load = function loadHandler() {
            self.onLoad();
        };
        window.addEventListener("load", load, true);
        var unload = function attendeeListBinding_unloadHandler() {
            self.onUnload();
        };
        window.addEventListener("unload", unload, true);

        var observer = {
            observe: function DSO_observe(subject,
                              topic,
                              value) {
                // catch the exception and ignore it, so that if LDAP setup
                // fails, the entire window doesn't get horked
                try {
                    self.setupAutocomplete();
                }
                catch (ex) {
                }
            }
        }

        this.mDirectoryServerObserver = observer;

        var component = Components.classes["@mozilla.org/messenger/headerparser;1"];
        if (component) {
            this.mHeaderParser = component.getService(Components.interfaces.nsIMsgHeaderParser);
        }

        // First get the preferences service
        try {
            this.mPrefs = Components.classes["@mozilla.org/preferences-service;1"]
                                    .getService(Components.interfaces.nsIPrefService)
                                    .getBranch(null);
            this.mPrefs = this.mPrefs.QueryInterface(Components.interfaces.nsIPrefBranch2);
        } catch (ex) {
        }

        this.mIOService = Components.classes["@mozilla.org/network/io-service;1"]
                                    .getService(Components.interfaces.nsIIOService);
        this.mIsOffline = this.mIOService.offline;
      ]]></constructor>

      <method name="onLoad">
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var template =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "item");

          // we need to enfore several layout constraints which can't be modelled
          // with plain xul and css, at least as far as i know.
          const kStylesheet = "chrome://calendar/content/sun-calendar-event-dialog.css";
          for each (var stylesheet in document.styleSheets) {
              if (stylesheet.href == kStylesheet) {
                  // the height of the text blocks contained in the grid items needs
                  // to have the same height as the items of the attendee-list.
                  var height = template.boxObject.height - 1;
                  stylesheet.insertRule(".freebusy-grid { min-height: " + height + "px; }", 0);
                  break;
              }
          }

          this.onInitialize();

          // this trigger the continous update chain, which
          // effectively calls this.onModify() on predefined
          // time intervals [each second].
          var self = this;
          var callback = function() {
              setTimeout(callback, 1000);
              self.onModify();
          }
          callback();
        ]]></body>
      </method>

      <method name="onInitialize">
        <body><![CDATA[
          var args = window.arguments[0];
          var organizer = args.organizer;
          var attendees = args.attendees;
          var calendar = args.calendar;

          // set 'mIsReadOnly' if the calendar is read-only
          if (calendar && calendar.readOnly) {
              this.mIsReadOnly = true;
          }

          // assume we're the organizer [in case that the calendar
          // does not support the concept of identities].
          this.mIsInvitation = false;
          this.mOrganizerID = ((organizer && organizer.id) ? organizer.id : "");
          try {
              var provider = calendar.QueryInterface(Components.interfaces.calIWcapCalendar);
              this.mIsInvitation = provider.isInvitation(args.item);
              if (this.mOrganizerID.length == 0) {
                  this.mOrganizerID = provider.ownerId; // sensible default
              }
          }
          catch (e) {
          }

          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var template =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "item");
          template.focus();

          if (this.mIsReadOnly || this.mIsInvitation) {
              listbox.setAttribute("disabled", "true");
          }

          // TODO: the organizer should show up in the attendee list, but this information
          // should be based on the organizer contained in the appropriate field of calIItemBase.
          // This is currently not supported, since we're still missing calendar identities.
          if (this.mOrganizerID && this.mOrganizerID != "") {
              if (!organizer) {
                  organizer = this.createAttendee();
                  organizer.id = this.mOrganizerID;
                  organizer.role = "CHAIR";
                  organizer.participationStatus = "ACCEPTED";
              } else {
                  if (!organizer.id) {
                      organizer.id = this.mOrganizerID;
                  }
                  if (!organizer.role) {
                      organizer.role = "CHAIR";
                  }
                  if (!organizer.participationStatus) {
                      organizer.participationStatus = "ACCEPTED";
                  }
              }
              try {
                  var provider = calendar.QueryInterface(Components.interfaces.calIWcapCalendar);
                  var props = provider.getCalendarProperties("X-S1CS-CALPROPS-COMMON-NAME", {});
                  if (props.length > 0) {
                      if(organizer.commonName.length <= 0) {
                         organizer.commonName = props[0];
                      }
                  }
              }
              catch (e) {
              }
              this.appendAttendee(organizer, listbox, template, true);
          }

          var numRowsAdded = 0;
          if (attendees.length > 0) {
              for each (var attendee in attendees) {
                  this.appendAttendee(attendee, listbox, template, false);
                  numRowsAdded++;
              }
          }
          if (numRowsAdded == 0) {
              this.appendAttendee(null, listbox, template, false);
          }

          // detach the template item from the listbox, but hold the reference.
          // until this function returns we add at least a single copy of this template back again.
          listbox.removeChild(template);

          this.addDirectoryServerObserver();

          this.setFocus(this.mMaxAttendees);
        ]]></body>
      </method>

      <method name="onUnload">
        <body><![CDATA[
          this.removeDirectoryServerObserver();
          this.releaseAutoCompleteState();
          this.mIOService = null;
          this.mLDAPSession = null;
        ]]></body>
      </method>

      <!-- appends a new row using an existing attendee structure -->
      <method name="appendAttendee">
        <parameter name="aAttendee"/>
        <parameter name="aParentNode"/>
        <parameter name="aTemplateNode"/>
        <parameter name="aDisableIfOrganizer"/>
        <body><![CDATA[
          // create a new listbox item and append it to our parent control.
          var newNode = aTemplateNode.cloneNode(true);

          var input =
              document.getAnonymousElementByAttribute(
                  newNode, "anonid", "input");
          var icon =
              document.getAnonymousElementByAttribute(
                  newNode, "anonid", "icon");

          // We always clone the first row. The problem is that the first row
          // could be focused. When we clone that row, we end up with a cloned
          // XUL textbox that has a focused attribute set.  Therefore we think
          // we're focused and don't properly refocus.  The best solution to this
          // would be to clone a template row that didn't really have any presentation,
          // rather than using the real visible first row of the listbox.
          // For now we'll just put in a hack that ensures the focused attribute
          // is never copied when the node is cloned.
          if (input.getAttribute('focused') != '') {
              input.removeAttribute('focused');
          }

          aParentNode.appendChild(newNode);

          // the template could have its fields disabled,
          // that's why we need to reset their status.
          input.removeAttribute("disabled");
          icon.removeAttribute("disabled");

          if (this.mIsReadOnly || this.mIsInvitation) {
              input.setAttribute("disabled", "true");
              icon.setAttribute("disabled", "true");
          }

          // disable the input-field [name <email>] if this attendee
          // appears to be the organizer.
          if (aDisableIfOrganizer) {
              if (aAttendee) {
                  if (this.mOrganizerID && this.mOrganizerID != "") {
                      if (aAttendee.id.toLowerCase() == this.mOrganizerID.toLowerCase()) {
                          input.setAttribute("disabled", "true");
                      }
                  }
              }
          }

          this.mMaxAttendees++;
          var rowNumber = this.mMaxAttendees;
          if (rowNumber >= 0) {
              icon.setAttribute("id", "attendeeCol1#" + rowNumber);
              input.setAttribute("id", "attendeeCol2#" + rowNumber);
          }

          if (!aAttendee) {
              aAttendee = this.createAttendee();
          }

          // construct the display string from common name and/or email address.
          var inputValue = aAttendee.commonName;
          var regexp = new RegExp("^mailto:(.*)", "i");
          if (inputValue && this.mHeaderParser) {
              var email = aAttendee.id;
              if (email && email.length) {
                  if (regexp.test(email)) {
                      inputValue += ' <' + RegExp.$1 + '>';
                  } else {
                      inputValue += ' <' + email + '>';
                  }
              }
          } else {
              var email = aAttendee.id;
              if (email && email.length) {
                  if (regexp.test(email)) {
                      inputValue = RegExp.$1;
                  } else {
                      inputValue = email;
                  }
              }
          }

          // remove leading spaces
          while (inputValue && inputValue[0] == " " ) {
              inputValue = inputValue.substring(1, inputValue.length);
          }

          input.setAttribute("value", inputValue);
          input.value = inputValue;
          input.attendee = aAttendee;
          input.setAttribute("dirty", "true");

          if (aAttendee) {
              if (this.mOrganizerID && this.mOrganizerID != "") {
                  if (aAttendee.id.toLowerCase() == this.mOrganizerID.toLowerCase()) {
                      icon.setAttribute("class", "status-icon");
                      icon.setAttribute("status", aAttendee.participationStatus);
                      return true;
                  }
              }
          }

          icon.setAttribute("class", "role-icon");
          icon.setAttribute("role", aAttendee.role);

          return true;
        ]]></body>
      </method>

      <method name="appendNewRow">
        <parameter name="aSetFocus"/>
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var listitem1 = this.getListItem(1);

          if (listbox && listitem1) {
              var newAttendee = this.createAttendee();
              var nextDummy = this.getNextDummyRow();
              var newNode = listitem1.cloneNode(true);

              var input =
                  document.getAnonymousElementByAttribute(
                      newNode, "anonid", "input");
              var icon =
                  document.getAnonymousElementByAttribute(
                      newNode, "anonid", "icon");

              // the template could have its fields disabled,
              // that's why we need to reset their status.
              input.removeAttribute("disabled");
              icon.removeAttribute("disabled");

              if (this.mIsReadOnly || this.mIsInvitation) {
                  input.setAttribute("disabled", "true");
                  icon.setAttribute("disabled", "true");
              }

              this.mMaxAttendees++;
              var rowNumber = this.mMaxAttendees;
              if (rowNumber >= 0) {
                  icon.setAttribute("id", "attendeeCol1#" + rowNumber);
                  input.setAttribute("id", "attendeeCol2#" + rowNumber);
              }

              input.value = null;
              input.removeAttribute("value");
              input.attendee = newAttendee;

              // this copies the autocomplete sessions list from first attendee
              if (this.mLDAPSession && this.mSessionAdded) {
                  input.syncSessions(document.getElementById('attendeeCol2#1'));
              }

              // set role and participation status
              //status.setAttribute("status", newAttendee.participationStatus);
              //role.setAttribute("role", newAttendee.role);
              icon.setAttribute("class", "role-icon");
              icon.setAttribute("role", "REQ-PARTICIPANT");

              // We always clone the first row.  The problem is that the first row
              // could be focused.  When we clone that row, we end up with a cloned
              // XUL textbox that has a focused attribute set.  Therefore we think
              // we're focused and don't properly refocus.  The best solution to this
              // would be to clone a template row that didn't really have any presentation,
              // rather than using the real visible first row of the listbox.
              // For now we'll just put in a hack that ensures the focused attribute
              // is never copied when the node is cloned.
              if (input.getAttribute('focused') != '') {
                  input.removeAttribute('focused');
              }

              if (nextDummy) {
                  listbox.replaceChild(newNode, nextDummy);
              } else {
                  listbox.appendChild(newNode);
              }

              // focus on new input widget
              if (aSetFocus) {
                  this.setFocus(this.mMaxAttendees);
              }

              this.onModify();
          }
        ]]></body>
      </method>

      <property name="attendees">
        <getter><![CDATA[
          var attendees = [];

          var inputField;
          for (var i = 1; inputField = this.getInputElement(i); i++) {
              var fieldValue = inputField.value;
              if (fieldValue != "") {
                  // the inputfield already has a reference to the attendee
                  // object, we just need to fill in the name.
                  var attendee = inputField.attendee.clone();

                  attendee.role = this.getRoleElement(i).getAttribute("role");
                  //attendee.participationStatus = this.getStatusElement(i).getAttribute("status");

                  // break the list of potentially many attendees back into individual names
                  var emailAddresses = {};
                  var names = {};
                  var fullNames = {};

                  if (this.mHeaderParser) {
                      this.mHeaderParser.parseHeadersWithArray(fieldValue,
                                                               emailAddresses,
                                                               names,
                                                               fullNames);
                  } else {
                      emailAddresses.value = [ fieldValue ];
                      names.value = [];
                  }

                  if (emailAddresses.value.length > 0) {
                      // If the new address has no 'mailto'-prefix but seems
                      // to look like an email-address, we prepend the prefix.
                      // This also allows for non-email-addresses.
                      var email = emailAddresses.value[0];
                      if (email.toLowerCase().indexOf("mailto:") != 0) {
                          if (email.indexOf("@") >= 0) {
                              email = "MAILTO:" + email;
                          }
                      }
                      attendee.id = email;
                  }
                  if (names.value.length > 0) {
                      attendee.commonName = names.value[0];
                  }

                  var addAttendee = true;
                  if (this.mOrganizerID &&
                      this.mOrganizerID != "" &&
                      attendee.id.toLowerCase() == this.mOrganizerID.toLowerCase() &&
                      i == 1) {
                      addAttendee = false;
                  }

                  // append the attendee object to the list of attendees.
                  if (addAttendee) {
                      attendees.push(attendee);
                  }
              }
          }

          return attendees;
        ]]></getter>
      </property>

      <property name="organizer">
        <getter><![CDATA[
          var inputField;
          for (var i = 1; inputField = this.getInputElement(i); i++) {
              var fieldValue = inputField.value;
              if (fieldValue != "") {
                  // The inputfield already has a reference to the attendee
                  // object, we just need to fill in the name.
                  var attendee = inputField.attendee.clone();

                  //attendee.role = this.getRoleElement(i).getAttribute("role");
                  attendee.participationStatus = this.getStatusElement(i).getAttribute("status");

                  // break the list of potentially many attendees back into individual names
                  var emailAddresses = {};
                  var names = {};
                  var fullNames = {};

                  if (this.mHeaderParser) {
                      this.mHeaderParser.parseHeadersWithArray(fieldValue,
                                                               emailAddresses,
                                                               names,
                                                               fullNames);
                  } else {
                      emailAddresses.value = [ fieldValue ];
                      names.value = [];
                  }

                  if (emailAddresses.value.length > 0) {
                      // if the new address has no 'mailto'-prefix but seems
                      // to look like an email-address, we prepend the prefix.
                      // this also allows for non-email-addresses.
                      var email = emailAddresses.value[0];
                      if (email.toLowerCase().indexOf("mailto:") != 0) {
                          if (email.indexOf("@") >= 0) {
                              email = "MAILTO:" + email;
                          }
                      }
                      attendee.id = email;
                  }
                  if (names.value.length > 0) {
                      attendee.commonName = names.value[0];
                  }

                  if (this.mOrganizerID && this.mOrganizerID != "" &&
                      attendee.id.toLowerCase() == this.mOrganizerID.toLowerCase()) {
                      return attendee;
                  }
              }
          }

          return null;
        ]]></getter>
      </property>

      <method name="onModify">
        <body><![CDATA[
          var list = [];
          for (var i = 1; i <= this.mMaxAttendees; i++) {
              // retrieve the string from the appropriate row
              var input = this.getInputElement(i);
              var fieldValue = input.value;

              // parse the string to break this down to individual names and addresses
              var email = "";
              var emailAddresses = {};
              var names = {};
              var fullNames = {};

              if (this.mHeaderParser) {
                  this.mHeaderParser.parseHeadersWithArray(
                      fieldValue,
                      emailAddresses,
                      names,
                      fullNames);
              } else {
                  emailAddresses.value = [ fieldValue ];
                  names.value = [];
              }

              if (emailAddresses.value.length > 0) {
                  // if the new address has no 'mailto'-prefix but seems
                  // to look like an email-address, we prepend the prefix.
                  // this also allows for non-email-addresses.
                  email = emailAddresses.value[0];
                  if (email.toLowerCase().indexOf("mailto:") != 0) {
                      if (email.indexOf("@") >= 0) {
                          email = "MAILTO:" + email;
                      }
                  }
              }

              var isdirty = false;
              if (input.hasAttribute("dirty")) {
                  isdirty = input.getAttribute("dirty");
              }
              input.removeAttribute("dirty");
              var entry = {
                  dirty: isdirty,
                  calid: email
              };
              list.push(entry);
          }

          var event = document.createEvent('Events');
          event.initEvent('modify', true, false);
          event.details = list;
          this.dispatchEvent(event);
        ]]></body>
      </method>

      <property name="documentSize">
        <getter><![CDATA[
            return this.mRowHeight * this.mMaxAttendees;
        ]]></getter>
      </property>

      <method name="fitDummyRows">
        <body><![CDATA[
          var self = this;
          var func = function attendees_list_fitDummyRows() {
              self.calcContentHeight();
              self.createOrRemoveDummyRows();
          }
          setTimeout(func, 0);
        ]]></body>
      </method>

      <method name="calcContentHeight">
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var items = listbox.getElementsByTagNameNS('*', 'listitem');
          this.mContentHeight = 0;
          if (items.length > 0) {
              var i = 0;
              do {
                  this.mRowHeight = items[i].boxObject.height;
                  ++i;
              } while (i < items.length && !this.mRowHeight);
              this.mContentHeight = this.mRowHeight * items.length;
          }
        ]]></body>
      </method>

      <method name="createOrRemoveDummyRows">
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var listboxHeight = listbox.boxObject.height;

          // remove rows to remove scrollbar
          var kids = listbox.childNodes;
          for (var i = kids.length - 1; this.mContentHeight > listboxHeight && i >= 0; --i) {
              if (kids[i].hasAttribute("_isDummyRow")) {
                  this.mContentHeight -= this.mRowHeight;
                  listbox.removeChild(kids[i]);
              }
          }

          // add rows to fill space
          if (this.mRowHeight) {
              while (this.mContentHeight + this.mRowHeight < listboxHeight) {
                  this.createDummyItem(listbox);
                  this.mContentHeight += this.mRowHeight;
              }
          }
        ]]></body>
      </method>

      <method name="createDummyCell">
        <parameter name="aParent"/>
        <body><![CDATA[
          var cell = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "listcell");
          cell.setAttribute("class", "addressingWidgetCell dummy-row-cell");
          if (aParent) {
              aParent.appendChild(cell);
          }
          return cell;
        ]]></body>
      </method>

      <method name="createDummyItem">
        <parameter name="aParent"/>
        <body><![CDATA[
          var titem = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "listitem");
          titem.setAttribute("_isDummyRow", "true");
          titem.setAttribute("class", "dummy-row");
          for (var i = this.numColumns; i > 0; i--) {
              this.createDummyCell(titem);
          }
          if (aParent) {
              aParent.appendChild(titem);
          }
          return titem;
        ]]></body>
      </method>

      <!-- gets the next row from the top down -->
      <method name="getNextDummyRow">
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var kids = listbox.childNodes;
          for (var i = 0; i < kids.length; ++i) {
              if (kids[i].hasAttribute("_isDummyRow")) {
                  return kids[i];
              }
          }
          return null;
        ]]></body>
      </method>

      <!-- This method returns the <xul:listitem> at row numer 'aRow' -->
      <method name="getListItem">
        <parameter name="aRow"/>
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          if (listbox && aRow > 0) {
              var listitems = listbox.getElementsByTagNameNS('*', 'listitem');
              if (listitems && listitems.length >= aRow) {
                  return listitems[aRow - 1];
              }
          }
          return 0;
        ]]></body>
      </method>

      <method name="getRowByInputElement">
        <parameter name="aElement"/>
        <body><![CDATA[
          var row = 0;
          while (aElement && aElement.localName != "listitem") {
              aElement = aElement.parentNode;
          }
          if (aElement) {
              while (aElement) {
                  if (aElement.localName == "listitem") {
                      ++row;
                  }
                  aElement = aElement.previousSibling;
              }
          }
          return row;
        ]]></body>
      </method>

      <!-- This method returns the <xul:textbox> that contains
           the name of the attendee at row number 'aRow' -->
      <method name="getInputElement">
        <parameter name="aRow"/>
        <body><![CDATA[
          return document.getElementById("attendeeCol2#" + aRow);
        ]]></body>
      </method>

      <method name="getRoleElement">
        <parameter name="aRow"/>
        <body><![CDATA[
          return document.getElementById("attendeeCol1#" + aRow);
        ]]></body>
      </method>

      <method name="getStatusElement">
        <parameter name="aRow"/>
        <body><![CDATA[
          return document.getElementById("attendeeCol1#" + aRow);
        ]]></body>
      </method>

      <method name="setFocus">
        <parameter name="aRow"/>
        <body><![CDATA[
          var self = this;
          var set_focus = function() {
              // do we need to scroll in order to see the selected row?
              var node = self.getListItem(aRow);
              var listbox =
                  document.getAnonymousElementByAttribute(
                      self, "anonid", "listbox");
              var firstVisibleRow = listbox.getIndexOfFirstVisibleRow();
              var numOfVisibleRows = listbox.getNumberOfVisibleRows();
              if (aRow <= firstVisibleRow) {
                  listbox.scrollToIndex(aRow - 1);
              } else {
                  if (aRow - 1 >= (firstVisibleRow + numOfVisibleRows)) {
                      listbox.scrollToIndex(aRow - numOfVisibleRows);
                  }
              }
              var input =
                  document.getAnonymousElementByAttribute(
                      node, "anonid", "input");
              input.focus();
          }
          setTimeout(set_focus, 0);
        ]]></body>
      </method>

      <property name="firstVisibleRow">
        <getter><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          return listbox.getIndexOfFirstVisibleRow();
        ]]></getter>
      </property>

      <method name="createAttendee">
        <body><![CDATA[
          var attendee = createAttendee();
          attendee.id = "";
          attendee.rsvp = true;
          attendee.role = "REQ-PARTICIPANT";
          attendee.participationStatus = "NEEDS-ACTION";
          return attendee;
        ]]></body>
      </method>

      <property name="numColumns">
        <getter><![CDATA[
          if (!this.mNumColumns) {
              var listbox =
                  document.getAnonymousElementByAttribute(
                      this, "anonid", "listbox");
              var listCols = listbox.getElementsByTagNameNS('*', 'listcol');
              this.mNumColumns = listCols.length;
              if (!this.mNumColumns) {
                  this.mNumColumns = 1;
              }
          }
          return this.mNumColumns;
        ]]></getter>
      </property>

      <property name="ratio">
        <setter><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var rowcount = listbox.getRowCount();
          listbox.scrollToIndex(Math.floor(rowcount * val));
          return val;
        ]]></setter>
      </property>

      <method name="arrowHit">
        <parameter name="aElement"/>
        <parameter name="aDirection"/>
        <body><![CDATA[
          var row = this.getRowByInputElement(aElement) + aDirection;
          if (row) {
              if (row > this.mMaxAttendees) {
                  this.appendNewRow(true);
              } else {
                  var input = this.getInputElement(row);
                  if (input.hasAttribute("disabled")) {
                      return;
                  }
                  this.setFocus(row);
              }
              var event = document.createEvent('Events');
              event.initEvent('rowchange', true, false);
              event.details = row;
              this.dispatchEvent(event);
          }
        ]]></body>
      </method>

      <method name="deleteHit">
        <parameter name="aElement"/>
        <body><![CDATA[
          // don't delete the row if it's the last one remaining
          if (this.mMaxAttendees <= 1) {
              return;
          }

          var row = this.getRowByInputElement(aElement);
          this.deleteRow(row);
          if (row > 1) {
              row = row - 1;
          }
          this.setFocus(row);
          this.onModify();

          var event = document.createEvent('Events');
          event.initEvent('rowchange', true, false);
          event.details = row;
          this.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="deleteRow">
        <parameter name="aRow"/>
        <body><![CDATA[
          // reset id's in order to not break the sequence
          var maxAttendees = this.mMaxAttendees;
          this.removeRow(aRow);
          var numberOfCols = this.numColumns;
          for (var row = aRow + 1; row <= maxAttendees; row++) {
              for (var col = 1; col <= numberOfCols; col++) {
                  var colID = "attendeeCol" + col + "#" + row;
                  var elem = document.getElementById(colID);
                  if (elem) {
                      elem.setAttribute("id", "attendeeCol" + col + "#" + (row - 1));
                  }
              }
          }
        ]]></body>
      </method>

      <method name="removeRow">
        <parameter name="aRow"/>
        <body><![CDATA[
          var listbox =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "listbox");
          var nodeToRemove = this.getListItem(aRow);
          nodeToRemove.parentNode.removeChild(nodeToRemove);
          this.fitDummyRows();
          this.mMaxAttendees--;
        ]]></body>
      </method>

      <!-- ############################################################################# -->
      <!-- LDAP support                                                                  -->
      <!-- ############################################################################# -->

      <method name="setupAutocomplete">
        <body><![CDATA[
          var autocompleteLdap = false;
          var autocompleteDirectory = null;
          var prevAutocompleteDirectory = this.mCurrentAutocompleteDirectory;
          var i;

          try {
              autocompleteLdap = this.mPrefs.getBoolPref("ldap_2.autoComplete.useDirectory");
          } catch (ex) {
              return;
          }
          if (autocompleteLdap) {
              autocompleteDirectory = this.mPrefs.getCharPref(
                  "ldap_2.autoComplete.directoryServer");
          }

          // Use a temporary to do the setup so that we don't overwrite the
          // global, then have some problem and throw an exception, and leave the
          // global with a partially setup session.  We'll assign the temp
          // into the global after we're done setting up the session.
          var LDAPSession;
          if (this.mLDAPSession) {
              LDAPSession = this.mLDAPSession;
          } else {
              LDAPSession = Components.classes[
                  "@mozilla.org/autocompleteSession;1?type=ldap"].createInstance()
                  .QueryInterface(
                      Components.interfaces.nsILDAPAutoCompleteSession);
          }

          if (autocompleteDirectory && !this.mIsOffline) {
              // Add observer on the directory server we are autocompleting against
              // only if current server is different from previous.
              // Remove observer if current server is different from previous
              this.mCurrentAutocompleteDirectory = autocompleteDirectory;
              if (prevAutocompleteDirectory) {
                  if (prevAutocompleteDirectory != this.mCurrentAutocompleteDirectory) {
                      this.removeDirectorySettingsObserver(prevAutocompleteDirectory);
                      this.addDirectorySettingsObserver();
                  }
              } else {
                  this.addDirectorySettingsObserver();
              }

              // Fill in the session params if there is a session
              if (LDAPSession) {
                  var serverURL = Components.classes["@mozilla.org/network/ldap-url;1"]
                                  .createInstance(Components.interfaces.nsILDAPURL);
                  try {
                      serverURL.spec = this.mPrefs.getComplexValue(
                          autocompleteDirectory + ".uri",
                          Components.interfaces.nsISupportsString).data;
                  } catch (ex) {
                      dump("ERROR: " + ex + "\n");
                  }
                  LDAPSession.serverURL = serverURL;

                  // Get the login to authenticate as, if there is one
                  var login = "";
                  try {
                      login = this.mPrefs.getComplexValue(
                          autocompleteDirectory + ".auth.dn",
                          Components.interfaces.nsISupportsString).data;
                  } catch (ex) {
                      // If we don't have this pref, no big deal
                  }

                  // Set the LDAP protocol version correctly
                  var protocolVersion;
                  try {
                      protocolVersion = this.mPrefs.getCharPref(
                          autocompleteDirectory + ".protocolVersion");
                  } catch (ex) {
                      // If we don't have this pref, no big deal
                  }
                  if (protocolVersion == "2") {
                      LDAPSession.version =
                          Components.interfaces.nsILDAPConnection.VERSION2;
                  }

                  // Find out if we need to authenticate, and if so, tell the LDAP
                  // autocomplete session how to prompt for a password.  This window
                  // is being used to parent the authprompter.
                  LDAPSession.login = login;
                  if (login != "") {
                      var windowWatcherSvc = Components.classes[
                          "@mozilla.org/embedcomp/window-watcher;1"]
                          .getService(Components.interfaces.nsIWindowWatcher);
                      var domWin =
                          window.QueryInterface(Components.interfaces.nsIDOMWindow);
                      var authPrompter =
                          windowWatcherSvc.getNewAuthPrompter(domWin);
                      LDAPSession.authPrompter = authPrompter;
                  }

                  // Don't search on non-CJK strings shorter than this
                  try {
                      LDAPSession.minStringLength = this.mPrefs.getIntPref(
                          autocompleteDirectory + ".autoComplete.minStringLength");
                  } catch (ex) {
                      // if this pref isn't there, no big deal.  Just let
                      // nsLDAPAutoCompleteSession use its default.
                  }

                  // don't search on CJK strings shorter than this
                  try {
                      LDAPSession.cjkMinStringLength = this.mPrefs.getIntPref(
                          autocompleteDirectory + ".autoComplete.cjkMinStringLength");
                  } catch (ex) {
                      // If this pref isn't there, no big deal.  Just let
                      // nsLDAPAutoCompleteSession use its default.
                  }

                  // We don't try/catch here, because if this fails, we're outta luck
                  var ldapFormatter = Components.classes[
                      "@mozilla.org/ldap-autocomplete-formatter;1?type=addrbook"]
                      .createInstance().QueryInterface(
                          Components.interfaces.nsIAbLDAPAutoCompFormatter);

                  // Override autocomplete name format?
                  try {
                      ldapFormatter.nameFormat =
                          this.mPrefs.getComplexValue(autocompleteDirectory +
                              ".autoComplete.nameFormat",
                              Components.interfaces.nsISupportsString).data;
                  } catch (ex) {
                      // If this pref isn't there, no big deal.  Just let
                      // nsAbLDAPAutoCompFormatter use its default.
                  }

                  // override autocomplete mail address format?
                  try {
                      ldapFormatter.addressFormat =
                          this.mPrefs.getComplexValue(autocompleteDirectory +
                              ".autoComplete.addressFormat",
                              Components.interfaces.nsISupportsString).data;
                  } catch (ex) {
                      // If this pref isn't there, no big deal.  Just let
                      // nsAbLDAPAutoCompFormatter use its default.
                  }

                  try {
                      // Figure out what goes in the comment column, if anything
                      //
                      // 0 = none
                      // 1 = name of addressbook this card came from
                      // 2 = other per-addressbook format
                      var showComments = 0;
                      showComments = this.mPrefs.getIntPref(
                          "mail.autoComplete.commentColumn");

                      switch (showComments) {
                        case 1:
                            // Use the name of this directory
                            ldapFormatter.commentFormat = this.mPrefs.getComplexValue(
                                autocompleteDirectory + ".description",
                                Components.interfaces.nsISupportsString).data;
                            break;
                        case 2:
                            // Override ldap-specific autocomplete entry?
                            try {
                                ldapFormatter.commentFormat =
                                    this.mPrefs.getComplexValue(autocompleteDirectory +
                                        ".autoComplete.commentFormat",
                                        Components.interfaces.nsISupportsString).data;
                            } catch (innerException) {
                                // If nothing has been specified, use the ldap
                                // organization field
                                ldapFormatter.commentFormat = "[o]";
                            }
                            break;
                        case 0:
                        default:
                            // Do nothing
                      }
                  } catch (ex) {
                      // If something went wrong while setting up comments, try and
                      // proceed anyway
                  }

                  // Set the session's formatter, which also happens to
                  // force a call to the formatter's getAttributes() method
                  // -- which is why this needs to happen after we've set the
                  // various formats
                  LDAPSession.formatter = ldapFormatter;

                  // Override autocomplete entry formatting?
                  try {
                      LDAPSession.outputFormat =
                          this.mPrefs.getComplexValue(autocompleteDirectory +
                              ".autoComplete.outputFormat",
                              Components.interfaces.nsISupportsString).data;
                  } catch (ex) {
                      // If this pref isn't there, no big deal.  Just let
                      // nsLDAPAutoCompleteSession use its default.
                  }

                  // override default search filter template?
                  try {
                      LDAPSession.filterTemplate = this.mPrefs.getComplexValue(
                          autocompleteDirectory + ".autoComplete.filterTemplate",
                          Components.interfaces.nsISupportsString).data;
                  } catch (ex) {
                      // If this pref isn't there, no big deal.  Just let
                      // nsLDAPAutoCompleteSession use its default
                  }

                  // Override default maxHits (currently 100)
                  try {
                      LDAPSession.maxHits =
                          this.mPrefs.getIntPref(autocompleteDirectory +
                                                 ".maxHits");
                  } catch (ex) {
                      // If this pref isn't there, or is out of range, no big deal.
                      // Just let nsLDAPAutoCompleteSession use its default.
                  }

                  if (!this.mSessionAdded) {
                      // If we make it here, we know that session initialization has
                      // succeeded; add the session for all recipients, and
                      // remember that we've done so
                      var autoCompleteWidget;
                      for (i = 1; i <= this.mMaxAttendees; i++) {
                          autoCompleteWidget = this.getInputElement(i);
                          if (autoCompleteWidget) {
                              autoCompleteWidget.addSession(LDAPSession);
                              // Ldap searches don't insert a default entry with
                              // the default domain appended to it so reduce the
                              // minimum results for a popup to 2 in this case.
                              autoCompleteWidget.minResultsForPopup = 2;
                          }
                       }
                       this.mSessionAdded = true;
                  }
              }
          } else {
              if (this.mCurrentAutocompleteDirectory) {
                  // Remove observer on the directory server since we are not doing Ldap
                  // autocompletion.
                  this.removeDirectorySettingsObserver(this.mCurrentAutocompleteDirectory);
                  this.mCurrentAutocompleteDirectory = null;
              }
              if (this.mLDAPSession && this.mSessionAdded) {
                  for (var i = 1; i <= this.mMaxAttendees; i++)
                  this.getInputElement(i).removeSession(this.mLDAPSession);
                  this.mSessionAdded = false;
              }
          }

          this.mLDAPSession = LDAPSession;
        ]]></body>
      </method>

      <method name="addDirectoryServerObserver">
        <body><![CDATA[
          if (this.mPrefs) {
              this.mPrefs.addObserver(
                  "ldap_2.autoComplete.useDirectory",
                  this.mDirectoryServerObserver,
                  false);
              this.mPrefs.addObserver(
                  "ldap_2.autoComplete.directoryServer",
                  this.mDirectoryServerObserver,
                  false);
          }
        ]]></body>
      </method>

      <method name="removeDirectoryServerObserver">
        <body><![CDATA[
          if (this.mPrefs) {
              this.mPrefs.removeObserver(
                  "ldap_2.autoComplete.useDirectory",
                  this.mDirectoryServerObserver);
              this.mPrefs.removeObserver(
                  "ldap_2.autoComplete.directoryServer",
                  this.mDirectoryServerObserver);
          }
        ]]></body>
      </method>

      <method name="addDirectorySettingsObserver">
        <body><![CDATA[
          if (this.mPrefs) {
              this.mPrefs.addObserver(
                  this.mCurrentAutocompleteDirectory,
                  this.mDirectoryServerObserver,
                  false);
          }
        ]]></body>
      </method>

      <method name="removeDirectorySettingsObserver">
        <parameter name="aPrefString"/>
        <body><![CDATA[
          if (this.mPrefs) {
              this.mPrefs.removeObserver(
                  aPrefString,
                  this.mDirectoryServerObserver);
          }
        ]]></body>
      </method>

      <method name="releaseAutoCompleteState">
        <body><![CDATA[
          if (this.mLDAPSession && this.mSessionAdded) {
              for (i = 1; i <= this.mMaxAttendees; i++) {
                  this.getInputElement(i).removeSession(this.mLDAPSession);
              }
          }

          this.mSessionAdded = false;
          this.mLDAPSession = null;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="click" button="0"><![CDATA[
        var target = event.originalTarget;
        if (target.hasAttribute("role")) {
            if (target.hasAttribute("disabled") &&
                target.getAttribute("disabled")) {
                return;
            }
            var role = target.getAttribute("role");
            if (role == "CHAIR") {
                target.setAttribute("role", "REQ-PARTICIPANT");
            } else if (role == "REQ-PARTICIPANT") {
                target.setAttribute("role", "OPT-PARTICIPANT");
            } else if (role == "OPT-PARTICIPANT") {
                target.setAttribute("role", "CHAIR");
            }
            return;
        }

        if (target.hasAttribute("status")) {
            if (target.hasAttribute("disabled") &&
                target.getAttribute("disabled")) {
                return;
            }
            var status = target.getAttribute("status");
            switch (status) {
                case "NEEDS-ACTION":
                    target.setAttribute("status", "ACCEPTED");
                    break;
                case "ACCEPTED":
                    target.setAttribute("status", "DECLINED");
                    break;
                case "DECLINED":
                    target.setAttribute("status", "TENTATIVE");
                    break;
                case "TENTATIVE":
                    target.setAttribute("status", "ACCEPTED");
                    break;
            }
            return;
        }

        if (this.mIsReadOnly || this.mIsInvitation) {
            return;
        }

        if (target == null ||
           (target.localName != "listboxbody" &&
            target.localName != "listcell" &&
            target.localName != "listitem")) {
            return;
        }

        var lastInput = this.getInputElement(this.mMaxAttendees);
        if (lastInput && lastInput.value) {
            this.appendNewRow(true);
        }
      ]]></handler>

      <handler event="popupshown"><![CDATA[
        this.mPopupOpen = true;
      ]]></handler>

      <handler event="popuphidden"><![CDATA[
        this.mPopupOpen = false;
      ]]></handler>

      <handler event="keydown"><![CDATA[
        if (this.mIsReadOnly || this.mIsInvitation) {
            return;
        }
        if (event.originalTarget.localName == "input") {
            switch (event.keyCode) {
                case 46:
                case 8:
                    if (!event.originalTarget.value) {
                        this.deleteHit(event.originalTarget);
                    }
                    event.stopPropagation();
                    break;
                case 13:
                    this.arrowHit(event.originalTarget, 1);
                    event.stopPropagation();
                    event.preventDefault();
                    break;
            }
        }
      ]]></handler>

      <handler event="keypress" phase="capturing"><![CDATA[
        // In case we're currently showing the autocompletion popup
        // don't care about keypress-events and let them go. Otherwise
        // this event indicates the user wants to travel between
        // the different attendees. In this case we set the focus
        // appropriately and stop the event propagation.
        if (this.mPopupOpen || this.mIsReadOnly || this.mIsInvitation) {
            return;
        }
        if (event.originalTarget.localName == "input") {
            switch (event.keyCode) {
                case KeyEvent.DOM_VK_UP:
                    this.arrowHit(event.originalTarget, -1);
                    event.stopPropagation();
                    break;
                case KeyEvent.DOM_VK_DOWN:
                    this.arrowHit(event.originalTarget, 1);
                    event.stopPropagation();
                    break;
                case KeyEvent.DOM_VK_TAB:
                    this.arrowHit(event.originalTarget, event.shiftKey ? -1 : +1);
                    event.stopPropagation();
                    event.preventDefault();
                    break;
                case KeyEvent.DOM_VK_RETURN:
                    event.stopPropagation();
                    event.preventDefault();
                    break;
            }
        }
      ]]></handler>

      <handler event="input"><![CDATA[
        this.setupAutocomplete();
      ]]></handler>
    </handlers>
  </binding>

  <!-- the 'selection-bar' binding implements the vertical bar that provides
       a visual indication for the time range the event is configured for. -->
  <binding id="selection-bar">
    <content>
      <xul:scrollbox anonid="scrollbox" width="0" orient="horizontal" flex="1">
        <xul:box class="selection-bar" anonid="selection-bar">
          <xul:box class="selection-bar-left" anonid="leftbox"/>
          <xul:spacer class="selection-bar-spacer" flex="1"/>
          <xul:box class="selection-bar-right" anonid="rightbox"/>
        </xul:box>
      </xul:scrollbox>
    </content>

    <implementation>
      <field name="mRange">0</field>
      <field name="mStartHour">8</field>
      <field name="mEndHour">19</field>
      <field name="mStartHourDefault">8</field>
      <field name="mEndHourDefault">19</field>
      <field name="mContentWidth">0</field>
      <field name="mHeaderHeight">0</field>
      <field name="mRatio">0</field>
      <field name="mBaseDate">null</field>
      <field name="mStartDate">null</field>
      <field name="mEndDate">null</field>
      <field name="mMouseX">0</field>
      <field name="mMouseY">0</field>
      <field name="mDragState">0</field>
      <field name="mMargin">0</field>
      <field name="mWidth">0</field>
      <field name="mForce24Hours">false</field>
      <field name="mZoomFactor">100</field>
      <!-- constant that defines at which ratio an event is clipped, when moved or resized -->
      <field name="mfClipRatio">0.7</field>
      <field name="mLeftBox"/>
      <field name="mRightBox"/>
      <field name="mSelectionbar"/>

      <property name="zoomFactor">
        <getter><![CDATA[
          return this.mZoomFactor;
        ]]></getter>
        <setter><![CDATA[
          this.mZoomFactor = val;
          return val;
        ]]></setter>
      </property>

      <property name="force24Hours">
        <getter><![CDATA[
          return this.mForce24Hours;
        ]]></getter>
        <setter><![CDATA[
          this.mForce24Hours = val;
          this.initTimeRange();
          this.update();
          return val;
        ]]></setter>
      </property>

      <property name="ratio">
        <setter><![CDATA[
          this.mRatio = val;
          this.update();
          return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
        this.initTimeRange();

        // The basedate is the date/time from which the display
        // of the timebar starts. The range is the number of days
        // we should be able to show. the start- and enddate
        // is the time the event is scheduled for.
        this.mRange = Number(this.getAttribute("range"));
        this.mSelectionbar =
            document.getAnonymousElementByAttribute(
                this, "anonid", "selection-bar");
      ]]></constructor>

      <property name="baseDate">
        <setter><![CDATA[
          // we need to convert the date/time in question in
          // order to calculate with hours that are aligned
          // with our timebar display.
          var kDefaultTimezone = calendarDefaultTimezone();
          this.mBaseDate = val.getInTimezone(kDefaultTimezone);
          this.mBaseDate.isDate = true;
          this.mBaseDate.makeImmutable();
          return val;
        ]]></setter>
      </property>

      <property name="startDate">
        <setter><![CDATA[
          // currently we *always* set the basedate to be
          // equal to the startdate. we'll most probably
          // want to change this later.
          this.baseDate = val;
          // we need to convert the date/time in question in
          // order to calculate with hours that are aligned
          // with our timebar display.
          var kDefaultTimezone = calendarDefaultTimezone();
          this.mStartDate = val.getInTimezone(kDefaultTimezone);
          this.mStartDate.makeImmutable();
          return val;
        ]]></setter>
        <getter><![CDATA[
          return this.mStartDate;
        ]]></getter>
      </property>

      <property name="endDate">
        <setter><![CDATA[
          // we need to convert the date/time in question in
          // order to calculate with hours that are aligned
          // with our timebar display.
          var kDefaultTimezone = calendarDefaultTimezone();
          this.mEndDate = val.getInTimezone(kDefaultTimezone);
          if (this.mEndDate.isDate) {
              this.mEndDate.day += 1;
          }
          this.mEndDate.makeImmutable();
          return val;
        ]]></setter>
        <getter><![CDATA[
          return this.mEndDate;
        ]]></getter>
      </property>

      <property name="leftdragWidth">
        <getter><![CDATA[
          if (!this.mLeftBox) {
            this.mLeftBox =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "leftbox");
          }
          return this.mLeftBox.boxObject.width;
        ]]></getter>
      </property>
      <property name="rightdragWidth">
        <getter><![CDATA[
          if (!this.mRightBox) {
              this.mRightBox =
                  document.getAnonymousElementByAttribute(
                      this, "anonid", "rightbox");
          }
          return this.mRightBox.boxObject.width;
        ]]></getter>
      </property>

      <method name="init">
        <parameter name="width"/>
        <parameter name="height"/>
        <body><![CDATA[
          this.mContentWidth = width;
          this.mHeaderHeight = height + 2;
          this.mMargin = 0;
          this.update();
        ]]></body>
      </method>

      <!-- given some specific date this method calculates the
           corrposonding offset in fractional hours -->
      <method name="date2offset">
        <parameter name="date"/>
        <body><![CDATA[
          var num_hours = this.mEndHour - this.mStartHour;
          var diff = date.subtractDate(this.mBaseDate);
          var offset = diff.days * num_hours;
          var hours = (diff.hours - this.mStartHour) + (diff.minutes / 60.0);
          if (hours < 0) {
              hours = 0;
          }
          if (hours > num_hours) {
              hours = num_hours;
          }
          offset += hours;
          return offset;
        ]]></body>
      </method>

      <method name="update">
        <body><![CDATA[
          if (!this.mStartDate || !this.mEndDate) {
              return;
          }

          // Calculate the relation of startdate/basedate and enddate/startdate.
          var offset = this.mStartDate.subtractDate(this.mBaseDate);
          var duration = this.mEndDate.subtractDate(this.mStartDate);

          // Calculate how much pixels a single hour and a single day take up.
          var num_hours = this.mEndHour - this.mStartHour;
          var hour_width = this.mContentWidth / num_hours;

          // Calculate the offset in fractional hours that corrospond
          // to our start- and end-time.
          var start_offset_in_hours = this.date2offset(this.mStartDate);
          var end_offset_in_hours = this.date2offset(this.mEndDate);
          var duration_in_hours = end_offset_in_hours - start_offset_in_hours;

          // Calculate width & margin for the selection bar based on the
          // relation of startdate/basedate and enddate/startdate.
          // This is a simple conversion from hours to pixels.
          this.mWidth = duration_in_hours * hour_width;
          var totaldragwidths = this.leftdragWidth + this.rightdragWidth;
          if (this.mWidth < totaldragwidths) {
              this.mWidth = totaldragwidths;
          }
          this.mMargin = start_offset_in_hours * hour_width;

          // Calculate the difference between content and container in pixels.
          // The container is the window showing this control, the content is the
          // total number of pixels the selection bar can theoretically take up.
          var total_width = this.mContentWidth * this.mRange - this.parentNode.boxObject.width;

          // Calculate the current scroll offset.
          var offset = Math.floor(total_width * this.mRatio);

          // The final margin is the difference between the date-based margin
          // and the scroll-based margin.
          this.mMargin -= offset;

          // Set the styles based on the calculations above for the 'selection-bar'.
          var style = "width: " + this.mWidth +
                      "px; margin-left: " + this.mMargin +
                      "px; margin-top: " + this.mHeaderHeight + "px;";
          this.mSelectionbar.setAttribute("style", style);

          var event = document.createEvent('Events');
          event.initEvent('timechange', true, false);
          event.startDate = this.mStartDate;
          event.endDate = this.mEndDate.clone();
          if (event.endDate.isDate) {
              event.endDate.day--;
          }
          event.endDate.makeImmutable();
          this.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="setWidth">
        <parameter name="width"/>
        <body><![CDATA[
            var scrollbox =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "scrollbox");
            scrollbox.setAttribute("width", width);
        ]]></body>
      </method>

      <method name="initTimeRange">
        <body><![CDATA[
          this.mStartHour = this.mStartHourDefault;
          this.mEndHour = this.mEndHourDefault;

          var pb2 = Components.classes[
              "@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefBranch2);

          // Get default start/end times from prefs and set on the
          // view. If we hit an error (eg because sunbird's pref
          // infrastructure hasn't created the pref yet), the
          // defaults will do.
          try {
              this.mStartHour = pb2.getIntPref("calendar.view.defaultstarthour");
              this.mEndHour = pb2.getIntPref("calendar.view.defaultendhour");
          } catch (ex) {
          }

          if (this.force24Hours) {
              this.mStartHour = 0;
              this.mEndHour = 24;
          }
        ]]></body>
      </method>

      <method name="moveTime">
        <parameter name="time"/>
        <parameter name="delta"/>
        <parameter name="doclip"/>
        <body><![CDATA[
          var newTime = time.clone();
          var clip_minutes = 60 * this.zoomFactor / 100;
          if (newTime.isDate) {
              clip_minutes = 60 * 24;
          }
          var num_hours = this.mEndHour - this.mStartHour;
          var hour_width = this.mContentWidth / num_hours;
          var minutes_per_pixel = 60 / hour_width;
          var minute_shift = minutes_per_pixel * delta;
          var isClipped = Math.abs(minute_shift) >= (this.mfClipRatio * clip_minutes);
          if (isClipped) {
              if (delta > 0) {
                  if (time.isDate) {
                      newTime.day++;
                  } else {
                      if (doclip) {
                          newTime.minute -= newTime.minute % clip_minutes;
                      }
                      newTime.minute += clip_minutes;
                  }
              } else if (delta < 0) {
                  if (time.isDate) {
                      newTime.day--;
                  } else {
                      if (doclip) {
                          newTime.minute -= newTime.minute % clip_minutes;
                      }
                      newTime.minute -= clip_minutes;
                  }
              }
          }

          if (!newTime.isDate) {
              if (newTime.hour < this.mStartHour) {
                  newTime.hour = this.mEndHour - 1;
                  newTime.day--;
              }
              if (newTime.hour >= this.mEndHour) {
                  newTime.hour = this.mStartHour;
                  newTime.day++;
              }
          }

          return newTime;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="mousedown"><![CDATA[
        var element = event.target;
        this.mMouseX = event.screenX;
        var mouseX = event.clientX - element.boxObject.x;

        if (mouseX >= this.mMargin) {
            if (mouseX <= (this.mMargin + this.mWidth)) {
                if (mouseX <= (this.mMargin + this.leftdragWidth)) {
                    // Move the startdate only...
                    window.setCursor("w-resize");
                    this.mDragState = 2;
                } else if (mouseX >= (this.mMargin + this.mWidth - (this.rightdragWidth))) {
                    // Move the enddate only..
                    window.setCursor("e-resize");
                    this.mDragState = 3;
                } else {
                    // Move the startdate and the enddate
                    this.mDragState = 1;
                    window.setCursor("-moz-grab");
                }
            }
        }
      ]]></handler>

      <handler event="mousemove"><![CDATA[
        var mouseX = event.screenX;
        if (this.mDragState == 1) {
            // Move the startdate and the enddate
            var delta = mouseX - this.mMouseX;
            var newStart = this.moveTime(this.mStartDate, delta, false);
            if (newStart.compare(this.mStartDate) != 0) {
                newEnd = this.moveTime(this.mEndDate, delta, false);

                // We need to adapt this date in case we're dealing with
                // an all-day event. This is because setting 'endDate' will
                // automatically add one day extra for all-day events.
                if (newEnd.isDate) {
                    newEnd.day--;
                }

                this.startDate = newStart;
                this.endDate = newEnd;
                this.mMouseX = mouseX;
                this.update();
            }
        } else if (this.mDragState == 2) {
            // Move the startdate only...
            var delta = event.screenX - this.mSelectionbar.boxObject.screenX;
            var newStart = this.moveTime(this.mStartDate, delta, true);
            if (newStart.compare(this.mEndDate) >= 0) {
                if (!this.mStartDate.isDate) {
                    newStart = this.mEndDate;
                }
                else{
                    return;
                }
            }
            if (newStart.compare(this.mStartDate) != 0) {
                this.startDate = newStart;
                this.update();
            }
        } else if (this.mDragState == 3) {
            // Move the enddate only..
            var delta = mouseX - (this.mSelectionbar.boxObject.screenX +
                                  this.mSelectionbar.boxObject.width);
            var newEnd = this.moveTime(this.mEndDate, delta, true);
            if (newEnd.compare(this.mStartDate) < 0) {
                newEnd = this.mStartDate;
            }
            if (newEnd.compare(this.mEndDate) != 0) {
                // We need to adapt this date in case we're dealing with
                // an all-day event. This is because setting 'endDate' will
                // automatically add one day extra for all-day events.
                if (newEnd.isDate) {
                    newEnd.day--;
                }

                // Don't allow all-day events to be shorter than a single day.
                if (!newEnd.isDate || (newEnd.compare(this.startDate) >= 0)) {
                    this.endDate = newEnd;
                    this.update();
                }
            }
        }
      ]]></handler>

      <handler event="mouseup"><![CDATA[
        this.mDragState = 0;
        window.setCursor("auto");
      ]]></handler>
    </handlers>
  </binding>

  <binding id="attendees-page">
    <content>
      <xul:box orient="vertical" flex="1">
        <xul:box orient="horizontal" align="center" pack="end">
          <xul:spacer flex="1"/>
          <xul:label value="&event.freebusy.suggest.slot;"/>
          <xul:button label="&event.freebusy.previous.slot;"
                      dir="normal"
                      class="left-icon"
                      anonid="previous-slot"
                      oncommand="onPreviousSlot();"/>
          <xul:button label="&event.freebusy.next.slot;"
                      dir="reverse"
                      class="right-icon"
                      anonid="next-slot"
                      oncommand="onNextSlot();"/>
          <xul:spacer style="width: 10em"/>
          <xul:label value="&event.freebusy.zoom;"/>
          <xul:image class="zoom-out-icon"/>
          <xul:menulist anonid="zoom-menulist"
                        oncommand="onZoomFactor(this.value);">
            <xul:menupopup>
              <xul:menuitem label="400%" value="25"/>
              <xul:menuitem label="200%" value="50"/>
              <xul:menuitem label="100%" value="100"/>
              <xul:menuitem label="50%" value="200"/>
              <xul:menuitem label="25%" value="400"/>
            </xul:menupopup>
          </xul:menulist>
          <xul:image class="zoom-in-icon"/>
        </xul:box>
        <xul:box orient="horizontal" flex="1">
          <xul:box orient="vertical" flex="1">
            <xul:box class="attendee-spacer-top"/>
            <xul:attendees-list flex="1" anonid="attendees-list"/>
            <xul:box class="attendee-spacer-bottom"/>
          </xul:box>
          <xul:splitter anonid="splitter"/>
          <xul:box orient="vertical">
            <xul:stack flex="1">
              <xul:box orient="vertical" flex="1">
                <xul:freebusy-timebar anonid="timebar"
                                      xbl:inherits="range"/>
                <xul:freebusy-grid flex="1"
                                   anonid="freebusy-grid"
                                   xbl:inherits="range"/>
              </xul:box>
              <xul:selection-bar anonid="selection-bar"
                                 xbl:inherits="range"/>
            </xul:stack>
            <xul:scrollbar orient="horizontal"
                           anonid="horizontal-scrollbar"
                           maxpos="100"/>
          </xul:box>
          <xul:box orient="vertical"
                   anonid="vertical-scrollbar-box"
                   collapsed="true">
            <xul:box class="attendee-spacer-top"/>
            <xul:scrollbar orient="vertical"
                           flex="1"
                           anonid="vertical-scrollbar"
                           maxpos="100"/>
            <xul:box class="attendee-spacer-bottom"/>
          </xul:box>
        </xul:box>
        <xul:box orient="horizontal">
          <xul:box orient="vertical" flex="1">
            <xul:box orient="horizontal" align="center">
              <xul:box class="legend" status="FREE"/>
              <xul:label value="&event.freebusy.legend.free;"/>
            </xul:box>
            <xul:box orient="horizontal" align="center">
              <xul:box class="legend" status="BUSY"/>
              <xul:label value="&event.freebusy.legend.busy;"/>
            </xul:box>
            <xul:box orient="horizontal" align="center">
              <xul:box class="legend" status="UNKNOWN"/>
              <xul:label value="&event.freebusy.legend.unknown;"/>
            </xul:box>
            <xul:box orient="horizontal">
              <xul:button label="&event.freebusy.minus;"
                          oncommand="onMinus();"/>
              <xul:button label="&event.freebusy.plus;"
                          oncommand="onPlus();"/>
            </xul:box>
            <xul:box orient="horizontal" collapsed="true">
              <xul:label value="&event.organizer.label;" disabled="true"/>
              <xul:textbox anonid="event-organizer"
                           disabled="true"
                           flex="true"/>
            </xul:box>
          </xul:box>
          <xul:grid>
            <xul:columns>
              <xul:column/>
              <xul:column flex="1"/>
            </xul:columns>
            <xul:rows>
              <xul:row align="center">
                <xul:spacer/>
                <xul:checkbox anonid="all-day"
                              oncommand="changeAllDay();"
                              label="&event.alldayevent.label;"/>
              </xul:row>
              <xul:row align="center">
                <xul:label value="&newevent.from.label;"/>
                <xul:datetimepicker anonid="event-starttime"
                                    onchange="updateStartTime();"/>
                <xul:label anonid="timezone-starttime"
                           crop="right"
                           class="text-link"
                           flex="1"
                           collapsed="true"
                           hyperlink="true"
                           onclick="editStartTimezone()"/>
              </xul:row>
              <xul:row align="center">
                <xul:label value="&newevent.to.label;"/>
                <xul:datetimepicker anonid="event-endtime"
                                    onchange="updateEndTime();"/>
                <xul:label anonid="timezone-endtime"
                           crop="right"
                           class="text-link"
                           flex="1"
                           collapsed="true"
                           hyperlink="true"
                           onclick="editEndTimezone()"/>
              </xul:row>
            </xul:rows>
          </xul:grid>
        </xul:box>
        <xul:separator class="groove"/>
      </xul:box>
    </content>

    <implementation>
      <field name="mStartDate">null</field>
      <field name="mEndDate">null</field>
      <field name="mStartTimezone">null</field>
      <field name="mEndTimezone">null</field>
      <field name="mDuration">null</field>
      <field name="mStartHour">8</field>
      <field name="mEndHour">19</field>
      <field name="mStartHourDefault">8</field>
      <field name="mEndHourDefault">19</field>

      <field name="mIsReadOnly">false</field>
      <field name="mIsInvitation">false</field>
      <field name="mIgnoreUpdate">false</field>
      <field name="mDisplayTimezone">true</field>

      <field name="mUndoStack">[]</field>

      <field name="mForce24Hours">false</field>
      <field name="mZoomFactor">100</field>

      <property name="zoomFactor">
        <getter><![CDATA[
          return this.mZoomFactor;
        ]]></getter>
        <setter><![CDATA[
          if (this.mZoomFactor == val) {
              return val;
          }

          this.mZoomFactor = val;
          var timebar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timebar");
          timebar.zoomFactor = this.mZoomFactor;
          var selectionbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "selection-bar");
          selectionbar.zoomFactor = this.mZoomFactor;
          var grid =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "freebusy-grid");
          grid.zoomFactor = this.mZoomFactor;

          // Calling onResize() will update the scrollbars and everything else
          // that needs to adopt the previously made changes. We need to call
          // this after the changes have actually been made...
          this.onResize();

          var scrollbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "horizontal-scrollbar");
          if (scrollbar.hasAttribute("maxpos")) {
              var curpos = scrollbar.getAttribute("curpos");
              var maxpos = scrollbar.getAttribute("maxpos");
              var ratio = curpos / maxpos;
              timebar.scroll = ratio;
              grid.scroll = ratio;
              selectionbar.ratio = ratio;
          }

          return val;
        ]]></setter>
      </property>

      <property name="force24Hours">
        <getter><![CDATA[
          return this.mForce24Hours;
        ]]></getter>
        <setter><![CDATA[
          if (this.mForce24Hours == val) {
            return val;
          }

          this.mForce24Hours = val;
          this.initTimeRange();
          var timebar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timebar");
          timebar.force24Hours = this.mForce24Hours;
          var selectionbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "selection-bar");
          selectionbar.force24Hours = this.mForce24Hours;
          var grid =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "freebusy-grid");
          grid.force24Hours = this.mForce24Hours;

          // Calling onResize() will update the scrollbars and everything else
          // that needs to adopt the previously made changes. We need to call
          // this after the changes have actually been made...
          this.onResize();

          var scrollbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "horizontal-scrollbar");
          if (!scrollbar.hasAttribute("maxpos")) {
              return val;
          }
          var curpos = scrollbar.getAttribute("curpos");
          var maxpos = scrollbar.getAttribute("maxpos");
          var ratio = curpos / maxpos;
          timebar.scroll = ratio;
          grid.scroll = ratio;
          selectionbar.ratio = ratio;

          return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
        var args = window.arguments[0];

        this.initTimeRange();

        var self = this;
        var load = function attendeesPage_loadHandler() {
            self.onLoad();
        };
        window.addEventListener("load", load, true);
        var resize = function attendeesPage_resizeHandler() {
            self.onResize();
        };
        window.addEventListener("resize", resize, true);

        var freebusy =
            document.getAnonymousElementByAttribute(
                this, "anonid", "freebusy-grid");
        var modify = function attendeesPage_modifyHandler(event) {
            self.onResize();
            freebusy.onModify(event);
        };
        this.addEventListener("modify", modify, true);

        var focus = function attendeesPage_focusHandler(event) {
            var scrollbar =
                document.getAnonymousElementByAttribute(
                    self, "anonid", "vertical-scrollbar");
            var attendees =
                document.getAnonymousElementByAttribute(
                    self, "anonid", "attendees-list");
            var maxpos = scrollbar.getAttribute("maxpos");
            scrollbar.setAttribute("curpos", event.details / attendees.mMaxAttendees * maxpos);
        };
        this.addEventListener("rowchange", focus, true);
      ]]></constructor>

      <method name="onZoomFactor">
        <parameter name="aValue"/>
        <body><![CDATA[
          this.zoomFactor = parseInt(aValue);
        ]]></body>
      </method>

      <method name="initTimeRange">
        <body><![CDATA[
          this.mStartHour = this.mStartHourDefault;
          this.mEndHour = this.mEndHourDefault;

          var pb2 = Components.classes[
              "@mozilla.org/preferences-service;1"]
                  .getService(Components.interfaces.nsIPrefBranch2);

          // get default start/end times from prefs and set on the
          // view.  if we hit an error (eg because sunbird's pref
          // infrastructure hasn't created the pref yet), the
          // defaults will do
          try {
              this.mStartHour = pb2.getIntPref("calendar.view.defaultstarthour");
              this.mEndHour = pb2.getIntPref("calendar.view.defaultendhour");
          } catch (ex) {
          }

          if (this.force24Hours) {
              this.mStartHour = 0;
              this.mEndHour = 24;
          }
        ]]></body>
      </method>

      <method name="loadDateTime">
        <parameter name="aStartDate"/>
        <parameter name="aEndDate"/>
        <body><![CDATA[
          this.mDuration = aEndDate.subtractDate(aStartDate);
          var kDefaultTimezone = calendarDefaultTimezone();
          this.mStartTimezone = aStartDate.timezone;
          this.mEndTimezone = aEndDate.timezone;
          this.mStartDate = aStartDate.getInTimezone(kDefaultTimezone);
          this.mEndDate = aEndDate.getInTimezone(kDefaultTimezone);
          this.mStartDate.makeImmutable();
          this.mEndDate.makeImmutable();
        ]]></body>
      </method>

      <method name="saveDateTime">
        <body><![CDATA[
          var kDefaultTimezone = calendarDefaultTimezone();
          var startTime = this.mStartDate.getInTimezone(this.mStartTimezone);
          var endTime = this.mEndDate.getInTimezone(this.mEndTimezone);
          this.mStartDate = startTime;
          this.mEndDate = endTime;
        ]]></body>
      </method>

      <method name="propagateDateTime">
        <body><![CDATA[
          // Fill the controls
          this.updateDateTime();

          // Tell the timebar about the new start/enddate
          var timebar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timebar");
          timebar.startDate = this.mStartDate;
          timebar.endDate = this.mEndDate;
          timebar.refresh();

          // Tell the selection-bar about the new start/enddate
          var selectionbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "selection-bar");
          selectionbar.startDate = this.mStartDate;
          selectionbar.endDate = this.mEndDate;
          selectionbar.update();

          // Tell the freebusy grid about the new start/enddate
          var grid =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "freebusy-grid");

          var refresh = (grid.startDate == null) ||
                        (grid.startDate.compare(this.mStartDate) != 0) ||
                        (grid.endDate == null) ||
                        (grid.endDate.compare(this.mEndDate) != 0);
          grid.startDate = this.mStartDate;
          grid.endDate = this.mEndDate;
          if (refresh) {
              grid.forceRefresh();
          }

          // Expand to 24hrs if the new range is outside of the default range.
          var kDefaultTimezone = calendarDefaultTimezone();
          var startTime = this.mStartDate.getInTimezone(kDefaultTimezone);
          var endTime = this.mEndDate.getInTimezone(kDefaultTimezone);
          if ((startTime.hour < this.mStartHour) ||
              (endTime.hour > this.mEndHour) ||
              (startTime.isDate)) {
              this.force24Hours = true;
          }
        ]]></body>
      </method>

      <!-- assumes this.mStartDate and this.mEndDate are up to date. -->
      <method name="updateDateTime">
        <body><![CDATA[
          // Convert to default timezone if the timezone option
          // is *not* checked, otherwise keep the specific timezone
          // and display the labels in order to modify the timezone.
          if (this.mDisplayTimezone) {
              var startTime = this.mStartDate.getInTimezone(this.mStartTimezone);
              var endTime = this.mEndDate.getInTimezone(this.mEndTimezone);

              if (startTime.isDate) {
                  document.getAnonymousElementByAttribute(
                      this, "anonid", "all-day")
                          .setAttribute("checked", "true");
              }

              // In the case where the timezones are different but
              // the timezone of the endtime is "UTC", we convert
              // the endtime into the timezone of the starttime.
              if (startTime && endTime) {
                  if (startTime.timezone != endTime.timezone) {
                      if (endTime.timezone == "UTC") {
                          endTime = endTime.getInTimezone(startTime.timezone);
                      }
                  }
              }

              // Before feeding the date/time value into the control we need
              // to set the timezone to 'floating' in order to avoid the
              // automatic conversion back into the OS timezone.
              startTime.timezone = "floating";
              endTime.timezone = "floating";

              document.getAnonymousElementByAttribute(
                  this, "anonid", "event-starttime")
                      .value = startTime.jsDate;
              document.getAnonymousElementByAttribute(
                  this, "anonid", "event-endtime")
                      .value = endTime.jsDate;
          } else {
              var kDefaultTimezone = calendarDefaultTimezone();

              var startTime = this.mStartDate.getInTimezone(kDefaultTimezone);
              var endTime = this.mEndDate.getInTimezone(kDefaultTimezone);

              if (startTime.isDate) {
                  document.getAnonymousElementByAttribute(
                      this, "anonid", "all-day")
                          .setAttribute("checked", "true");
              }

              // Before feeding the date/time value into the control we need
              // to set the timezone to 'floating' in order to avoid the
              // automatic conversion back into the OS timezone.
              startTime.timezone = "floating";
              endTime.timezone = "floating";

              document.getAnonymousElementByAttribute(
                  this, "anonid", "event-starttime")
                      .value = startTime.jsDate;
              document.getAnonymousElementByAttribute(
                  this, "anonid", "event-endtime")
                      .value = endTime.jsDate;
          }

          this.updateTimezone();
          this.updateAllDay();
        ]]></body>
      </method>

      <method name="timezoneString">
        <parameter name="date"/>
        <body><![CDATA[
          var fragments = date.split('/');
          var num = fragments.length;
          if (num <= 1) {
              return fragments[0];
          }
          return fragments[num - 2] + '/' + fragments[num - 1];
        ]]></body>
      </method>

      <!-- assumes this.mStartDate and this.mEndDate are up to date. -->
      <method name="updateTimezone">
        <body><![CDATA[
          this.mIgnoreUpdate = true;

          if (this.mDisplayTimezone) {
              var startTimezone = this.mStartTimezone;
              var endTimezone = this.mEndTimezone;
              var equalTimezones = false;
              if (startTimezone && endTimezone &&
                  (startTimezone == endTimezone || endTimezone == "UTC")) {
                  equalTimezones = true;
              }

              var tzStart = document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-starttime");
              var tzEnd = document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-endtime");
              if (startTimezone != null) {
                  tzStart.removeAttribute('collapsed');
                  tzStart.value = this.timezoneString(startTimezone);
              } else {
                  tzStart.setAttribute('collapsed', 'true');
              }

              // we never display the second timezone if both are equal
              if (endTimezone != null && !equalTimezones) {
                  tzEnd.removeAttribute('collapsed');
                  tzEnd.value = this.timezoneString(endTimezone);
              } else {
                  tzEnd.setAttribute('collapsed', 'true');
              }
          } else {
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-starttime")
                      .setAttribute('collapsed', 'true');
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-endtime")
                      .setAttribute('collapsed', 'true');
          }

          this.mIgnoreUpdate = false;
        ]]></body>
      </method>

      <method name="updateStartTime">
        <body><![CDATA[
          if (this.mIgnoreUpdate) {
              return;
          }

          var startWidgetId = "event-starttime";
          var endWidgetId = "event-endtime";

          var startWidget = document.getAnonymousElementByAttribute(
              this, "anonid", startWidgetId);
          var endWidget = document.getAnonymousElementByAttribute(
              this, "anonid", endWidgetId);

          // jsDate is always in OS timezone, thus we create a calIDateTime
          // object from the jsDate representation and simply set the new
          // timezone instead of converting.
          var kDefaultTimezone = calendarDefaultTimezone();
          var start = jsDateToDateTime(startWidget.value);
          start = start.getInTimezone(kDefaultTimezone);
          if (this.mDisplayTimezone) {
              start.timezone = this.mStartTimezone;
          }
          this.mStartDate = start.clone();
          start.addDuration(this.mDuration);
          start = start.getInTimezone(this.mEndTimezone);
          if (this.mDisplayTimezone) {
              start.timezone = this.mEndTimezone;
          }
          this.mEndDate = start;

          var allDayElement =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "all-day");
          var allDay = allDayElement.getAttribute("checked") == "true";
          if (allDay) {
              this.mStartDate.isDate = true;
              this.mEndDate.isDate = true;
          }

          this.propagateDateTime();
        ]]></body>
      </method>

      <method name="updateEndTime">
        <body><![CDATA[
          if (this.mIgnoreUpdate) {
              return;
          }

          var startWidgetId = "event-starttime";
          var endWidgetId = "event-endtime";

          var startWidget =
              document.getAnonymousElementByAttribute(
                  this, "anonid", startWidgetId);
          var endWidget =
              document.getAnonymousElementByAttribute(
                  this, "anonid", endWidgetId);

          var saveStartTime = this.mStartDate;
          var saveEndTime = this.mEndDate;
          var kDefaultTimezone = calendarDefaultTimezone();

          var start = jsDateToDateTime(startWidget.value);
          start = start.getInTimezone(kDefaultTimezone);
          if (this.mDisplayTimezone) {
              start.timezone = this.mStartTimezone;
          }
          this.mStartDate = start;

          var end = jsDateToDateTime(endWidget.value);
          end = end.getInTimezone(kDefaultTimezone);
          var timezone = this.mEndTimezone;
          if (timezone == "UTC" &&
              this.mStartDate &&
              this.mStartTimezone != this.mEndTimezone) {
              timezone = this.mStartTimezone;
          }
          if (this.mDisplayTimezone) {
              end.timezone = timezone;
          }
          this.mEndDate = end;

          var allDayElement =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "all-day");
          var allDay = allDayElement.getAttribute("checked") == "true";
          if (allDay) {
              this.mStartDate.isDate = true;
              this.mEndDate.isDate = true;
          }

          // Calculate the new duration of start/end-time.
          // don't allow for negative durations.
          var warning = false;
          if (this.mEndDate.compare(this.mStartDate) >= 0) {
              this.mDuration = end.subtractDate(start);
          } else {
              this.mStartDate = saveStartTime;
              this.mEndDate = saveEndTime;
              warning = true;
          }

          this.propagateDateTime();

          if (warning) {
              var callback = function() {
                  var promptService =
                      Components.classes[
                          "@mozilla.org/embedcomp/prompt-service;1"]
                          .getService(
                              Components.interfaces.nsIPromptService);
                  promptService.alert(
                      null,
                      document.title,
                      calGetString("calendar", "warningNegativeDuration"));
              }
              setTimeout(callback, 1);
          }
        ]]></body>
      </method>

      <method name="editStartTimezone">
        <body><![CDATA[
          var tzStart =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-starttime");
          if (tzStart.hasAttribute("disabled")) {
              return;
          }

          var self = this;
          var args = new Object();
          args.time = this.mStartDate.getInTimezone(this.mStartTimezone);
          args.onOk = function(datetime) {
              var equalTimezones = false;
              if (self.mStartTimezone && self.mEndTimezone &&
                  self.mStartTimezone == self.mEndTimezone) {
                  equalTimezones = true;
              }
              self.mStartTimezone = datetime.timezone;
              if (equalTimezones) {
                  self.mEndTimezone = datetime.timezone;
              }
              self.propagateDateTime();
          };

          // Open the dialog modally
          openDialog(
              "chrome://calendar/content/sun-calendar-event-dialog-timezone.xul",
              "_blank",
              "chrome,titlebar,modal,resizable",
              args);
        ]]></body>
      </method>

      <method name="editEndTimezone">
        <body><![CDATA[
          var tzStart =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-endtime");
          if (tzStart.hasAttribute("disabled")) {
              return;
          }

          var self = this;
          var args = new Object();
          args.time = gEndTime.getInTimezone(gEndTimezone);
          args.onOk = function(datetime) {
              var equalTimezones = false;
              if (self.mStartTimezone && self.mEndTimezone &&
                  self.mStartTimezone == self.mEndTimezone) {
                  equalTimezones = true;
              }
              if (equalTimezones) {
                  self.mStartTimezone = datetime.timezone;
              }
              self.mEndTimezone = datetime.timezone;
              self.propagateDateTime();
          };

          // Open the dialog modally
          openDialog(
              "chrome://calendar/content/sun-calendar-event-dialog-timezone.xul",
              "_blank",
              "chrome,titlebar,modal,resizable",
              args);
        ]]></body>
      </method>

      <method name="updateAllDay">
        <body><![CDATA[
          if (this.mIgnoreUpdate) {
              return;
          }

          var allDayElement =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "all-day");
          var allDay  = (allDayElement.getAttribute("checked") == "true");
          var startpicker =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "event-starttime");
          var endpicker =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "event-endtime");

          var tzStart =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-starttime");
          var tzEnd =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timezone-endtime");

          // Disable the timezone links if 'allday' is checked OR the
          // calendar of this item is read-only. In any other case we
          // enable the links.
          if (allDay) {
              startpicker.setAttribute("timepickerdisabled", "true");
              endpicker.setAttribute("timepickerdisabled", "true");

              tzStart.setAttribute("disabled", "true");
              tzEnd.setAttribute("disabled", "true");
              tzStart.removeAttribute("class");
              tzEnd.removeAttribute("class");
          } else {
              startpicker.removeAttribute("timepickerdisabled");
              endpicker.removeAttribute("timepickerdisabled");

              tzStart.removeAttribute("disabled");
              tzEnd.removeAttribute("disabled");
              tzStart.setAttribute("class", "text-link");
              tzEnd.setAttribute("class", "text-link");
          }
        ]]></body>
      </method>

      <method name="changeAllDay">
        <body><![CDATA[
          var allDayElement =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "all-day");
          var allDay = (allDayElement.getAttribute("checked") == "true");

          this.mStartDate = this.mStartDate.clone();
          this.mEndDate = this.mEndDate.clone();

          this.mStartDate.isDate = allDay;
          this.mEndDate.isDate = allDay;

          this.propagateDateTime();

          // After propagating the modified times we enforce some constraints
          // on the zoom-factor. in case this events is now said to be all-day,
          // we automatically enforce a 25% zoom-factor and disable the control.
          var zoom =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "zoom-menulist");
          if (allDay) {
              zoom.value = "400";
              zoom.setAttribute("disabled", "true");
              this.zoomFactor = zoom.value;
              this.force24Hours = true;
          } else {
              zoom.removeAttribute("disabled");
          }
        ]]></body>
      </method>

      <property name="startDate">
        <getter><![CDATA[
          return this.mStartDate;
        ]]></getter>
      </property>

      <property name="endDate">
        <getter><![CDATA[
          return this.mEndDate;
        ]]></getter>
      </property>

      <property name="attendees">
        <getter><![CDATA[
          var attendeelist =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "attendees-list");
          return attendeelist.attendees;
        ]]></getter>
      </property>

      <property name="organizer">
        <getter><![CDATA[
          var attendeelist =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "attendees-list");
          return attendeelist.organizer;
        ]]></getter>
      </property>

      <method name="onResize">
        <body><![CDATA[
            // Don't do anything if we haven't been initialized.
            if (!this.mStartDate || !this.mEndDate) {
                return;
            }

            var grid =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "freebusy-grid");
            var gridScrollbar =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "horizontal-scrollbar");
            grid.fitDummyRows();
            var ratio = grid.boxObject.width / grid.documentSize;
            var maxpos = gridScrollbar.getAttribute("maxpos");
            var inc = maxpos * ratio / (1 - ratio);
            gridScrollbar.setAttribute("pageincrement", inc);

            var attendees =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "attendees-list");
            var attendeesScrollbar =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "vertical-scrollbar");
            var box =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "vertical-scrollbar-box");
            attendees.fitDummyRows();
            var ratio = attendees.boxObject.height / attendees.documentSize;
            if (ratio < 1) {
                box.removeAttribute("collapsed");
                var maxpos = attendeesScrollbar.getAttribute("maxpos");
                var inc = maxpos * ratio / (1 - ratio);
                attendeesScrollbar.setAttribute("pageincrement", inc);
            } else {
                box.setAttribute("collapsed", "true");
            }
        ]]></body>
      </method>

      <method name="onLoad">
        <body><![CDATA[
          var args = window.arguments[0];
          var startTime = args.startTime;
          var endTime = args.endTime;
          var calendar = args.calendar;

          this.mDisplayTimezone = args.displayTimezone;

          this.onChangeCalendar(calendar);

          // we need to enfore several layout constraints which can't be modelled
          // with plain xul and css, at least as far as i know.
          const kStylesheet = "chrome://calendar/content/sun-calendar-event-dialog.css";
          for each (var stylesheet in document.styleSheets) {
              if (stylesheet.href == kStylesheet) {
                  // make the dummy-spacer #1 [top] the same height as the timebar
                  var timebar =
                      document.getAnonymousElementByAttribute(
                          this, "anonid", "timebar");
                  stylesheet.insertRule(
                      ".attendee-spacer-top { height: "
                          + timebar.boxObject.height+"px; }", 0);
                  // make the dummy-spacer #2 [bottom] the same height as the scrollbar
                  var scrollbar =
                      document.getAnonymousElementByAttribute(
                          this, "anonid", "horizontal-scrollbar");
                  stylesheet.insertRule(
                      ".attendee-spacer-bottom { height: "
                          + scrollbar.boxObject.height+"px; }", 0);
                  break;
              }
          }

          var zoom =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "zoom-menulist");
          zoom.value = "100";

          // Check if an all-day event has been passed in (to adapt endDate).
          if (startTime.isDate) {
              startTime = startTime.clone();
              endTime = endTime.clone();

              endTime.day--;

              // for all-day events we expand to 24hrs, set zoom-factor to 25%
              // and disable the zoom-control.
              this.force24Hours = true;
              zoom.value = "400";
              zoom.setAttribute("disabled", "true");
              this.zoomFactor = zoom.value;
          }

          this.loadDateTime(startTime, endTime);
          this.propagateDateTime();

          this.updateButtons();
        ]]></body>
      </method>

      <method name="onChangeCalendar">
        <parameter name="calendar"/>
        <body><![CDATA[
          var args = window.arguments[0];
          var organizer = args.organizer;

          // set 'mIsReadOnly' if the calendar is read-only
          if (calendar && calendar.readOnly) {
              this.mIsReadOnly = true;
          }

          // assume we're the organizer [in case that the calendar
          // does not support the concept of identities].
          this.mIsInvitation = false;

          try {
              this.mIsInvitation = provider.isInvitation(args.item);
          }
          catch (e) {
          }

          if (this.mIsReadOnly || this.mIsInvitation) {
              document.getAnonymousElementByAttribute(
                  this, "anonid", "next-slot")
                      .setAttribute('disabled', 'true');
              document.getAnonymousElementByAttribute(
                  this, "anonid", "previous-slot")
                      .setAttribute('disabled', 'true');
          }

          var freebusy =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "freebusy-grid");
          freebusy.onChangeCalendar(calendar);
        ]]></body>
      </method>

      <method name="updateButtons">
        <body><![CDATA[
          var previousButton =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "previous-slot");
          if (this.mUndoStack.length > 0) {
              previousButton.removeAttribute('disabled');
          } else {
              previousButton.setAttribute('disabled', 'true');
          }
        ]]></body>
      </method>

      <method name="onNextSlot">
        <body><![CDATA[
          // Store the current setting in the undo-stack.
          var currentSlot = {};
          currentSlot.startTime = this.mStartDate;
          currentSlot.endTime = this.mEndDate;
          this.mUndoStack.push(currentSlot);

          // Ask the grid for the next possible timeslot.
          var grid =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "freebusy-grid");
          var duration = this.mEndDate.subtractDate(this.mStartDate);
          var start = grid.nextSlot();
          var end = start.clone();
          end.addDuration(duration);
          if (start.isDate) {
              end.day++;
          }
          this.mStartDate = start.clone();
          this.mEndDate = end.clone();
          var endDate = this.mEndDate.clone();

          // Check if an all-day event has been passed in (to adapt endDate).
          if (this.mStartDate.isDate) {
              this.mEndDate.day--;
          }
          this.mStartDate.makeImmutable();
          this.mEndDate.makeImmutable();
          endDate.makeImmutable();

          this.propagateDateTime();

          // Scroll the grid/timebar such that the current time is visible
          this.scrollToCurrentTime();

          this.updateButtons();
        ]]></body>
      </method>

      <method name="onPreviousSlot">
        <body><![CDATA[
          var previousSlot = this.mUndoStack.pop();
          if (!previousSlot) {
              return;
          }

          // In case the new starttime happens to be scheduled
          // on a different day, we also need to update the
          // complete freebusy informations and appropriate
          // underlying arrays holding the information.
          var refresh = previousSlot.startTime.day != this.mStartDate.day;

          this.mStartDate = previousSlot.startTime.clone();
          this.mEndDate = previousSlot.endTime.clone();
          var endDate = this.mEndDate.clone();

          this.propagateDateTime();

          // scroll the grid/timebar such that the current time is visible
          this.scrollToCurrentTime();

          this.updateButtons();

          if (refresh) {
              var grid =
                  document.getAnonymousElementByAttribute(
                      this, "anonid", "freebusy-grid");
              grid.forceRefresh();
          }
        ]]></body>
      </method>

      <method name="onMinus">
        <body><![CDATA[
          var timebar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timebar");
          var ratio = timebar.scroll;
          ratio -= timebar.step;
          if (ratio <= 0.0) {
              ratio = 0.0;
          }
          var scrollbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "horizontal-scrollbar");
          var maxpos = scrollbar.getAttribute("maxpos");
          scrollbar.setAttribute("curpos", ratio * maxpos);
        ]]></body>
      </method>

      <method name="onPlus">
        <body><![CDATA[
          var timebar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timebar");
          var ratio = timebar.scroll;
          ratio += timebar.step;
          if (ratio >= 1.0) {
              ratio = 1.0;
          }
          var scrollbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "horizontal-scrollbar");
          var maxpos = scrollbar.getAttribute("maxpos");
          scrollbar.setAttribute("curpos", ratio * maxpos);
        ]]></body>
      </method>

      <method name="scrollToCurrentTime">
        <body><![CDATA[
          var timebar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "timebar");
          var ratio = (this.mStartDate.hour - this.mStartHour) * timebar.step;
          if (ratio <= 0.0) {
              ratio = 0.0;
          }
          if (ratio >= 1.0) {
              ratio = 1.0;
          }
          var scrollbar =
              document.getAnonymousElementByAttribute(
                  this, "anonid", "horizontal-scrollbar");
          var maxpos = scrollbar.getAttribute("maxpos");
          scrollbar.setAttribute("curpos", ratio * maxpos);
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="DOMMouseScroll" phase="capturing"><![CDATA[
        // ignore mouse scrolling for now...
        event.stopPropagation();
      ]]></handler>

      <handler event="DOMAttrModified"><![CDATA[
        if (event.attrName == "width") {
            var selectionbar =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "selection-bar");
            selectionbar.setWidth(selectionbar.boxObject.width);
            return;
        }

        // Synchronize grid and attendee list
        var target = event.originalTarget;
        if (target.hasAttribute("anonid") &&
            target.getAttribute("anonid") == "input" &&
            event.attrName == "focused" &&
            event.newValue == "true") {
            var attendees =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "attendees-list");
            var grid =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "freebusy-grid");
            if (grid.firstVisibleRow != attendees.firstVisibleRow) {
                grid.firstVisibleRow = attendees.firstVisibleRow;
            }
        }

        var scrollbar = event.originalTarget.parentNode;
        if (!scrollbar.hasAttribute("maxpos")) {
            return;
        }
        if (scrollbar.getAttribute("anonid") == "vertical-scrollbar") {
            var attendees =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "attendees-list");
            var grid =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "freebusy-grid");
            if (event.attrName == "curpos") {
                var maxpos = scrollbar.getAttribute("maxpos");
                attendees.ratio = event.newValue / maxpos;
            }
            grid.firstVisibleRow = attendees.firstVisibleRow;
        } else if (scrollbar.getAttribute("anonid") == "horizontal-scrollbar") {
            if (event.attrName == "curpos") {
                var maxpos = scrollbar.getAttribute("maxpos");
                var ratio = event.newValue/maxpos;
                var timebar =
                    document.getAnonymousElementByAttribute(
                        this, "anonid", "timebar");
                var grid =
                    document.getAnonymousElementByAttribute(
                        this, "anonid", "freebusy-grid");
                var selectionbar =
                    document.getAnonymousElementByAttribute(
                        this, "anonid", "selection-bar");
                timebar.scroll = ratio;
                grid.scroll = ratio;
                selectionbar.ratio = ratio;
            }
        }
      ]]></handler>

      <handler event="timebar"><![CDATA[
        var selectionbar =
            document.getAnonymousElementByAttribute(
                this, "anonid", "selection-bar");
        selectionbar.init(event.details, event.height);
      ]]></handler>

      <handler event="timechange"><![CDATA[
        var start = event.startDate.getInTimezone(this.mStartTimezone);
        var end = event.endDate.getInTimezone(this.mEndTimezone);

        this.loadDateTime(start, end);

        // fill the controls
        this.updateDateTime();

        // tell the timebar about the new start/enddate
        var timebar =
            document.getAnonymousElementByAttribute(
                this, "anonid", "timebar");
        timebar.startDate = this.mStartDate;
        timebar.endDate = this.mEndDate;
        timebar.refresh();

        // tell the freebusy grid about the new start/enddate
        var grid =
            document.getAnonymousElementByAttribute(
                this, "anonid", "freebusy-grid");

        var refresh = (grid.startDate == null) ||
                      (grid.startDate.compare(this.mStartDate) != 0) ||
                      (grid.endDate == null) ||
                      (grid.endDate.compare(this.mEndDate) != 0);
        grid.startDate = this.mStartDate;
        grid.endDate = this.mEndDate;
        if (refresh) {
            grid.forceRefresh();
        }
      ]]></handler>
    </handlers>
  </binding>
</bindings>
