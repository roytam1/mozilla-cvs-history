#! /usr/local/bin/perl

# The contents of this file are subject to the Netscape Public License
# Version 1.0 (the "License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.mozilla.org/NPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
# the License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is Netscape Communications
# Corporation.  Portions created by Netscape are Copyright (C) 1998
# Netscape Communications Corporation.  All Rights Reserved.

######################################################################

# Table of tag names; it doesn't have to be sorted because code
# below will do it. However, for the sake of ease of additions, keep
# it sorted so that its easy to tell where to add a new tag and that
# the tag hasn't already been added.
$i = 0;
$tags[$i++] = "action";
$tags[$i++] = "attach";
$tags[$i++] = "attendee";
$tags[$i++] = "begin";
$tags[$i++] = "calscale";
$tags[$i++] = "categories";
$tags[$i++] = "class";
$tags[$i++] = "comment";
$tags[$i++] = "completed";
$tags[$i++] = "contact";
$tags[$i++] = "created";
$tags[$i++] = "daylight";
$tags[$i++] = "description";
$tags[$i++] = "dtend";
$tags[$i++] = "dtstart";
$tags[$i++] = "due";
$tags[$i++] = "duration";
$tags[$i++] = "end";
$tags[$i++] = "exdate";
$tags[$i++] = "exrule";
$tags[$i++] = "freebusy";
$tags[$i++] = "geo";
$tags[$i++] = "last_modified";
$tags[$i++] = "location";
$tags[$i++] = "method";
$tags[$i++] = "organizer";
$tags[$i++] = "percent_complete";
$tags[$i++] = "priority";
$tags[$i++] = "prodid";
$tags[$i++] = "rdate";
$tags[$i++] = "rrule";
$tags[$i++] = "recurrence_id";
$tags[$i++] = "related_to";
$tags[$i++] = "repeat";
$tags[$i++] = "request_status";
$tags[$i++] = "resources";
$tags[$i++] = "sequence";
$tags[$i++] = "standard";
$tags[$i++] = "status";
$tags[$i++] = "summary";
$tags[$i++] = "transp";
$tags[$i++] = "trigger";
$tags[$i++] = "tzid";
$tags[$i++] = "tzname";
$tags[$i++] = "tzoffsetfrom";
$tags[$i++] = "tzoffsetto";
$tags[$i++] = "tzurl";
$tags[$i++] = "uid";
$tags[$i++] = "url";
$tags[$i++] = "valarm";
$tags[$i++] = "vcalendar";
$tags[$i++] = "version";
$tags[$i++] = "vevent";
$tags[$i++] = "vfreebusy";
$tags[$i++] = "vjournal";
$tags[$i++] = "vtimezone";
$tags[$i++] = "vtodo";

######################################################################

# These are not tags; rather they are extra values to place into the
# tag enumeration after the normal tags. These do not need to be sorted
# and they do not go into the tag table, just into the tag enumeration.
$extra = 0;
$extra_tags[$extra++] = "text";
$extra_tags[$extra++] = "whitespace";
$extra_tags[$extra++] = "newline";
$extra_tags[$extra++] = "entity";
$extra_tags[$extra++] = "userdefined";

######################################################################

# Sort the tag table before using it
@tags = sort @tags;

$copyright = "/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * The contents of this file are subject to the Netscape Public License
 * Version 1.0 (the \"License\"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of the License at
 * http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an \"AS IS\"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is Mozilla Communicator client code.
 *
 * The Initial Developer of the Original Code is Netscape Communications
 * Corporation.  Portions created by Netscape are Copyright (C) 1998
 * Netscape Communications Corporation.  All Rights Reserved.
 */

/* Do not edit - generated by gentags.pl */
";

######################################################################

$file_base = @ARGV[0];

# Generate the header file first
open(HEADER_FILE, ">$file_base.h");

# Print out copyright and do not edit notice
print HEADER_FILE $copyright;
print HEADER_FILE "#ifndef " . $file_base . "_h___\n";
print HEADER_FILE "#define " . $file_base . "_h___\n";
print HEADER_FILE "#include \"nscalicalendarpars.h\"\n";

# Print out enum's for the tag symbols
print HEADER_FILE "enum nsCalICalendarTag {\n";
print HEADER_FILE "  /* this enum must be first and must be zero */\n";
print HEADER_FILE "  eCalICalendarTag_unknown=0,\n\n";
print HEADER_FILE "  /* begin tag enums */\n  ";
$width = 2;
print HEADER_FILE $str;
for ($j = 0; $j < $i; $j++) {
    $lower = $tags[$j];
    $lower =~ tr/A-Z/a-z/;
    $str = "eCalICalendarTag_" . $lower . "=" . ($j + 1);
    $str = $str . ", ";
    $len = length($str);
    if ($width + $len > 78) {
	print HEADER_FILE "\n  ";
	$width = 2;
    }
    print HEADER_FILE $str;
    $width = $width + $len;
}
print HEADER_FILE "\n\n  /* The remaining enums are not for tags */\n  ";

# Print out extra enum's that are not in the tag table
$width = 2;
for ($k = 0; $k < $extra; $k++) {
    $lower = $extra_tags[$k];
    $lower =~ tr/A-Z/a-z/;
    $str = "eCalICalendarTag_" . $lower . "=" . ($j + $k + 1);
    if ($k < $extra - 1) {
	$str = $str . ", ";
    }
    $len = length($str);
    if ($width + $len > 78) {
	print HEADER_FILE "\n  ";
	$width = 2;
    }
    print HEADER_FILE $str;
    $width = $width + $len;
}

print HEADER_FILE "\n};\n#define NS_CALICALENDAR_TAG_MAX " . $j . "\n\n";
print HEADER_FILE "extern NS_CALICALENDARPARS nsCalICalendarTag NS_CalICalendarTagToEnum(const char* aTag);\n";
print HEADER_FILE "extern NS_CALICALENDARPARS const char* NS_CalICalendarEnumToTag(nsCalICalendarTag aEnum);\n\n";
print HEADER_FILE "#endif /* " . $file_base . "_h___ */\n";
close(HEADER_FILE);

######################################################################

# Generate the source file
open(CPP_FILE, ">$file_base.cpp");
print CPP_FILE $copyright;
print CPP_FILE "#include \"nsCRT.h\"\n";
print CPP_FILE "#include \"$file_base.h\"\n\n";

# Print out table of tag names
print CPP_FILE "static char* tagTable[] = {\n  ";
$width = 2;
for ($j = 0; $j < $i; $j++) {
    $upper = $tags[$j];
    $upper =~ tr/a-z/A-Z/;
    $upper =~ s/_/-/;
    $str = "\"" . $upper . "\"";
    if ($j < $i - 1) {
	$str = $str . ", ";
    }
    $len = length($str);
    if ($width + $len > 78) {
	print CPP_FILE "\n  ";
	$width = 2;
    } 
    print CPP_FILE $str;
    $width = $width + $len;
}
print CPP_FILE "\n};\n";

# Finally, dump out the search routine that takes a char* and finds it
# in the table.
print CPP_FILE "
nsCalICalendarTag NS_CalICalendarTagToEnum(const char* aTag) {
  int low = 0;
  int high = NS_CALICALENDAR_TAG_MAX - 1;
  while (low <= high) {
    int middle = (low + high) >> 1;
    int result = nsCRT::strcasecmp(aTag, tagTable[middle]);
    if (result == 0)
      return (nsCalICalendarTag) (middle + 1);
    if (result < 0)
      high = middle - 1; 
    else
      low = middle + 1; 
  }
  return eCalICalendarTag_userdefined;
}

const char* NS_CalICalendarEnumToTag(nsCalICalendarTag aTagID) {
  if ((int(aTagID) <= 0) || (int(aTagID) > NS_CALICALENDAR_TAG_MAX)) {
    return 0;
  }
  return tagTable[int(aTagID) - 1];
}

#ifdef NS_DEBUG
#include <stdio.h>

class nsCalICalendarTestTagTable {
public:
   nsCalICalendarTestTagTable() {
     const char *tag;
     nsCalICalendarTag id;

     // Make sure we can find everything we are supposed to
     for (int i = 0; i < NS_CALICALENDAR_TAG_MAX; i++) {
       tag = tagTable[i];
       id = NS_CalICalendarTagToEnum(tag);
       NS_ASSERTION(id != eCalICalendarTag_userdefined, \"can't find tag id\");
       const char* check = NS_CalICalendarEnumToTag(id);
       NS_ASSERTION(check == tag, \"can't map id back to tag\");
     }

     // Make sure we don't find things that aren't there
     id = NS_CalICalendarTagToEnum(\"@\");
     NS_ASSERTION(id == eCalICalendarTag_userdefined, \"found @\");
     id = NS_CalICalendarTagToEnum(\"zzzzz\");
     NS_ASSERTION(id == eCalICalendarTag_userdefined, \"found zzzzz\");

     tag = NS_CalICalendarEnumToTag((nsCalICalendarTag) 0);
     NS_ASSERTION(0 == tag, \"found enum 0\");
     tag = NS_CalICalendarEnumToTag((nsCalICalendarTag) -1);
     NS_ASSERTION(0 == tag, \"found enum -1\");
     tag = NS_CalICalendarEnumToTag((nsCalICalendarTag) (NS_CALICALENDAR_TAG_MAX + 1));
     NS_ASSERTION(0 == tag, \"found past max enum\");
   }
};
nsCalICalendarTestTagTable validateTagTable;
#endif

";

close(CPP_FILE);
