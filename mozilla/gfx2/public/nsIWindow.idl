/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 * 
 * The Original Code is mozilla.org code.
 * 
 * The Initial Developer of the Original Code is Netscape
 * Communications Corporation. Portions created by Netscape are
 * Copyright (C) 2000 Netscape Communications Corporation. All
 * Rights Reserved.
 * 
 * Contributor(s): 
 *   Stuart Parmenter <pavlov@netscape.com>
 */

#include "nsISupports.idl"
#include "gfxtypes.idl"

interface nsICursor;
interface nsIGUIEventListener;
interface nsIImage;
interface nsIRegion;

/**
 * nsIWindow interface
 *
 * @author Stuart Parmenter <pavlov@netscape.com>
 * @version 0.0
 * @see nsIChildWindow
 * @see nsIPopupWindow
 * @see nsITopLevelWindow
 * @see nsIDrawable
 * @see "gfx2"
 **/
[scriptable, uuid(dba78efe-1dd1-11b2-87c6-96864a58da7e)]
interface nsIWindow : nsISupports
{

  /**
   * The parent of this window
   */
  attribute nsIWindow parent;

  /**
   * Make this window visible on the screen.
   *
   * @note show() should not affect the z-order of the window.
   **/
  void show();

  /**
   * Make this window not visible on the screen.
   **/
  void hide();

  /**
   * Find out if the window is visible or not.
   *
   * @return TRUE if the window is visible or FALSE if it is not
   **/
  readonly attribute boolean isVisible;

  /**
   * Move this window.
   *
   * @param aX the new x position expressed in the parent's coordinate system
   * @param aY the new y position expressed in the parent's coordinate system
   **/
  void move(in gfx_coord aX, in gfx_coord aY);

  /**
   * Resize this window. 
   *
   * @param aWidth  the new width expressed in the parent's coordinate system
   * @param aHeight the new height expressed in the parent's coordinate system
   * @param aRepaint whether the window should be repainted
   */
  void resize(in gfx_width aWidth,
              in gfx_height aHeight,
              in boolean aRepaint);

  /**
   * Move and resize this window.
   *
   * @param aX       the new x position expressed in the parent's coordinate system
   * @param aY       the new y position expressed in the parent's coordinate system
   * @param aWidth   the new width expressed in the parent's coordinate system
   * @param aHeight  the new height expressed in the parent's coordinate system
   * @param aRepaint whether the window should be repainted if the size changes
   */
  void moveResize(in gfx_coord aX,
                  in gfx_coord aY,
                  in gfx_width aWidth,
                  in gfx_height aHeight,
                  in boolean aRepaint);

  /**
   * Get the geometry of this window.
   *
   * @param aX       the x position expressed in the parent's coordinate system
   * @param aY       the y position expressed in the parent's coordinate system
   * @param aWidth   the width expressed in the parent's coordinate system
   * @param aHeight  the height expressed in the parent's coordinate system
   */
  void getBounds(out gfx_coord aX,
                 out gfx_coord aY,
                 out gfx_width aWidth,
                 out gfx_height aHeight);


  /**
   * The event listener for this window
   * should you be able to have multiple event listeners?  ugh
   */
  attribute nsIGUIEventListener eventListener;

  /**
   * Set/Get the background color for this window.
   *
   * @param aColor the new background color
   */
  attribute gfx_color winBackgroundColor;

  /**
   * Set/Get the cursor for this window
   *
   * @param aCursor the new cursor for this window.
   */
  attribute nsICursor cursor;


  /**
   * Invalidate a the area \a aRect in 'this' window.
   *
   * @param aRect The rectangle to invalidate, or NULL if you wish to invalidate the entire window.
   * @param aIsSynchronouse If TRUE then repaint now else repaint later.
   * @see update()
   */
  [noscript] void invalidateRect([const] in nsRect aRect, in boolean aIsSynchronous);

  /**
   * Invalidate the area \a aRegion in 'this' window.
   *
   * @param aRegion The region to invalidate.
   * @param aIsSynchronouse If TRUE then repaint now else repaint later.
   * @see update()
   */
  void invalidateRegion(in nsIRegion aRegion, in boolean aIsSynchronous);

  /**
   * Force a synchronous repaint of the window if there are dirty rects.
   *
   * @see invalidate()
   */
  void update();

  /**
   * Scroll the window.
   * @attention NEED DOCS!
   *
   * @param aSrcX src x
   * @param aSrcY src y
   * @param aDestX dest x
   * @param aDestY dest y
   * @param aWidth width to scroll
   * @param aHeight height to scroll
   *
   * @note Implementations are required to generate expose events for any areas of the
   *       destination rectangle that could not be painted because the corresponding
   *       source area was obscured. (roc)
   */
  void scroll(in gfx_coord aSrcX,
              in gfx_coord aSrcY,
              in gfx_coord aDestX,
              in gfx_coord aDestY,
              in gfx_dimension aWidth,
              in gfx_dimension aHeight);

};
