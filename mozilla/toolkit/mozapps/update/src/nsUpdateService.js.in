/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is the Update Service.
 *
 * The Initial Developer of the Original Code is Ben Goodger.
 * Portions created by the Initial Developer are Copyright (C) 2004
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *  Ben Goodger <ben@bengoodger.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

const PREF_APP_UPDATE_ENABLED   = "app.update.enabled";
const PREF_APP_UPDATE_MODE      = "app.update.mode";
const PREF_APP_UPDATE_INTERVAL  = "app.update.interval";
const PREF_APP_UPDATE_TIMER     = "app.update.timer";
const PREF_APP_UPDATE_URL       = "app.update.url";
const PREF_APP_UPDATE_INPROGRESS      = "app.update.inProgress";
const PREF_APP_UPDATE_LASTUPDATEDATE  = "app.update.lastUpdateDate";

const nsIUpdateService    = Components.interfaces.nsIUpdateService;
const nsIUpdateItem       = Components.interfaces.nsIUpdateItem;

const UPDATED_EXTENSIONS  = 0x01;
const UPDATED_APP         = 0x02;

function APP_NS(aProperty)
{
  return "http://www.mozilla.org/2004/app-rdf#" + aProperty;
}

var gApp    = null;
var gPref   = null;
var gOS     = null;
var gRDF    = null;

function UpdateService() {
  gApp  = Components.classes["@mozilla.org/xre/app-info;1"]
                    .getService(Components.interfaces.nsIXULAppInfo);
  gPref = Components.classes["@mozilla.org/preferences-service;1"]
                    .getService(Components.interfaces.nsIPrefBranch);
  gOS   = Components.classes["@mozilla.org/observer-service;1"]
                    .getService(Components.interfaces.nsIObserverService);
  
  this.watchForUpdates();

  var pbi = gPref.QueryInterface(Components.interfaces.nsIPrefBranch2);
  pbi.addObserver(PREF_UPDATE_APP_AUTOUPDATEENABLED, this, false);

  // Observe xpcom-shutdown to unhook pref branch observers above to avoid 
  // shutdown leaks.
  gOS.addObserver(this, "xpcom-shutdown", false);
  
  // Reset update state from previous session if an app update was installed.
  if (gPref.prefHasUserValue(PREF_UPDATE_APP_PERFORMED)) 
    gPref.clearUserPref(PREF_UPDATE_APP_PERFORMED);
}

UpdateService.prototype = {
  /////////////////////////////////////////////////////////////////////////////
  // nsIUpdateService
  watchForUpdates: function nsUpdateService_watchForUpdates ()
  {
    // This is called when the app starts, so check to see if the time interval
    // expired between now and the last time an automated update was performed.
    // now is the same one that was started last time. 
    this._appAutoUpdateEnabled = gPref.getBoolPref(PREF_UPDATE_APP_AUTOUPDATEENABLED);
    this._extAutoUpdateEnabled = gPref.getBoolPref(PREF_UPDATE_EXTENSIONS_AUTOUPDATEENABLED);
    if (!this._appAutoUpdateEnabled && !this._extAutoUpdateEnabled)
      return;

    this._makeTimer(gPref.getIntPref(PREF_UPDATE_INTERVAL));
  },
  
  checkForUpdates: function(aSourceEvent, aParentWindow) {
    switch (aSourceEvent) {
    case nsIUpdateService.SOURCE_EVENT_USER:
      if (aSourceEvent == nsIUpdateService.SOURCE_EVENT_USER && 
          gPref.getBoolPref(PREF_UPDATE_APP_PERFORMED)) {
        var sbs = Components.classes["@mozilla.org/intl/stringbundle;1"]
                            .getService(Components.interfaces.nsIStringBundleService);
        var bundle = sbs.createBundle("chrome://mozapps/locale/update/update.properties");
        var brandBundle = sbs.createBundle("chrome://branding/locale/brand.properties");
        var brandShortName = brandBundle.GetStringFromName("brandShortName");        
        var message = bundle.formatStringFromName("appupdateperformedmessage",
                                                  [brandShortName, brandShortName], 2);
        var ps = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
                          .getService(Components.interfaces.nsIPromptService);
        ps.alert(aParentWindow, 
                 bundle.GetStringFromName("appupdateperformedtitle"), 
                 message);
        return;
      }
      
      var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
                         .getService(Components.interfaces.nsIWindowMediator);
      var wizard = wm.getMostRecentWindow("Update:Wizard");
      if (wizard)
        wizard.focus();
      else {
        var ww = Components.classes["@mozilla.org/embedcomp/window-watcher;1"]
                          .getService(Components.interfaces.nsIWindowWatcher);
        ww.openWindow(aParentWindow, "chrome://mozapps/content/update/update.xul", 
                      "", "chrome,centerscreen", null);
      }
      break;
    case nsIUpdateService.SOURCE_EVENT_BACKGROUND:
      // Rather than show a UI, call the checkForUpdates function directly here. 
      // The Browser's inline front end update notification system listens for the
      // updates that this function broadcasts.
      this.checkForUpdatesInternal([], 0, types, aSourceEvent);

      break;
    }  
  },
  
  _canUpdate: function(sourceEvent) {
    // Always can update if the autoupdate preference is set, otherwise, 
    // allow updates only when not in backround update mode, i.e. when the user
    // explicitly asked. 
    return aPreference ? true 
                       : sourceEvent != nsIUpdateService.SOURCE_EVENT_BACKGROUND;
  },
  
  checkForUpdatesInternal: function(aSourceEvent) {
    var types = this._getAllowedTypes(aUpdateTypes);

    // Listen for notifications sent out by the app updater (implemented here) and the
    // extension updater (implemented in nsExtensionItemUpdater)
    var canUpdate;
    this._updateObserver = new nsUpdateObserver(types, aSourceEvent, this);
    var os = Components.classes["@mozilla.org/observer-service;1"]
                       .getService(Components.interfaces.nsIObserverService);
    if (types & nsIUpdateItem.TYPE_APP) {
      if (this._canUpdate(this._appAutoUpdateEnabled, aSourceEvent, types)) {
        gOS.addObserver(this._updateObserver, "Update:App:Ended", false);
        
        this._currentVersion  = new nsAppUpdateInfo();
        this._newestVersion   = new nsAppUpdateInfo();

        if (!this._updateObserver.appUpdater) {
          this._updateObserver.appUpdater = new nsAppUpdater(this);
          this._updateObserver.appUpdater.checkForUpdates();
        }
      }
    }
    if (types & nsIUpdateItem.TYPE_ADDON) { // TYPE_EXTENSION, TYPE_ANY, etc.
      if (this._canUpdate(this._extAutoUpdateEnabled, aSourceEvent, types)) {
        gOS.addObserver(this._updateObserver, "Update:Extension:Started", false);
        gOS.addObserver(this._updateObserver, "Update:Extension:Item-Ended", false);
        gOS.addObserver(this._updateObserver, "Update:Extension:Ended", false);

        var em = Components.classes["@mozilla.org/extensions/manager;1"]
                           .getService(Components.interfaces.nsIExtensionManager);
        em.update(aItems, aItems.length, false);
      }
    }
    
    if (aSourceEvent == nsIUpdateService.SOURCE_EVENT_BACKGROUND && 
        (this._appAutoUpdateEnabled || this._extAutoUpdateEnabled)) {
      if (types & nsIUpdateItem.TYPE_ADDON)
        gPref.setIntPref(PREF_UPDATE_EXTENSIONS_LASTUPDATEDATE, Date.now() / 1000);
      if (types & nsIUpdateItem.TYPE_APP)
        gPref.setIntPref(PREF_UPDATE_APP_LASTUPDATEDATE, Date.now() / 1000);
    }
  },
  
  /////////////////////////////////////////////////////////////////////////////
  // nsITimerCallback
  _shouldUpdate: function nsUpdateService__shouldUpdate (aIntervalPref, aLastCheckPref)
  {
    var interval = gPref.getIntPref(aIntervalPref);
    var lastUpdateTime = gPref.getIntPref(aLastCheckPref);
    return ((Math.round(Date.now() / 1000) - lastUpdateTime) > Math.round(interval/1000));
  },
  
  notify: function nsUpdateService_notify (aTimer)
  {
    var types = 0;
    if (this._shouldUpdate(PREF_UPDATE_EXTENSIONS_INTERVAL, 
                           PREF_UPDATE_EXTENSIONS_LASTUPDATEDATE)) {
      types |= nsIUpdateItem.TYPE_ADDON;         
    }
    if (this._shouldUpdate(PREF_UPDATE_APP_INTERVAL,
                           PREF_UPDATE_APP_LASTUPDATEDATE)) {
      types |= nsIUpdateItem.TYPE_APP;         
    }
    if (types)
      this.checkForUpdatesInternal([], 0, types, 
                                   nsIUpdateService.SOURCE_EVENT_BACKGROUND);
  },

  /////////////////////////////////////////////////////////////////////////////
  // nsIObserver
  observe: function nsUpdateService_observe (aSubject, aTopic, aData)
  {
    switch (aTopic) {
    case "nsPref:changed":
      var needsNotification = false;
      switch (aData) {
      case PREF_UPDATE_APP_AUTOUPDATEENABLED:
      case PREF_UPDATE_APP_ENABLED:
        this._appAutoUpdateEnabled = gPref.getBoolPref(PREF_UPDATE_APP_AUTOUPDATEENABLED);
        if (!this._appAutoUpdateEnabled) {
          this._clearAppUpdatePrefs();
          needsNotification = true;
        }
        else {
          // Do an initial check NOW to update any FE components and kick off the
          // timer. 
          this.checkForUpdatesInternal([], 0, nsIUpdateItem.TYPE_APP, 
                                       nsIUpdateService.SOURCE_EVENT_BACKGROUND);
        }
        break;
      case PREF_UPDATE_EXTENSIONS_AUTOUPDATEENABLED:
      case PREF_UPDATE_EXTENSIONS_ENABLED:
        this._extAutoUpdateEnabled = gPref.getBoolPref(PREF_UPDATE_EXTENSIONS_AUTOUPDATEENABLED);
        if (!this._extAutoUpdateEnabled) {
          // Unset prefs used by the update service to signify extension updates
          if (gPref.prefHasUserValue(PREF_UPDATE_EXTENSIONS_COUNT))
            gPref.clearUserPref(PREF_UPDATE_EXTENSIONS_COUNT);
          needsNotification = true;
        }
        else {
          // Do an initial check NOW to update any FE components and kick off the
          // timer. 
          this.checkForUpdatesInternal([], 0, nsIUpdateItem.TYPE_ADDON, 
                                       nsIUpdateService.SOURCE_EVENT_BACKGROUND);
        }
        break;
      case PREF_UPDATE_INTERVAL:
      case PREF_UPDATE_APP_INTERVAL:
      case PREF_UPDATE_EXTENSIONS_INTERVAL:
        this._makeTimer(gPref.getIntPref(PREF_UPDATE_INTERVAL));
        break;
      }
    
      if (needsNotification) {
        var os = Components.classes["@mozilla.org/observer-service;1"]
                           .getService(Components.interfaces.nsIObserverService);
        var backgroundEvt = Components.interfaces.nsIUpdateService.SOURCE_EVENT_BACKGROUND;
        gOS.notifyObservers(null, "Update:Ended", backgroundEvt.toString());
      }
      break;
    case "xpcom-shutdown":
      gOS.removeObserver(this, "xpcom-shutdown");    
      
      // Clean up held observers etc to avoid leaks. 
      var pbi = gPref.QueryInterface(Components.interfaces.nsIPrefBranch2);
      pbi.removeObserver(PREF_UPDATE_APP_AUTOUPDATEENABLED, this);
      pbi.removeObserver(PREF_UPDATE_APP_ENABLED, this);
      pbi.removeObserver(PREF_UPDATE_EXTENSIONS_AUTOUPDATEENABLED, this);
      pbi.removeObserver(PREF_UPDATE_EXTENSIONS_ENABLED, this);
      pbi.removeObserver(PREF_UPDATE_INTERVAL, this);
      pbi.removeObserver(PREF_UPDATE_EXTENSIONS_INTERVAL, this);
    
      // Release strongly held services.
      gPref = null;
      gRDF  = null;
      gOS   = null;
      if (this._timer) {
        this._timer.cancel();
        this._timer = null;
      }
      break;
    }  
  },

  /////////////////////////////////////////////////////////////////////////////
  // nsUpdateService
  _timer: null,
  _makeTimer: function nsUpdateService__makeTimer (aDelay)
  {
    if (!this._timer) 
      this._timer = Components.classes["@mozilla.org/timer;1"]
                              .createInstance(Components.interfaces.nsITimer);
    this._timer.cancel();
    this._timer.initWithCallback(this, aDelay, 
                                 Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
  },
  
  _clearAppUpdatePrefs: function nsUpdateService__clearAppUpdatePrefs ()
  {
    // Unset prefs used by the update service to signify application updates
    if (gPref.prefHasUserValue(PREF_UPDATE_APP_UPDATESAVAILABLE))
      gPref.clearUserPref(PREF_UPDATE_APP_UPDATESAVAILABLE);
  },

  /**
   * See nsISupports.idl
   */
  QueryInterface: function(iid) {
    if (!iid.equals(Components.interfaces.nsIUpdateService) &&
        !iid.equals(Components.interfaces.nsIObserver) && 
        !iid.equals(Components.interfaces.nsISupports))
      throw Components.results.NS_ERROR_NO_INTERFACE;
    return this;
  }
};

///////////////////////////////////////////////////////////////////////////////
// App Updater
function AppUpdater() {

}
AppUpdater.prototype = {

};

function UpdateItem () {
}
UpdateItem.prototype = {
  /**
   * See nsIUpdateService.idl
   */
  init: function(id, version, installLocationKey, minAppVersion, maxAppVersion,
                 name, downloadURL, iconURL, updateURL, type) {
    this._id                  = id;
    this._version             = version;
    this._installLocationKey  = installLocationKey;
    this._minAppVersion       = minAppVersion;
    this._maxAppVersion       = maxAppVersion;
    this._name                = name;
    this._downloadURL         = downloadURL;
    this._iconURL             = iconURL;
    this._updateURL           = updateURL;
    this._type                = type;
  },
  
  /**
   * See nsIUpdateService.idl
   */
  get id()                { return this._id;                },
  get version()           { return this._version;           },
  get installLocationKey(){ return this._installLocationKey;},
  get minAppVersion()     { return this._minAppVersion;     },
  get maxAppVersion()     { return this._maxAppVersion;     },
  get name()              { return this._name;              },
  get xpiURL()            { return this._downloadURL;       },
  get iconURL()           { return this._iconURL            },
  get updateRDF()         { return this._updateURL;         },
  get type()              { return this._type;              },

  /**
   * See nsIUpdateService.idl
   */
  get objectSource() {
    return { id                 : this._id, 
             version            : this._version, 
             installLocationKey : this._installLocationKey,
             minAppVersion      : this._minAppVersion,
             maxAppVersion      : this._maxAppVersion,
             name               : this._name, 
             xpiURL             : this._downloadURL, 
             iconURL            : this._iconURL, 
             updateRDF          : this._updateURL,
             type               : this._type 
           }.toSource();
  },
  
  /**
   * See nsISupports.idl
   */
  QueryInterface: function(iid) {
    if (!iid.equals(Components.interfaces.nsIUpdateItem) &&
        !iid.equals(Components.interfaces.nsISupports))
      throw Components.results.NS_ERROR_NO_INTERFACE;
    return this;
  }
};

function Version(aMajor, aMinor, aRelease, aBuild, aPlus) 
{ 
  this.major    = aMajor    || 0;
  this.minor    = aMinor    || 0;
  this.release  = aRelease  || 0;
  this.build    = aBuild    || 0;
  this.plus     = aPlus     || 0;
}

Version.prototype = {
  toString: function Version_toString() 
  {
    return this.major + "." + this.minor + "." + this.subminor + "." + this.release + (this.plus ? "+" : "");
  },
  
  compare: function (aVersion)
  {
    var fields = ["major", "minor", "release", "build", "plus"];
    
    for (var i = 0; i < fields.length; ++i) {
      var field = fields[i];
      if (aVersion[field] > this[field])
        return -1;
      else if (aVersion[field] < this[field])
        return 1;
    }
    return 0;
  }
}

function nsVersionChecker()
{
}

nsVersionChecker.prototype = {
  /////////////////////////////////////////////////////////////////////////////
  // nsIVersionChecker
  
  // -ve      if B is newer
  // equal    if A == B
  // +ve      if A is newer
  compare: function nsVersionChecker_compare (aVersionA, aVersionB)
  {
    var a = this._decomposeVersion(aVersionA);
    var b = this._decomposeVersion(aVersionB);
    
    return a.compare(b);
  },
  
  _decomposeVersion: function nsVersionChecker__decomposeVersion (aVersion)
  {
    var plus = 0;
    if (aVersion.charAt(aVersion.length-1) == "+") {
      aVersion = aVersion.substr(0, aVersion.length-1);
      plus = 1;
    }

    var parts = aVersion.split(".");
    
    return new Version(this._getValidInt(parts[0]),
                       this._getValidInt(parts[1]),
                       this._getValidInt(parts[2]),
                       this._getValidInt(parts[3]),
                       plus);
  },
  
  _getValidInt: function nsVersionChecker__getValidInt (aPartString)
  {
    var integer = parseInt(aPartString);
    if (isNaN(integer))
      return 0;
    return integer;
  },
  
  isValidVersion: function nsVersionChecker_isValidVersion (aVersion)
  {
    return /^([0-9]+\.){0,3}[0-9]+\+?$/.test(aVersion);
  },

  /////////////////////////////////////////////////////////////////////////////
  // nsISupports
  QueryInterface: function nsVersionChecker_QueryInterface (aIID) 
  {
    if (!aIID.equals(Components.interfaces.nsIVersionChecker) &&
        !aIID.equals(Components.interfaces.nsISupports))
      throw Components.results.NS_ERROR_NO_INTERFACE;
    return this;
  }
};

var gModule = {
  _firstTime: true,
  
  registerSelf: function (aComponentManager, aFileSpec, aLocation, aType) 
  {
    if (this._firstTime) {
      this._firstTime = false;
      throw Components.results.NS_ERROR_FACTORY_REGISTER_AGAIN;
    }
    aComponentManager = aComponentManager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
    
    for (var key in this._objects) {
      var obj = this._objects[key];
      aComponentManager.registerFactoryLocation(obj.CID, obj.className, obj.contractID,
                                                aFileSpec, aLocation, aType);
    }
  },
  
  getClassObject: function (aComponentManager, aCID, aIID) 
  {
    if (!aIID.equals(Components.interfaces.nsIFactory))
      throw Components.results.NS_ERROR_NOT_IMPLEMENTED;

    for (var key in this._objects) {
      if (aCID.equals(this._objects[key].CID))
        return this._objects[key].factory;
    }
    
    throw Components.results.NS_ERROR_NO_INTERFACE;
  },
  
  _objects: {
    manager: { CID: Components.ID("{B3C290A6-3943-4B89-8BBE-C01EB7B3B311}"),
               contractID: "@mozilla.org/updates/update-service;1",
               className: "Update Service",
               factory: {
                          createInstance: function (aOuter, aIID) 
                          {
                            if (aOuter != null)
                              throw Components.results.NS_ERROR_NO_AGGREGATION;
                            
                            return (new nsUpdateService()).QueryInterface(aIID);
                          }
                        }
             },
    version: { CID: Components.ID("{9408E0A5-509E-45E7-80C1-0F35B99FF7A9}"),
               contractID: "@mozilla.org/updates/version-checker;1",
               className: "Version Checker",
               factory: {
                          createInstance: function (aOuter, aIID) 
                          {
                            if (aOuter != null)
                              throw Components.results.NS_ERROR_NO_AGGREGATION;
                            
                            return (new nsVersionChecker()).QueryInterface(aIID);
                          }
                        }
             },
    item:    { CID: Components.ID("{F3294B1C-89F4-46F8-98A0-44E1EAE92518}"),
               contractID: "@mozilla.org/updates/item;1",
               className: "Extension Item",
               factory: {
                          createInstance: function (aOuter, aIID) 
                          {
                            if (aOuter != null)
                              throw Components.results.NS_ERROR_NO_AGGREGATION;
                            
                            return new UpdateItem().QueryInterface(aIID);
                          }
                        } 
             }  
   },
  
  canUnload: function (aComponentManager) 
  {
    return true;
  }
};

function NSGetModule(compMgr, fileSpec) 
{
  return gModule;
}

