<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is mozilla.org code.
   -
   - The Initial Developer of the Original Code is
   - Netscape Communications Corporation.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -  Brian Ryner <bryner@netscape.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<bindings id="selectBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="select-base" extends="chrome://global/content/bindings/outliner.xml#outliner-base">
    <resources>
      <stylesheet src="chrome://forms/content/select.css"/>
    </resources>
  </binding>

  <binding id="select-outlinerbody" extends="chrome://forms/content/select.xml#select-base">
    <implementation>
      <field name="_lastSelectedRow">
        -1
      </field>
    </implementation>
    <handlers>
      <!-- If there is no modifier key, we select on mousedown, not
           click, so that drags work correctly. -->
      <handler event="mousedown">
      <![CDATA[
         if (!event.ctrlKey && !event.shiftKey && !event.metaKey) {
           var row = {};
           var col = {};
           var obj = {};
           var b = this.parentNode.parentNode.parentNode.outlinerBoxObject;
           b.getCellAt(event.clientX, event.clientY, row, col, obj);

           // save off the last selected row
           this._lastSelectedRow = row.value;

           try {
             if (row.value >= b.view.rowCount) return;
           } catch (e) { return; }
           if (!b.selection.isSelected(row.value)) {
             b.selection.select(row.value);
           }
         }
      ]]>
      </handler>

      <!-- On a click (up+down on the same item), deselect everything
           except this item. -->
      <handler event="click">
      <![CDATA[
         if (event.button != 0) return;
         var row = {};
         var col = {};
         var obj = {};
         var b = this.parentNode.parentNode.parentNode.outlinerBoxObject;
         b.getCellAt(event.clientX, event.clientY, row, col, obj);

         try {
           if (row.value >= b.view.rowCount) return;
         } catch (e) { return; }

         var augment = event.ctrlKey || event.metaKey;
         if (event.shiftKey)
           b.selection.rangedSelect(-1, row.value, augment);
         else if (augment) {
           b.selection.toggleSelect(row.value);
           b.selection.currentIndex = row.value;
         }
         else {
          /* We want to deselect all the selected items except what was
            clicked, UNLESS it was a right-click.  We have to do this
            in click rather than mousedown so that you can drag a
            selected group of items */

           // if the last row has changed in between the time we 
           // mousedown and the time we click, don't fire the select handler.
           // see bug #92366
           if (this._lastSelectedRow == row.value)
             b.selection.select(row.value);  
         }
      ]]>
      </handler>

    </handlers>
  </binding>

  <binding id="select-size" extends="chrome://forms/content/select.xml#select-base"
           display="xul:outliner">
    <content orient="vertical">
      <xul:outlinercols>
        <xul:outlinercol flex="1"/>
      </xul:outlinercols>
      <xul:outlinerrows class="outliner-rows" flex="1">
        <xul:hbox flex="1" class="outliner-bodybox">
          <xul:outlinerbody flex="1">
            <xul:outlinerchildren>
              <children/>
            </xul:outlinerchildren>
          </xul:outlinerbody>
        </xul:hbox>
        <xul:scrollbar orient="vertical" class="outliner-scrollbar"/>
      </xul:outlinerrows>
    </content>

    <implementation>
      <property name="outlinerBoxObject"
               onget="return this.boxObject.QueryInterface(Components.interfaces.nsIOutlinerBoxObject);"
               readonly="true"/>
      <property name="currentIndex"
                onget="return this.outlinerBoxObject.selection.currentIndex;"
                onset="return this.outlinerBoxObject.selection.currentIndex=val;"/>
      <property name="singleSelection"
                onget="return this.getAttribute('seltype') == 'single'"
                readonly="true"/>
      <field name="selectionHead">
        -1
      </field>
      <field name="selectionTail">
        -1
      </field>
    </implementation>

    <handlers>
      <handler event="focus" action="this.outlinerBoxObject.focused = true;"/>
      <handler event="blur" action="this.outlinerBoxObject.focused = false;"/>

      <handler event="keypress" keycode="vk_up">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          if (c == -1 || c == 0)
            return;
          this.selectionHead = -1;
          this.selectionTail = -1;
          this.outlinerBoxObject.selection.timedSelect(c-1, 500);
          this.outlinerBoxObject.ensureRowIsVisible(c-1);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_down">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          try { if (c+1 == this.outlinerBoxObject.view.rowCount)
            return;
          } catch (e) {}
          this.selectionHead = -1;
          this.selectionTail = -1;
          this.outlinerBoxObject.selection.timedSelect(c+1, 500);
          this.outlinerBoxObject.ensureRowIsVisible(c+1);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_up" modifiers="shift">
        <![CDATA[
          event.preventDefault();
          if (this.singleSelection)
            return;
          var c = this.currentIndex;
          if (c == -1 || c == 0)
            return;
          if (c == this.selectionTail) {
            if (this.selectionHead < this.selectionTail) {
              this.outlinerBoxObject.selection.toggleSelect(c);
              this.currentIndex = c - 1;
            }
            else {
              this.outlinerBoxObject.selection.toggleSelect(c - 1);
            }
          }
          else {
            this.outlinerBoxObject.selection.clearSelection();
            this.selectionHead = c;
            this.outlinerBoxObject.selection.rangedSelect(c, c - 1, true);
          }
          this.selectionTail = c - 1;
          this.outlinerBoxObject.ensureRowIsVisible(c - 1);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_down" modifiers="shift">
        <![CDATA[
          event.preventDefault();
          if (this.singleSelection)
            return;
          var c = this.currentIndex;
          try { if (c+1 == this.outlinerBoxObject.view.rowCount)
            return;
          } catch (e) {}
          if (c == this.selectionTail) {
            if (this.selectionHead > this.selectionTail) {
              this.outlinerBoxObject.selection.toggleSelect(c);
              this.currentIndex = c + 1;
            }
            else
              this.outlinerBoxObject.selection.toggleSelect(c + 1);
          }
          else {
            this.outlinerBoxObject.selection.clearSelection();
            this.selectionHead = c;
            this.outlinerBoxObject.selection.rangedSelect(c, c + 1, true);
          }
          this.selectionTail = c + 1;
          this.outlinerBoxObject.ensureRowIsVisible(c + 1);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_up" modifiers="control">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          if (c == -1 || c == 0)
            return;
          this.currentIndex = c-1;
          this.outlinerBoxObject.ensureRowIsVisible(c-1);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_down" modifiers="control">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          try { if (c+1 == this.outlinerBoxObject.view.rowCount)
            return;
          } catch (e) {}
          this.currentIndex = c+1;
          this.outlinerBoxObject.ensureRowIsVisible(c+1);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_up">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          if (c == 0)
            return;
          this.selectionHead = -1;
          this.selectionTail = -1;
          var f = this.outlinerBoxObject.getFirstVisibleRow();
          var i = 0;
          if (f > 0) {
            var p = this.outlinerBoxObject.getPageCount();
            if (f - p >= 0)
              i = c - p;
            else
              i = c - f;
            this.outlinerBoxObject.scrollByPages(-1);
          }
          this.outlinerBoxObject.selection.timedSelect(i, 500);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_down">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          var l = this.outlinerBoxObject.view.rowCount - 1;
          if (c == l)
            return;
          this.selectionHead = -1;
          this.selectionTail = -1;
          var f = this.outlinerBoxObject.getFirstVisibleRow();
          var p = this.outlinerBoxObject.getPageCount();
          var i = l;
          var lastTopRowIndex = l - p;
          if (f <= lastTopRowIndex) {
            if (f + p <= lastTopRowIndex)
              i = c + p;
            else
              i = lastTopRowIndex + c - f + 1;
            this.outlinerBoxObject.scrollByPages(1);
          }
          this.outlinerBoxObject.selection.timedSelect(i, 500);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_up" modifiers="shift">
        <![CDATA[
          event.preventDefault();
          if (this.singleSelection)
            return;
          var c = this.currentIndex;
          if (c == 0)
            return;
          var f = this.outlinerBoxObject.getFirstVisibleRow();
          var i = 0;
          if (f > 0) {
            var p = this.outlinerBoxObject.getPageCount();
            if (f - p >= 0)
              i = c - p;
            else
              i = c - f;
            this.outlinerBoxObject.scrollByPages(-1);
          }
          if (c == this.selectionTail) {
            if (this.selectionHead < this.selectionTail) {
              if (i < this.selectionHead) {
                this.outlinerBoxObject.selection.clearRange(c, this.selectionHead + 1);
                this.outlinerBoxObject.selection.rangedSelect(this.selectionHead - 1, i, true);
              }
              else {
                this.outlinerBoxObject.selection.clearRange(c, i + 1);
                this.currentIndex = i;
              }
            }
            else
              this.outlinerBoxObject.selection.rangedSelect(c - 1, i, true);
          }
          else {
            this.outlinerBoxObject.selection.clearSelection();
            this.selectionHead = c;
            this.outlinerBoxObject.selection.rangedSelect(c, i, true);
          }
          this.selectionTail = i;
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_down" modifiers="shift">
        <![CDATA[
          event.preventDefault();
          if (this.singleSelection)
            return;
          var c = this.currentIndex;
          var l = this.outlinerBoxObject.view.rowCount - 1;
          if (c == l)
            return;
          var f = this.outlinerBoxObject.getFirstVisibleRow();
          var p = this.outlinerBoxObject.getPageCount();
          var i = l;
          var lastTopRowIndex = l - p;
          if (f <= lastTopRowIndex) {
            if (f + p <= lastTopRowIndex)
              i = c + p;
            else
              i = lastTopRowIndex + c - f + 1;
            this.outlinerBoxObject.scrollByPages(1);
          }
          if (c == this.selectionTail) {
            if (this.selectionHead > this.selectionTail) {
              if (i > this.selectionHead) {
                this.outlinerBoxObject.selection.clearRange(c, this.selectionHead - 1);
                this.outlinerBoxObject.selection.rangedSelect(this.selectionHead + 1, i, true);
              }
              else {
                this.outlinerBoxObject.selection.clearRange(c, i - 1);
                this.currentIndex = i;
              }
            }
            else
              this.outlinerBoxObject.selection.rangedSelect(c + 1, i, true);
          }
          else {
            this.outlinerBoxObject.selection.clearSelection();
            this.selectionHead = c;
            this.outlinerBoxObject.selection.rangedSelect(c, i, true);
          }
          this.selectionTail = i;
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_up" modifiers="control">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          if (c == 0)
            return;
          var f = this.outlinerBoxObject.getFirstVisibleRow();
          var i = 0;
          if (f > 0) {
            var p = this.outlinerBoxObject.getPageCount();
            if (f - p >= 0)
              i = c - p;
            else
              i = c - f;
            this.outlinerBoxObject.scrollByPages(-1);
          }
          this.currentIndex = i;
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_down" modifiers="control">
        <![CDATA[
          event.preventDefault();
          var c = this.currentIndex;
          var l = this.outlinerBoxObject.view.rowCount - 1;
          if (c == l)
            return;
          var f = this.outlinerBoxObject.getFirstVisibleRow();
          var p = this.outlinerBoxObject.getPageCount();
          var i = l;
          var lastTopRowIndex = l - p;
          if (f <= lastTopRowIndex) {
            if (f + p <= lastTopRowIndex)
              i = c + p;
            else
              i = lastTopRowIndex + c - f + 1;
            this.outlinerBoxObject.scrollByPages(1);
          }
          this.currentIndex = i;
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_home">
        <![CDATA[
          event.preventDefault();
          if (this.currentIndex == 0)
            return;
          this.selectionHead = -1;
          this.selectionTail = -1;
          this.outlinerBoxObject.selection.timedSelect(0, 500);
          this.outlinerBoxObject.ensureRowIsVisible(0);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_end">
        <![CDATA[
          event.preventDefault();
          var l = this.outlinerBoxObject.view.rowCount - 1;
          if (this.currentIndex == l)
            return;
          this.selectionHead = -1;
          this.selectionTail = -1;
          this.outlinerBoxObject.selection.timedSelect(l, 500);
          this.outlinerBoxObject.ensureRowIsVisible(l);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_home" modifiers="shift">
        <![CDATA[
          event.preventDefault();
          if (this.singleSelection)
            return;
          var c = this.currentIndex;
          if (c == 0)
            return;
          if (c != this.selectionTail) {
            this.outlinerBoxObject.selection.clearSelection();
            this.selectionHead = c;
          }
          this.outlinerBoxObject.selection.rangedSelect(c, 0, true);
          this.selectionTail = 0;
          this.outlinerBoxObject.ensureRowIsVisible(0);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_end" modifiers="shift">
        <![CDATA[
          event.preventDefault();
          if (this.singleSelection)
            return;
          var c = this.currentIndex;
          var l = this.outlinerBoxObject.view.rowCount - 1;
          if (c == l)
            return;
          if (c != this.selectionTail) {
            this.outlinerBoxObject.selection.clearSelection();
            this.selectionHead = c;
          }
          this.outlinerBoxObject.selection.rangedSelect(c, l, true);
          this.selectionTail = l;
          this.outlinerBoxObject.ensureRowIsVisible(l);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_home" modifiers="control">
        <![CDATA[
          event.preventDefault();
          if (this.currentIndex == 0)
            return;
          this.currentIndex = 0;
          this.outlinerBoxObject.ensureRowIsVisible(0);
         ]]>
      </handler>
      <handler event="keypress" keycode="vk_end" modifiers="control">
        <![CDATA[
          event.preventDefault();
          var l = this.outlinerBoxObject.view.rowCount - 1;
          if (this.currentIndex == l)
            return;
          this.currentIndex = l;
          this.outlinerBoxObject.ensureRowIsVisible(l);
         ]]>
      </handler>
      <handler event="keypress">
        <![CDATA[
          event.preventDefault();
          if (event.keyCode == ' ') {
            var c = this.currentIndex;
            if (!this.outlinerBoxObject.selection.isSelected(c))
              this.outlinerBoxObject.selection.toggleSelect(c);
          }
          ]]>
      </handler>

     </handlers>

   </binding>
 
  <binding id="select" extends="xul:menu">
    <implementation>
      <property name="selectElement" readonly="true"
                onget="return this.QueryInterface(Components.interfaces.nsISelectElement);"/>
      <method name="updateLabel">
        <body>
        <![CDATA[
          var selectedIndex = this.selectedIndex;
          var item = this.childNodes[selectedIndex];
          var newLabel = item.label;
          if (!newLabel)
            newLabel = item.text;
          this.setAttribute('label', newLabel);
        ]]>
        </body>
      </method>

      <constructor>
        <![CDATA[
          this.updateLabel();
        ]]>
      </constructor>
    </implementation>
    <content sizetopopup="true">
        <xul:label flex="1" value="   " inherits="value=label" style="border: 1px solid red"/>
        <xul:dropmarker/>
        <xul:menupopup style="display:-moz-popup!important">
          <children/>
        </xul:menupopup>
    </content>
    <handlers>
      <handler event="command" phase="capturing">
      <![CDATA[
        if (event.originalTarget.localName != 'OPTION')
          return;

        // Notify the select element that the selected item has changed.
        // It will then give us a selectedItemChanged event.
        var itemIndex = 0;
        for (itemIndex = 0; itemIndex < this.childNodes.length; ++itemIndex) {
          if (this.childNodes[itemIndex] == event.originalTarget)
            break;
        }

        if (itemIndex == this.childNodes.length) // not found
          return;

        this.selectElement.setOptionsSelectedByIndex(itemIndex, itemIndex, true,
                                                     true, false);
        ]]>
      </handler>

      <handler event="selectedItemChanged" action="this.updateLabel();"/>
    </handlers>
  </binding>

  <binding id="select-option" extends="xul:menuitem">
    <content>
       <xul:label inherits="value=label">
         <children/>
      </xul:label>
    </content>
  </binding>

</bindings>          
