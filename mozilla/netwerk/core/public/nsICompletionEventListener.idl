/**
 * Goals:
 *
 *  (1) Model streams after NSPR I/O, thus making implementation easy and transparent
 *  (2) Allow both - blocking and non-blocking operations within the same API framework
 *      and in doing so streamlining the way application is developed
 *  (3) All stream implenetations become uniformed in both - blocking and non0blocking
 *      modes, thus taking partially the functionality of nsIOChannel's and allow simple
 *      transparent chaining of streams without encouraging excessive buffering
 *
 *  This model will not support NT-style overlapped I/O; there's no good expression for it
 *  within NSPR either - do we need it?
 *
 *  Changes:
 *      gagan:  streams will not inherit from nsI*Stream to not confuse them with existing
 *              streams as behavior is a bit different
 *      ruslan: streams will not have a common base class and Close () operation - this will
 *              have to be done in the destructor
 *      ruslan: output stream will not have Flush () operation - this will need to  be moved
 *              into some new BufferedWriter interface
 */

/**
 * this event object is always assumed to be called via proxy on the originating thread's
 * event queue
 */

#include "nsISupports.idl"

[scriptable, uuid(717fa26d-8ce4-40a9-9e7c-71958bf86ddd)]
interface nsICompletionEventListener : nsISupports
{
    /**
     * we don't want any parameters in this method on purpose to avoid dealing with
     * their lifecycles; it is listener's responisbility to maintain a reference to
     * a stream and then check for errors if needed
     */
    void OnComplete ();
};

