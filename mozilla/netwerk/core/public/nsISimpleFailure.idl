/**
 * Goals:
 *
 *  (1) Model streams after NSPR I/O, thus making implementation easy and transparent
 *  (2) Allow both - blocking and non-blocking operations within the same API framework
 *      and in doing so streamlining the way application is developed
 *  (3) All stream implenetations become uniformed in both - blocking and non0blocking
 *      modes, thus taking partially the functionality of nsIOChannel's and allow simple
 *      transparent chaining of streams without encouraging excessive buffering
 *
 *  This model will not support NT-style overlapped I/O; there's no good expression for it
 *  within NSPR either - do we need it?
 *
 *  Changes:
 *      gagan:  streams will not inherit from nsI*Stream to not confuse them with existing
 *              streams as behavior is a bit different
 *      ruslan: streams will not have a common base class and Close () operation - this will
 *              have to be done in the destructor
 *      ruslan: output stream will not have Flush () operation - this will need to  be moved
 *              into some new BufferedWriter interface
 */

#include "nsISupports.idl"

/**
 * Since we don't support exceptions - this is essentially an exception object to report
 * extended I/O errors up stream; it can have furher dependency on a common error-reporting
 * structure, such as GenericFailure for example
 */
[scriptable, uuid(2a5dd631-494f-4693-a2e1-15bbcc80846e)]
interface nsISimpleFailure	: nsISupports
{
    readonly attribute unsigned long osErrorCode;
    readonly attribute unsigned long	 errorCode;
    readonly attribute string  message;
};
