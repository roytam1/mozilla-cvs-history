<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <title>Soap Scripts in Mozilla</title>
</head>
<body>
<div align="Center">
<h1>SOAP Scripts in Mozilla</h1>
<font color="#999999">February 16, 2002</font><br>
<h3><font color="#999999">Ray Whitmer</font></h3>
<h2><font color="#666666">Abstract</font></h2>
<div align="Left"><font color="#000000">Microsoft and others have advocated
SOAP as a way to encode and exchange public data structures between agents
on the web.&nbsp; The browser client is the most universal web agent in existence,
and Javascript is the standard, interoperable way of scripting browsers.&nbsp;
Scriptable SOAP in browsers gives clients and servers more to say to each
other through existing http-xml services, providing scripts with persistence,
database, and access to other web services not tied to the request and response
cycles of the HTML-based user interface.&nbsp; Web data structures, exchanged
in a platform-neutral way, should become as fundamental to web agents as
web content is today.&nbsp; The key to this is a tight binding to the natural
data of Javascript so that the script can simply use the data instead of
tediously encoding and extracting the data from the XML.</font><br>
<h2>SOAP Services</h2>
 There are a number of sources for services available on the web being set 
up, such as XMethods. Apache supports modules for SOAP that this author has 
used to author services for purposes of testing and entertainment.&nbsp;
Once it is set up, it is as simple as writing a function in Javascript, Java, 
or any other of a number of supported languages and then writing a simple 
service description in XML or submitting a form to deploy the service.&nbsp;
There are toolkits available from Microsoft and other webserver providers
for authoring such services as well.<br>
<h2>SOAP Blocks</h2>
<h3>Parameters<br>
</h3>
SOAP-based services exchange message envelopes which contain blocks of XML
data roughly corresponding to the parameters of a service call.&nbsp; When
an rpc-style message is exchanged, blocks representing the regular parameter
blocks are placed inside an element which identifies the object and method
being invoked, which is placed inside the body. &nbsp;In a non-RPC message,
the blocks are placed directly inside the body instead of under the method
element.&nbsp; <br>
<h3>Header Blocks<br>
</h3>
Blocks which are optional or are independently added or processed are placed
inside the header with an assigned role and specially marked if the recipient
is required to understand them.<br>
<h3>Encodings<br>
</h3>
Interpretation of each block depends upon the encoding that was used, which
is clearly specified in the message.&nbsp; If the standard SOAP encoding
is used, then XML Schema types used to interpret the data within each block.<br>
<h2>Using the Low-Level SOAP API</h2>
To use the low-level API, the user creates a SOAPCall object, encodes the 
function call with a list of headers and regular parameters, and invokes the
call, which returns a response which contains the results of the service call
including a fault generated by the service which processed the message, output
parameters, and/or header blocks.&nbsp; If the call is invoked asynchronously, 
then a function is given which receives the response when it arrives from 
the remote service.<br>
<br>
Besides Javascript, the below-described operations should also generally
work for other xpconnect-supported languages in Mozilla such as C++/XPCOM
and Python, because language-independent cross-platform interfaces were used.<br>
<br>
Object names or descriptions contained in angle brackets represent any object
of the named or described type. &nbsp;Quoted angle brackets indicate a suitable
string of the named or described value type.<br>
<h3>Basic Operations<br>
</h3>
For most simple use cases, basic operations is all the user needs to do.<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">Basic Operation<br>
      </td>
      <td valign="Top">Ways to Access<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Set a Javascript value or object as the value of a
message block<br>
      </td>
      <td valign="Top">&lt;variable&gt; = new SOAPParameter(&lt;value&gt;)<br>
&nbsp;// or<br>
 &lt;variable&gt; =   new SOAPHeader(&lt;value&gt;)<br>
&nbsp;// or<br>
&lt;SOAPParameter&gt;.value = &lt;value&gt;<br>
&nbsp;or<br>
 &lt;SOAPHeaderBlock&gt;.value = &lt;value&gt;<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Get or set header blocks or parameters in a Javascript
array<br>
      </td>
      <td valign="Top">&lt;Array&gt;[]<br>
// or<br>
new Array(&lt;block&gt;[,...]);<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Associate the arrays of header blocks and parameters
with a message<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.encode(&lt;0 or 1 for 1.1 or 1.2&gt;,
"&lt;method&gt;", "&lt;object namespace&gt;", &lt;header count&gt;, &lt;headers&gt;,
&lt;parameter count&gt;, &lt;parameters&gt;)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Invoke &nbsp;call (send call message and receive response
message)<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.invoke()<br>
// or<br>
&lt;SOAPCall&gt;.asyncInvoke(&lt;SOAPResponseListener&gt;)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Get the response's fault, if any<br>
      </td>
      <td valign="Top">&lt;SOAPResponse&gt;.fault<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Get the arrays of blocks from the response<br>
      </td>
      <td valign="Top">&lt;variable&gt; = &lt;SOAPResponse&gt;.getParameters(&lt;true
if not rpc-style&gt;, {})<br>
// or<br>
&lt;variable&gt; = &lt;SOAPResponse&gt;.getHeaderBlocks({})<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Get a Javascript value or object from a response message
block<br>
      </td>
      <td valign="Top">&lt;variable&gt; = &lt;SOAPParameter&gt;.value<br>
// or<br>
&lt;variable&gt; = &lt;SOAPHeaderBlock&gt;.value<br>
      </td>
    </tr>
  </tbody>
</table>
<h3>Sources of Objects for Basic Operations</h3>
Source expressions can generally be placed on the right-side of an assignment
(equals) operator to get an object of the listed type.<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">Basic Object Types<br>
      </td>
      <td valign="Top">Objects of Type Found Here<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPParameter<br>
      </td>
      <td valign="Top">new SOAPParameter()<br>
// or<br>
&lt;SOAPResponse&gt;.getParameters(&lt;true if not rpc-style&gt;, {})<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPHeaderBlock<br>
      </td>
      <td valign="Top">new SOAPHeaderBlock()<br>
// or<br>
SOAPResponse.getHeaderBlocks({})<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPCall<br>
      </td>
      <td valign="Top">new SOAPCall()<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPResponse<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.invoke()<br>
// or<br>
&lt;SOAPCall&gt;.asyncInvoke(&lt;SOAPResponseListener&gt;) // SOAPResponse
delivered to listener<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPResponseListener<br>
      </td>
      <td valign="Top">&lt;Function accepting (&lt;SOAPResponse&gt;, &lt;SOAPCall&gt;,
&lt;status&gt;)&gt;<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPFault<br>
      </td>
      <td valign="Top">&lt;SOAPResponse&gt;.fault<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h3>Expert Operations -- To be Skipped by the Bleary-Eyed<br>
</h3>
When the default encoding, decoding, and handling is not adequate, the user
has access to a variety of additional JS-accessible mechanisms to control
the encoding and decoding of messages.<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">Operation<br>
      </td>
      <td valign="Top">Ways to Access<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Set or get the name and namespaceURI of a message
block<br>
      </td>
      <td valign="Top">&lt;variable&gt; = new SOAPParameter(&lt;value&gt;,
"&lt;name&gt;", "&lt;namespaceURI&gt;")<br>
// or<br>
&lt;SOAPParameter&gt;.name<br>
// or<br>
&lt;SOAPParameter&gt;.namespaceURI<br>
// or<br>
&lt;variable&gt; = new SOAPHeaderBlock(&lt;value&gt;, "&lt;name&gt;", "&lt;namespaceURI&gt;")<br>
// or<br>
&lt;SOAPHeaderBlock&gt;.name<br>
// or<br>
&lt;SOAPHeaderBlock&gt;.namespaceURI<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Mark / check role URI of header block<br>
      </td>
      <td valign="Top">&lt;SOAPHeaderBlock&gt;.actorURI<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Mark / check boolean value whether header must be
understood by recipient or the message should be rejected<br>
      </td>
      <td valign="Top">&lt;SOAPHeaderBlock&gt;.mustUnderstand<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Check the actual SOAP version of an encoded message.<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.version<br>
// or<br>
&lt;SOAPResponse&gt;.version<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Abort an in-progress asynchronous call<br>
      </td>
      <td valign="Top">&lt;SOAPCallCompletion&gt;.abort()<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Map or unmap alias schema target URIs to be used --
as SOAP 1.1 types are aliased 1.2 types<br>
      </td>
      <td valign="Top">&lt;SOAPEncoding&gt;.mapSchemaURI("&lt;external URI&gt;",
"&lt;internal URI&gt;", &lt;true to alias output&gt;)<br>
// or<br>
&lt;SOAPEncoding&gt;.unmapSchemaURI("&lt;external URI&gt;")<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Associate a specific XML schema type (SchemaType)
with the block to govern encoding or decoding<br>
      </td>
      <td valign="Top">&lt;variable&gt; = &lt;SchemaCollection&gt;.getType("&lt;name&gt;",
"&lt;namespaceURI&gt;")<br>
// and then<br>
&lt;variable2&gt; = new SOAPParameter(&lt;value&gt;, "&lt;name&gt;", "&lt;namespaceURI&gt;",
&lt;SchemaType&gt;)<br>
// or<br>
&lt;SOAPParameter&gt;.schemaType = &lt;variable&gt;<br>
// or<br>
&lt;variable2&gt; = new SOAPHeaderBlock(&lt;value&gt;, "&lt;name&gt;", "&lt;namespaceURI&gt;",
&lt;SchemaType&gt;)<br>
// or<br>
&lt;SOAPHeaderBlock&gt;.schemaType = &lt;variable&gt;<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Associate a specific encoding with the call to govern
encoding or decoding<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.encoding = &lt;SOAPEncoding&gt;<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Associate a specific schema collection with all associated
encodings<br>
      </td>
      <td valign="Top">&lt;SOAPEncoding&gt;.schemaCollection = &lt;SchemaCollection&gt;<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Load Schema files containing additional schema types
to be used for encoding or decoding<br>
      </td>
      <td valign="Top">&lt;SchemaLoader&gt;.load("&lt;schema URI&gt;")<br>
      <br>
&lt;SchemaLoader&gt;.loadAsync("&lt;schemaURI&gt;", &lt;completion function&gt;)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Directly get or set the XML content associated with
a message block as a DOM Element<br>
      </td>
      <td valign="Top">&lt;SOAPParameter&gt;.element<br>
// or<br>
  &lt;SOAPHeaderBlock&gt;.element<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Add or replace the encoders or decoders within the
particular encoding<br>
      </td>
      <td valign="Top">&lt;SOAPEncoding&gt;.defaultEncoder = &lt;SOAPEncoder&gt;<br>
// or<br>
&lt;SOAPEncoding&gt;.defaultDecoder = &lt;SOAPDecoder&gt;<br>
// or<br>
&lt;SOAPEncoding&gt;.setEncoder("&lt;namespaceURI&gt;#&lt;name&gt;",&lt;SOAPEncoder&gt;)<br>
// or<br>
&lt;SOAPEncoding&gt;.setDecoder("&lt;namespaceURI&gt;#&lt;name&gt;",&lt;SOAPDecoder&gt;)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Create an alternative encoding for use on specific
messages<br>
      </td>
      <td valign="Top">&lt;variable&gt; = &lt;SOAPEncoding&gt;.getAssociatedEncoding("&lt;namespaceURI&gt;")<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Register modified or alternative encodings, making
them automatically available to all SOAP scripts in the system<br>
      </td>
      <td valign="Top">&lt;new encoding&gt;.js<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Mark the call with a verifySourceHeader, if the server
permits it, so the browser needs less risky privilege and trust for the script<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.verifySourceHeader = true<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Request risky privileges within a local or signed
script to make an unverified SOAP calls to other domains<br>
      </td>
      <td valign="Top">netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead")<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Modify the security settings in the preferences file,
allowing some domains to make risky SOAP calls without restriction</td>
      <td valign="Top">all.js: pref("&lt;some domain&gt;.SOAPCall.invoke","allAccess");<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">Register alternative transport mechanisms, providing
alternative transports  to all SOAP scripts in the system<br>
      </td>
      <td valign="Top">&lt;new transport&gt;.js<br>
      </td>
    </tr>
  </tbody>
</table>
<h3>Additional Sources for Expert Operations</h3>
For JS objects, source expressions can generally be placed on the right-side 
of an assignment (equals) operator to get an object of the listed type.<br>
<br>
<table cellpadding="2" cellspacing="2" border="1" width="100%">
  <tbody>
    <tr>
      <td valign="Top">Object or File<br>
      </td>
      <td valign="Top">Additional Objects of Type Found Here<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAParameter<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.getParameters(&lt;true if not rpc-style&gt;,
{}) &nbsp;// (if encoded)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPHeaderBlock<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.getHeaderBlocks({}) // (if encoded)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPEncoding<br>
      </td>
      <td valign="Top">new SOAPEncoding()<br>
// or<br>
&lt;SOAPCall&gt;.encoding // (if encoded)<br>
// or<br>
&lt;SOAPResponse&gt;.encoding<br>
// or<br>
&lt;SOAPEncoding&gt;.getAssociatedEncoding("&lt;namespaceURI&gt;",&lt;true
to create&gt;)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPEncoder<br>
      </td>
      <td valign="Top">&lt;Suitable Javascript function &lt;New DOM Element&gt;
= &lt;function name&gt;(&lt;SOAPEncoding&gt;, &lt;value&gt;, &lt;namespaceURI&gt;,
&lt;name&gt;, &lt;SchemaType&gt;, &lt;SOAPAttachments&gt;, &lt;Parent DOM 
Element&gt; )&gt;<br>
// or<br>
&lt;SOAPEncoding&gt;.defaultEncoder<br>
// or<br>
&lt;SOAPEncoding&gt;.getEncoder("&lt;namespaceURI&gt;#&lt;name&gt;")<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPDecoder<br>
      </td>
      <td valign="Top">&lt;Suitable Javascript function &lt;value&gt; = &lt;function
name&gt;(&lt;SOAPEncoding&gt;, &lt;DOM Element&gt;, &lt;SchemaType&gt;, &lt;SOAPAttachments&gt;)&gt;<br>
// or<br>
&lt;SOAPEncoding&gt;.defaultDecoder<br>
// or<br>
&lt;SOAPEncoding&gt;.getDecoder("&lt;namespaceURI&gt;#&lt;name&gt;")<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SchemaLoader<br>
      </td>
      <td valign="Top">&lt;SchemaCollection&gt;<br>
// or<br>
new SchemaLoader()<br>
// or<br>
&lt;SOAPEncoding&gt;.schemaCollection<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SchemaCollection<br>
      </td>
      <td valign="Top">&lt;SchemaLoader&gt;<br>
// or<br>
new SchemaLoader()<br>
// or<br>
&lt;SOAPEncoding&gt;.schemaCollection<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SchemaType<br>
      </td>
      <td valign="Top">&lt;SchemaCollection&gt;.getType("&lt;name&gt;", "&lt;namespaceURI&gt;")<br>
// or<br>
&lt;SOAPParameter&gt;.schemaType<br>
// or<br>
 &lt;SOAPHeaderBlock&gt;.schemaType<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">SOAPCallCompletion<br>
      </td>
      <td valign="Top">&lt;SOAPCall&gt;.asyncInvoke(&lt;SOAPResponseListener&gt;)<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">all.js<br>
      </td>
      <td valign="Top">In default/pref directory<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">&lt;new encoding&gt;.js<br>
      </td>
      <td valign="Top">In components directory<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">&lt;new transport&gt;.js<br>
      </td>
      <td valign="Top">In components directory<br>
      </td>
    </tr>
    <tr>
      <td valign="Top">netscape.security.PrivilegeManager<br>
      </td>
      <td valign="Top">Globally-available object in Javascript</td>
    </tr>
  </tbody>
</table>
<h2>Future Features</h2>
<h3>High-Level Access to SOAP</h3>
Although a SOAP call can generally be accomplished using this API in a few
dozen lines, rather than having to manually attach all the type information
to the call and set and retrieve the parameters from arrays of blocks, WSDL
is a standard that describes how all of this should occur with no manual
type and argument setup required. &nbsp;An implementation is underway that
instantiates web service proxies complete with appropriate xpconnect interfaces
by simply loading and using information out of a WSDL file. &nbsp;The proxy's
interface has dynamically-generated methods named appropriately to match
the services described in the WSDL file which accept arguments of the appropriate
data types and call the appropriate low-level SOAP functions with the appropriate
type information, making it even simpler not only to invoke services from
Javascript code, but to associate appropriate schema types loaded from the
WSDL file with the arguments. &nbsp;This is not available in the first release.<br>
<h3> </h3>
<h3>Arbitrary Graphs of Data</h3>
The SOAP specification allows objects to be passed as arguments which may
have originally referenced other objects that are not owned in a pure hierarchy.
&nbsp;This is represented by using an href attribute. &nbsp;Due to the problems
with leaking reference counts in COM objects with cyclic references, this
has not been implemented yet. &nbsp;Also, the output of a cyclicly-referencing
set of objects has not been implemented. &nbsp;Incoming objects that do not
reference cyclicly currently create separate copies for each reference to
an object, and with cycles will probably never complete. &nbsp;On input,
hrefs are currently ignored. &nbsp;In the future it may be possible to solve
this and transmit and receive arbitrarily-referencing objects, but the solution
is more complex than just using weak references.<br>
<h3>SOAP With Attachments</h3>
Many clients and servers now support automatically transmitting large Mime
with a SOAP message by encapsulating it in MIME, DIME, or other enveloping
formats. &nbsp;This has been anticipated in the APIs, but the SOAPAttachments
API is currently a placeholder for this future feature which is not yet implemented.<br>
<h2>Samples and Tests</h2>
Tests are available which can be used as samples...<br>
<br>
If the samples are inadequate, look at the IDL files at...<br>
<br>
A test server exists at .... where I will put up relevant tests anyone submits...<br>
<br>
Bugs can be reported at...<br>
<br>
</div>
</div>
</body>
</html>
