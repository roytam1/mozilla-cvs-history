<?xml version="1.0"?>
<xalantests>
  <test file="attribset/attribset01">
    <purpose>Set attribute of a LRE from single attribute set.</purpose>
  </test>
  <test file="attribset/attribset02">
    <purpose>Set attributes of a LRE from multiple attribute sets.</purpose>
  </test>
  <test file="attribset/attribset03">
    <purpose>Use xsl:element with multiple attribute sets.</purpose>
  </test>
  <test file="attribset/attribset04">
    <purpose>Use xsl:copy with multiple attribute sets, no conflicts.</purpose>
  </test>
  <test file="attribset/attribset05">
    <purpose>Set attributes of a LRE using attribute sets that inherit.</purpose>
  </test>
  <test file="attribset/attribset06">
    <purpose>Set attributes of a LRE using attribute sets that inherit, plus add overlapping attribute with xsl:attribute.</purpose>
  </test>
  <test file="attribset/attribset07">
    <purpose>Set attributes of a LRE using attribute sets that inherit, but have overlapping attributes.</purpose>
  </test>
  <test file="attribset/attribset08">
    <purpose>Use xsl:element with attribute sets that inherit, plus add overlapping attribute with xsl:attribute.</purpose>
  </test>
  <test file="attribset/attribset09">
    <purpose>Use xsl:copy with attribute sets that inherit, plus add overlapping attribute with xsl:attribute.</purpose>
  </test>
  <test file="attribset/attribset10">
    <purpose>Set attributes of an LRE, using attribute sets whose names overlap, plus add overlapping attribute with xsl:attribute.</purpose>
  </test>
  <test file="attribset/attribset11">
    <purpose>Set attributes of an LRE, using one attribute set with multiple attributes, and one overriding LRE attribute.</purpose>
  </test>
  <test file="attribset/attribset12">
    <purpose>Set attributes of an LRE, using one attribute set with multiple attributes, and one overriding LRE attribute, and one overriding xsl:attribute attribute.</purpose>
  </test>
  <test file="attribset/attribset13">
    <purpose>Creating attribute for Literal Result Element. The expanded-name of the attribute to be created is specified by a required name attribute and an optional namespace attribute</purpose>
  </test>
  <test file="attribset/attribset14">
    <purpose>Use xsl:element with attribute having a namespace. The expanded-name of the attribute to be created is specified by a required name attribute and an optional namespace attribute</purpose>
  </test>
  <test file="attribset/attribset15">
    <purpose>The name attribute is interpreted as an attribute value template. It is an error if the value of the AVT is not a QNAME or the string "xmlns". (Last two xsl:attributes test this)</purpose>
  </test>
  <test file="attribset/attribset16">
    <purpose>The namespace attribute is interpreted as an attribute value template.</purpose>
  </test>
  <test file="attribset/attribset17">
    <purpose>Verify that 'checked' attribute of HTML element input is correctly set.</purpose>
  </test>
  <test file="attribset/attribset18">
    <purpose>Verify adding an attribute to an element replaces any existing attribute of that element with the same expanded name.</purpose>
  </test>
  <test file="attribset/attribset19">
    <purpose>Verify adding an attribute to an element after children have been added to it is an error. The attributes can be ignored.</purpose>
  </test>
  <test file="attribset/attribset20">
    <purpose>Test for selecting attributes with xml namespace prefix.</purpose>
  </test>
  <test file="attribset/attribset22">
    <purpose>Verify that attributes that contain text nodes with a newline, the output must contain a character reference.</purpose>
  </test>
  <test file="attribset/attribset23">
    <purpose>XSLT processors may make use of the prefix of the QNAME specified in the name attribute ... however they are not required to do so and, if the prefix is xmlns, they must not do so ... this will not result in a namespace declaration being output.</purpose>
  </test>
  <test file="attribset/attribset24">
    <purpose>The namespace attribute is interpreted as an attribute value template.</purpose>
  </test>
  <test file="attribset/attribset25">
    <purpose>Use xsl:element with for-each inside xsl:attribute</purpose>
  </test>
  <test file="attribset/attribset28">
    <purpose>Use xsl:copy with multiple attribute sets in a list that have conflicts.</purpose>
  </test>
  <test file="attribset/attribset32">
    <purpose>Use xsl:element with multiple attribute sets with conflicting set names.</purpose>
  </test>
  <test file="attribset/attribset35">
    <purpose>Verify adding an attribute to an element after a PI has been added to it is an error. The attributes can be ignored. The spec doesn't explicitly say this is disallowed, as it does for child elements, but it makes sense to have the same treatment.</purpose>
  </test>
  <test file="attribset/attribset36">
    <purpose>Verify adding an attribute to an element after a comment has been added to it is an error. The attributes can be ignored. The spec doesn't explicitly say this is disallowed, as it does for child elements, but it makes sense to have the same treatment.</purpose>
  </test>
  <test file="attribset/attribset37">
    <purpose>Set some attributes from an imported definition.</purpose>
  </test>
  <test file="attribset/attribset38">
    <purpose>Set some attributes from an imported definition.</purpose>
  </test>
  <test file="attribset/err/attribseterr01">
    <purpose>Verify creating nodes other than text nodes during instantiation of the content of the xsl:attribute element is an error. Offending nodes can be ignored.</purpose>
  </test>
  <test file="attribset/err/attribseterr02">
    <purpose>Set up circular references of attribute-sets using each other</purpose>
  </test>
  <test file="attribset/err/attribseterr03">
    <purpose>Verify adding an attribute to node that is not an element is an error. The attributes can be ignored.</purpose>
  </test>
  <test file="attribset/err/attribseterr04">
    <purpose>Omit name attribute in xsl:attribute-set.</purpose>
  </test>
  <test file="attribset/err/attribseterr05">
    <purpose>Put illegal instructions in xsl:attribute-set.</purpose>
  </test>
  <test file="attribset/err/attribseterr06">
    <purpose>Test placement of attribute-set inside a template, which is illegal.</purpose>
  </test>
  <test file="attribset/err/attribseterr07">
    <purpose>Set attributes of element, using an attribute set that doesn't exist.</purpose>
    <comment>NOTE that the spec is unclear about what behavior is required! In a private email, James Clark said that it should be an error. Erratum to come?</comment>
  </test>
  <test file="attribvaltemplate/attribvaltemplate01">
    <purpose>Test of single attribute value template (AVT).</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate02">
    <purpose>Test two AVTs with literal element between them (based on example in the spec).</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate03">
    <purpose>Test of left curly brace escape.</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate04">
    <purpose>Test of right curly brace escape.</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate05">
    <purpose>Use of Curly brace to set value of HTML attribute.</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate07">
    <purpose>Use of Curly brace to set value of HTML attributes. Predicate and quotes inside.</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate08">
    <purpose>Compare the results of attribute value generated by AVT vs. xsl:value-of, with the output specified to be HTML.</purpose>
  </test>
  <test file="attribvaltemplate/attribvaltemplate09">
    <purpose>Testing generation of null attribute. Bug: if $From was null, it was not outputting the attribute.</purpose>
  </test>
  <test file="attribvaltemplate/err/attribvaltemplateerr01">
    <purpose>Test of nested curly braces. Not allowed.</purpose>
  </test>
  <test file="axes/axes01">
    <purpose>Test for 'ancestor::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes02">
    <purpose>Test for 'ancestor-or-self::*' Axis Identifier</purpose>
  </test>
  <test file="axes/axes03">
    <purpose>Test for 'attribute::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes04">
    <purpose>Test for 'child::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes05">
    <purpose>Test for 'descendant::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes06">
    <purpose>Test for 'descendant-or-self::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes07">
    <purpose>Test for 'following::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes08">
    <purpose>Test for 'preceding::*' Axis Identifier with wildcard.</purpose>
  </test>
  <test file="axes/axes09">
    <purpose>Test for 'following-sibling::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes10">
    <purpose>Test for 'preceding-sibling::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes11">
    <purpose>Test for 'parent::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes12">
    <purpose>Test for 'self::*' Axis Identifier.</purpose>
  </test>
  <test file="axes/axes13">
    <purpose>Test for ancestor::*[...][...] and index of ancestors.</purpose>
  </test>
  <test file="axes/axes14">
    <purpose>Test for ancestor-or-self::*[@att1][1]/@att1 vs. (ancestor-or-self::*)[@att1][1]/@att1.</purpose>
  </test>
  <test file="axes/axes15">
    <purpose>Test for completion of tree using all axes.</purpose>
  </test>
  <test file="axes/axes16">
    <purpose>Test for 'ancestor::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes17">
    <purpose>Test for 'ancestor-or-self::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes18">
    <purpose>Test for 'attribute::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes19">
    <purpose>Test for '@*' abbreviated syntax.</purpose>
  </test>
  <test file="axes/axes20">
    <purpose>Test for '@*' abbreviated syntax with index.</purpose>
  </test>
  <test file="axes/axes21">
    <purpose>Test for 'child::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes22">
    <purpose>Test for 'child::' Axis Identifier with element name.</purpose>
  </test>
  <test file="axes/axes23">
    <purpose>Test for 'descendant::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes24">
    <purpose>Test for 'descendant::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes25">
    <purpose>Test for 'descendant-or-self::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes26">
    <purpose>Test for 'descendant-or-self::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes27">
    <purpose>Test for 'descendant-or-self::' Axis Identifier with self specified.</purpose>
  </test>
  <test file="axes/axes28">
    <purpose>Test for 'following::' Axis Identifier with wildcard and index.</purpose>
  </test>
  <test file="axes/axes29">
    <purpose>Test for 'following::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes30">
    <purpose>Test for 'preceding::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes31">
    <purpose>Test for 'preceding::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes32">
    <purpose>Test for 'following-sibling::' Axis Identifier with index.</purpose>
  </test>
  <test file="axes/axes33">
    <purpose>Test for 'following-sibling::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes34">
    <purpose>Test for 'preceding-sibling::' Axis Identifier with wildcard and index.</purpose>
  </test>
  <test file="axes/axes35">
    <purpose>Test for 'preceding-sibling::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes36">
    <purpose>Test for 'parent::' Axis Identifier using specified element name.</purpose>
  </test>
  <test file="axes/axes37">
    <purpose>Test for 'parent::' Axis Identifier using index (not that it's practical).</purpose>
  </test>
  <test file="axes/axes38">
    <purpose>Test for 'parent::' Axis Identifier using specified element name that is not found.</purpose>
  </test>
  <test file="axes/axes39">
    <purpose>Test for abbreviated '..' syntax.</purpose>
  </test>
  <test file="axes/axes40">
    <purpose>Test for 'self::' Axis Identifier with specified element name.</purpose>
  </test>
  <test file="axes/axes41">
    <purpose>Test for 'self::' Axis Identifier with index (not that it's practical).</purpose>
  </test>
  <test file="axes/axes42">
    <purpose>Test for 'self::' Axis Identifier with specified element name that is not found.</purpose>
  </test>
  <test file="axes/axes43">
    <purpose>Test for abbreviated '.' syntax.</purpose>
  </test>
  <test file="axes/axes44">
    <purpose>Test for 'attribute::' Axis Identifier with name of attribute.</purpose>
  </test>
  <test file="axes/axes45">
    <purpose>Test for '@' to select an attribute, with name of attribute.</purpose>
  </test>
  <test file="axes/axes46">
    <purpose>Test for '..' and an attribute of parent node.</purpose>
  </test>
  <test file="axes/axes47">
    <purpose>Test for '..//name' and an attribute.</purpose>
  </test>
  <test file="axes/axes48">
    <purpose>Test for two 'child::' Axis Identifiers in succession.</purpose>
  </test>
  <test file="axes/axes49">
    <purpose>Test for 'child::*' followed by 'descendant::*' (i.e., all grandchildren and below).</purpose>
  </test>
  <test file="axes/axes50">
    <purpose>Test for 'descendant::*' followed by 'child::*' (i.e., all grandchildren and below).</purpose>
  </test>
  <test file="axes/axes51">
    <purpose>Test for '//' followed by 'child::*' (i.e., all grandchildren).</purpose>
  </test>
  <test file="axes/axes52">
    <purpose>Test for '//' followed by 'descendant::*' (i.e., all children and below).</purpose>
  </test>
  <test file="axes/axes53">
    <purpose>Test for named node followed by 'descendant::*' (i.e., all children and below).</purpose>
  </test>
  <test file="axes/axes54">
    <purpose>Test for named node followed by 'child::*' (i.e., all children).</purpose>
  </test>
  <test file="axes/axes55">
    <purpose>Test for '//*' (i.e., all descendants, but elements only).</purpose>
  </test>
  <test file="axes/axes56">
    <purpose>Test that combination of // and descendant specifies node can be anywhere in ancestry.</purpose>
  </test>
  <test file="axes/axes57">
    <purpose>Test that // goes down at least 15 levels.</purpose>
  </test>
  <test file="axes/axes58">
    <purpose>Check the attribute:: axis. The foo:doc selection is necessary to pick up the last doc, cuz, I change the default namespace.</purpose>
  </test>
  <test file="axes/axes59">
    <purpose>Check the namespace axis.</purpose>
    <comment>To suppress empty lines</comment>
  </test>
  <test file="axes/axes60">
    <purpose>Test for 'attribute::*' in match pattern.</purpose>
  </test>
  <test file="axes/axes61">
    <purpose>Test for 'child::*' in match pattern.</purpose>
  </test>
  <test file="axes/axes62">
    <purpose>Check the namespace axes with a specified name.</purpose>
  </test>
  <test file="axes/axes63">
    <purpose>Test for 'self::' Axis Identifier with child predicate</purpose>
  </test>
  <test file="axes/axes64">
    <purpose>Test for 'self::' Axis Identifier with attribute predicate</purpose>
  </test>
  <test file="axes/axes65">
    <purpose>Test for 'self::text()' being empty when it should be</purpose>
  </test>
  <test file="axes/axes66">
    <purpose>Test for 'self::comment()' being empty when it should be</purpose>
  </test>
  <test file="axes/axes67">
    <purpose>Test for 'self::processing-instruction()' being empty when it should be</purpose>
  </test>
  <test file="axes/axes68">
    <purpose>Check that namespace axis includes all namespaces in scope.</purpose>
  </test>
  <test file="axes/axes69">
    <purpose>Compound test for preceding-sibling:: and following-sibling:: with explicit iteration.</purpose>
  </test>
  <test file="axes/axes70">
    <purpose>Compound test for preceding-sibling:: and following-sibling:: conjoined.</purpose>
  </test>
  <test file="axes/axes71">
    <purpose>Compound test for preceding-sibling:: and following-sibling:: conjoined, with positional predicate on the first axis.</purpose>
  </test>
  <test file="axes/axes72">
    <purpose>Compound test for preceding-sibling:: and following-sibling:: conjoined, with positional predicates on both axes.</purpose>
  </test>
  <test file="axes/axes73">
    <purpose>Compound test where we bounce "horizontally" across the tree, using positions.</purpose>
  </test>
  <test file="axes/axes74">
    <purpose>Compound test for following-sibling:: and preceding-sibling:: with explicit iteration.</purpose>
  </test>
  <test file="axes/axes75">
    <purpose>Compound test for following-sibling:: and preceding-sibling:: conjoined.</purpose>
  </test>
  <test file="axes/axes76">
    <purpose>Compound test for following-sibling:: and preceding-sibling:: conjoined, with positional predicate on the first axis.</purpose>
  </test>
  <test file="axes/axes77">
    <purpose>Compound test for following-sibling:: and preceding-sibling:: conjoined, with positional predicates on both axes. Reverse document order applies.</purpose>
  </test>
  <test file="axes/axes78">
    <purpose>Compound test where we bounce "horizontally" across the tree, using positions.</purpose>
  </test>
  <test file="axes/axes79">
    <purpose>Compound test for following::, parent, and child conjoined, with positional predicates.</purpose>
  </test>
  <test file="axes/axes80">
    <purpose>Compound test for preceding::, parent, and following:: conjoined, with positional predicates.</purpose>
  </test>
  <test file="axes/axes81">
    <purpose>Compound test for preceding::, parent, descendant::, and following-sibling:: conjoined, with positional predicates and a node test.</purpose>
  </test>
  <test file="axes/axes82">
    <purpose>Test simple notation to select entire tree.</purpose>
  </test>
  <test file="axes/axes83">
    <purpose>Compound test selecting everything that has children.</purpose>
  </test>
  <test file="axes/axes84">
    <purpose>Compound test going "vertically" in the tree.</purpose>
  </test>
  <test file="axes/axes85">
    <purpose>Alternate test to select the set of all grandparents.</purpose>
  </test>
  <test file="axes/axes86">
    <purpose>Test to select the set of all aunts, great-aunts, etc. but exclude ancestors.</purpose>
    <comment>"ancestor::*[count(child::*) &amp;gt; 1]" is the set of all ancestors with other children.</comment>
  </test>
  <test file="axes/axes87">
    <purpose>Traverse ancestor:: starting from attributes.</purpose>
  </test>
  <test file="axes/axes88">
    <purpose>Traverse following:: starting from attributes.</purpose>
  </test>
  <test file="axes/axes89">
    <purpose>Traverse preceding:: starting from attributes.</purpose>
  </test>
  <test file="axes/axes90">
    <purpose>Test for union of preceding-sibling:: and following-sibling::</purpose>
  </test>
  <test file="axes/axes91">
    <purpose>Test for steps beyond union of two axes.</purpose>
  </test>
  <test file="axes/axes92">
    <purpose>Test for union of two relative-location-paths</purpose>
  </test>
  <test file="axes/axes93">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes94">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes95">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes96">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes97">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes98">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes99">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes100">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes101">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes102">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes103">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes104">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes105">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes106">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes107">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes108">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes109">
    <purpose>Tests following axes starting with a attribute axes.</purpose>
  </test>
  <test file="axes/axes110">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes111">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="axes/axes112">
    <purpose>Tests apply-templates starting with a attribute axes followed by additional relative-location-path steps.</purpose>
  </test>
  <test file="boolean/boolean01">
    <purpose>Test of true()</purpose>
  </test>
  <test file="boolean/boolean02">
    <purpose>Test of boolean "and" operator with both values true</purpose>
  </test>
  <test file="boolean/boolean03">
    <purpose>Test of boolean "or" operator with two true values</purpose>
  </test>
  <test file="boolean/boolean04">
    <purpose>Test of boolean "not" operator with true value.</purpose>
  </test>
  <test file="boolean/boolean05">
    <purpose>Test of boolean() function - conversion of empty string.</purpose>
  </test>
  <test file="boolean/boolean06">
    <purpose>Test of "&gt;" operator with false expected value.</purpose>
  </test>
  <test file="boolean/boolean07">
    <purpose>Test of "&gt;=" operators with expected false result.</purpose>
  </test>
  <test file="boolean/boolean08">
    <purpose>Test of lang() function</purpose>
  </test>
  <test file="boolean/boolean09">
    <purpose>Test of false() function</purpose>
  </test>
  <test file="boolean/boolean10">
    <purpose>Test of the '=' operator for true.</purpose>
  </test>
  <test file="boolean/boolean11">
    <purpose>Test of '=' operator for false.</purpose>
  </test>
  <test file="boolean/boolean12">
    <purpose>Test of '=' operator on two numbers, one having decimal point and zeroes after</purpose>
  </test>
  <test file="boolean/boolean13">
    <purpose>Test of '=' operator with positive and negative zero.</purpose>
  </test>
  <test file="boolean/boolean14">
    <purpose>Test of '=' operator with one number with leading zero, one not.</purpose>
  </test>
  <test file="boolean/boolean15">
    <purpose>Test of '=' operator, true value compared against a non-empty string.</purpose>
  </test>
  <test file="boolean/boolean16">
    <purpose>Test of '=' operator, false value compared against an empty string.</purpose>
  </test>
  <test file="boolean/boolean17">
    <purpose>Test of '=' operator, true value compared against a non-zero number.</purpose>
  </test>
  <test file="boolean/boolean18">
    <purpose>Test of '=' operator, false value compared against zero.</purpose>
  </test>
  <test file="boolean/boolean19">
    <purpose>Test of boolean "and" operator with both values false</purpose>
  </test>
  <test file="boolean/boolean20">
    <purpose>Test of boolean "and" operator with two strings; strings are evaluated to True if there length &gt; 1.</purpose>
  </test>
  <test file="boolean/boolean21">
    <purpose>Test of boolean "and" operator with one value true and one value false</purpose>
  </test>
  <test file="boolean/boolean22">
    <purpose>Test of boolean "and" operator with one value false and one value true</purpose>
  </test>
  <test file="boolean/boolean23">
    <purpose>Test of boolean "and" operator with two strings that look like numbers</purpose>
  </test>
  <test file="boolean/boolean24">
    <purpose>Test of boolean "or" operator with true first, then false</purpose>
  </test>
  <test file="boolean/boolean25">
    <purpose>Test of boolean "or" operator, false first, then true</purpose>
  </test>
  <test file="boolean/boolean26">
    <purpose>Test of boolean "or" operator with two false values</purpose>
  </test>
  <test file="boolean/boolean27">
    <purpose>Test of boolean "or" operator, numeric vs. empty string</purpose>
  </test>
  <test file="boolean/boolean28">
    <purpose>Test of boolean "not" operator on a false</purpose>
  </test>
  <test file="boolean/boolean29">
    <purpose>Test of boolean "not" operator on a true expression</purpose>
  </test>
  <test file="boolean/boolean30">
    <purpose>Test of boolean "not" operator on a false expression</purpose>
  </test>
  <test file="boolean/boolean31">
    <purpose>Test of boolean "not" operator on an empty string</purpose>
  </test>
  <test file="boolean/boolean32">
    <purpose>Test of boolean "not" operator on a string</purpose>
  </test>
  <test file="boolean/boolean33">
    <purpose>Test of boolean() function, converting a non-empty string to true</purpose>
  </test>
  <test file="boolean/boolean34">
    <purpose>Test of boolean() function, converting a zero to false</purpose>
  </test>
  <test file="boolean/boolean35">
    <purpose>Test of boolean() function, converting a -0 to false</purpose>
  </test>
  <test file="boolean/boolean36">
    <purpose>Test of boolean() function, converting a non-zero number to true</purpose>
  </test>
  <test file="boolean/boolean37">
    <purpose>Test of boolean() function, converting a problem expression to true</purpose>
  </test>
  <test file="boolean/boolean38">
    <purpose>Display a problem expression</purpose>
  </test>
  <test file="boolean/boolean39">
    <purpose>Test of boolean() function, converting a problem expression</purpose>
  </test>
  <test file="boolean/boolean40">
    <purpose>Test of boolean() function, converting a node-set to true</purpose>
  </test>
  <test file="boolean/boolean41">
    <purpose>Test of boolean() function, converting an empty node-set to false</purpose>
  </test>
  <test file="boolean/boolean42">
    <purpose>Test of boolean() function, converting a result tree fragment</purpose>
  </test>
  <test file="boolean/boolean43">
    <purpose>Test of boolean() function, converting an empty result tree fragment</purpose>
  </test>
  <test file="boolean/boolean44">
    <purpose>Test of "&gt;" operator</purpose>
  </test>
  <test file="boolean/boolean45">
    <purpose>Test of "&gt;" operator</purpose>
  </test>
  <test file="boolean/boolean46">
    <purpose>Test of "&lt;" operator</purpose>
  </test>
  <test file="boolean/boolean47">
    <purpose>Test of "&lt;" operator</purpose>
  </test>
  <test file="boolean/boolean48">
    <purpose>Test of "&lt;" operator</purpose>
  </test>
  <test file="boolean/boolean49">
    <purpose>Test of "&gt;" operator</purpose>
  </test>
  <test file="boolean/boolean50">
    <purpose>Test of "&gt;" operator</purpose>
  </test>
  <test file="boolean/boolean51">
    <purpose>Test of "&lt;=" operator</purpose>
  </test>
  <test file="boolean/boolean52">
    <purpose>Test of "&gt;=" operator</purpose>
  </test>
  <test file="boolean/boolean53">
    <purpose>Test of "&lt;=" operator</purpose>
  </test>
  <test file="boolean/boolean54">
    <purpose>Test of "&lt;=" operator</purpose>
  </test>
  <test file="boolean/boolean55">
    <purpose>Test of "&lt;=" operator</purpose>
  </test>
  <test file="boolean/boolean56">
    <purpose>Test that "and" doesn't bother with right operand if left is false</purpose>
  </test>
  <test file="boolean/boolean57">
    <purpose>Test that "or" doesn't evaluate right operand if left is true</purpose>
  </test>
  <test file="boolean/boolean58">
    <purpose>If $x is bound to a node-set, then $x="foo" does not mean the same as not($x!="foo"): the former is true if and only if some node in $x has the string-value foo; the latter is true if and only if all nodes in $x have the string-value foo.</purpose>
  </test>
  <test file="boolean/boolean59">
    <purpose>Test =, !=, and not, comparing node-set to string, where node-set is empty.</purpose>
  </test>
  <test file="boolean/err/booleanerr01">
    <purpose>Test of invalid function that resembles "not".</purpose>
  </test>
  <test file="boolean/err/booleanerr02">
    <purpose>Test of invalid function that resembles "true" in not.</purpose>
  </test>
  <test file="boolean/err/booleanerr03">
    <purpose>Test of invalid function that resembles "true" in and.</purpose>
  </test>
  <test file="boolean/err/booleanerr04">
    <purpose>Test of invalid function that resembles "true" in or.</purpose>
  </test>
  <test file="boolean/err/booleanerr05">
    <purpose>Test of invalid function that resembles "true" in = relation.</purpose>
  </test>
  <test file="boolean/err/booleanerr06">
    <purpose>Test of invalid function that resembles "true" in boolean().</purpose>
  </test>
  <test file="boolean/err/booleanerr07">
    <purpose>Test of true() with an argument.</purpose>
  </test>
  <test file="boolean/err/booleanerr08">
    <purpose>Test of false() with an argument.</purpose>
  </test>
  <test file="boolean/err/booleanerr09">
    <purpose>Test of not() with no argument.</purpose>
  </test>
  <test file="boolean/err/booleanerr10">
    <purpose>Test of not() with too many arguments.</purpose>
  </test>
  <test file="boolean/err/booleanerr11">
    <purpose>Test of boolean() with no argument.</purpose>
  </test>
  <test file="boolean/err/booleanerr12">
    <purpose>Test of boolean() with too many arguments.</purpose>
  </test>
  <test file="boolean/err/booleanerr13">
    <purpose>Give lang() function too few arguments</purpose>
  </test>
  <test file="boolean/err/booleanerr14">
    <purpose>Give lang() function too many arguments</purpose>
  </test>
  <test file="conditional/conditional01">
    <purpose>General test of choose, with otherwise</purpose>
  </test>
  <test file="conditional/conditional02">
    <purpose>Test choose with no matches and missing otherwise clause.</purpose>
    <comment>No expected output.</comment>
  </test>
  <test file="conditional/conditional03">
    <purpose>Test for "when" testing on nonexsisent attribute node.</purpose>
    <comment>No errors or output expected.</comment>
  </test>
  <test file="conditional/conditional04">
    <purpose>Test xsl:when by itself, success.</purpose>
  </test>
  <test file="conditional/conditional05">
    <purpose>Test two xsl:when elements without xsl:otherwise, one succeeding.</purpose>
  </test>
  <test file="conditional/conditional06">
    <purpose>Test two xsl:when, no xsl:otherwise, second matches.</purpose>
  </test>
  <test file="conditional/conditional07">
    <purpose>Test single when by itself, fail.</purpose>
  </test>
  <test file="conditional/conditional08">
    <purpose>Test failing when with xsl:otherwise.</purpose>
  </test>
  <test file="conditional/conditional09">
    <purpose>Test single when with xsl:otherwise, success on when.</purpose>
  </test>
  <test file="conditional/conditional10">
    <purpose>Test xsl:if with simplistic boolean expression.</purpose>
  </test>
  <test file="conditional/conditional11">
    <purpose>Test xsl:if with test expression that converts to boolean true.</purpose>
  </test>
  <test file="conditional/conditional12">
    <purpose>Test xsl:if with test involving current node value.</purpose>
  </test>
  <test file="conditional/conditional13">
    <purpose>Test xsl:if with boolean function and test of current node.</purpose>
  </test>
  <test file="conditional/conditional14">
    <purpose>Test xsl:if with test of subelement value.</purpose>
  </test>
  <test file="conditional/conditional15">
    <purpose>Test xsl:if with equality of result tree fragments.</purpose>
  </test>
  <test file="conditional/conditional16">
    <purpose>Test of compound conditions within xsl:if.</purpose>
  </test>
  <test file="conditional/conditional17">
    <purpose>Test that only the content of the first matching xsl:when is instantiated.</purpose>
  </test>
  <test file="conditional/conditional18">
    <purpose>Test that xsl:if can be nested.</purpose>
  </test>
  <test file="conditional/conditional19">
    <purpose>Test that xsl:choose can be nested.</purpose>
  </test>
  <test file="conditional/conditional20">
    <purpose>Test two xsl:when elements using a variable in the test.</purpose>
  </test>
  <test file="conditional/err/conditionalerr01">
    <purpose>Test for xsl:choose with no when or otherwise clauses.</purpose>
  </test>
  <test file="conditional/err/conditionalerr02">
    <purpose>Test xsl:choose without xsl:when, but otherwise exists.</purpose>
  </test>
  <test file="conditional/err/conditionalerr03">
    <purpose>Test of xsl:choose containing sub-element that is not a when or otherwise.</purpose>
  </test>
  <test file="conditional/err/conditionalerr04">
    <purpose>Test xsl:choose having more than one xsl:otherwise.</purpose>
  </test>
  <test file="conditional/err/conditionalerr05">
    <purpose>Test xsl:when after xsl:otherwise, match on final when.</purpose>
  </test>
  <test file="conditional/err/conditionalerr06">
    <purpose>Test bad attribute on xsl:when (only "test" allowed).</purpose>
  </test>
  <test file="conditional/err/conditionalerr07">
    <purpose>Test attempt to put attribute on xsl:otherwise.</purpose>
  </test>
  <test file="conditional/err/conditionalerr08">
    <purpose>Test attempt to put attribute on xsl:choose.</purpose>
  </test>
  <test file="conditional/err/conditionalerr09">
    <purpose>Test xsl:if that lacks the required "test" attribute.</purpose>
  </test>
  <test file="conditional/err/conditionalerr10">
    <purpose>Test xsl:if that has an empty "test" attribute.</purpose>
  </test>
  <test file="conditional/err/conditionalerr11">
    <purpose>Try to use when outside of choose.</purpose>
  </test>
  <test file="conditional/err/conditionalerr12">
    <purpose>Try to use otherwise outside of choose.</purpose>
  </test>
  <test file="conditional/err/conditionalerr13">
    <purpose>Test xsl:when lacking the "test" attribute.</purpose>
  </test>
  <test file="conditional/err/conditionalerr14">
    <purpose>Test xsl:when "test" having null content.</purpose>
  </test>
  <test file="conditional/err/conditionalerr15">
    <purpose>Test of incorrect use of | where 'or' was intended.</purpose>
  </test>
  <test file="conditional/err/conditionalerr16">
    <purpose>Test use of non-existant variable in test attribute.</purpose>
  </test>
  <test file="conditional/err/conditionalerr17"/>
  <test file="conditional/err/conditionalerr18"/>
  <test file="conditional/err/conditionalerr19">
    <purpose>Put xsl:choose at top level, which is illegal.</purpose>
  </test>
  <test file="conditional/err/conditionalerr20">
    <purpose>Put xsl:if at top level, which is illegal.</purpose>
  </test>
  <test file="conditional/err/conditionalerr21">
    <purpose>Put xsl:when at top level, which is illegal.</purpose>
  </test>
  <test file="conditional/err/conditionalerr22">
    <purpose>Put xsl:otherwise at top level, which is illegal.</purpose>
  </test>
  <test file="conflictres/conflictres01">
    <purpose>Test match of element name.</purpose>
  </test>
  <test file="conflictres/conflictres02">
    <purpose>Test for conflict resolution on wildcard names.</purpose>
  </test>
  <test file="conflictres/conflictres03">
    <purpose>Test for conflict resolution - nodetype.</purpose>
  </test>
  <test file="conflictres/conflictres04">
    <purpose>Test for nodetest override of default priority. Also, node selected is attribute instead of element.</purpose>
  </test>
  <test file="conflictres/conflictres05">
    <purpose>Test for conflict resolution between simple and non-simple node patterns.</purpose>
    <comment>No conflict warnings should be seen.</comment>
  </test>
  <test file="conflictres/conflictres06">
    <purpose>Test for conflict resolution on a predicate</purpose>
  </test>
  <test file="conflictres/conflictres07">
    <purpose>Test for conflict resolution with 2 non-simple patterns (predicate and '/')</purpose>
  </test>
  <test file="conflictres/conflictres08">
    <purpose>Test for conflict resolution with 2 non-simple patterns ('/' and predicate)</purpose>
  </test>
  <test file="conflictres/conflictres09">
    <purpose>Verify that template with higher priority executes, and that one with a lower import precedence does not.</purpose>
  </test>
  <test file="conflictres/conflictres10">
    <purpose>Test that second instance of template wins.</purpose>
  </test>
  <test file="conflictres/conflictres11">
    <purpose>Test for conflict resolution - two different node tests.</purpose>
    <comment>should see 1 conflict warning</comment>
  </test>
  <test file="conflictres/conflictres12">
    <purpose>Test that child and descendant are equal in priority.</purpose>
    <comment>should see 2 conflict warnings</comment>
  </test>
  <test file="conflictres/conflictres13">
    <purpose>Test that two patterns containing * at one level are equal in priority, despite one * being deeper.</purpose>
    <comment>should see 1 conflict warning</comment>
  </test>
  <test file="conflictres/conflictres14">
    <purpose>Test that pattern containing * at one level is equal in priority to one containing * at two levels.</purpose>
    <comment>should see 1 conflict warning</comment>
  </test>
  <test file="conflictres/conflictres15">
    <purpose>Test that pattern a//c is higher priority than a/*/c, even though it allows more nodes to qualify.</purpose>
    <comment>should see 4 conflict warnings</comment>
  </test>
  <test file="conflictres/conflictres16">
    <purpose>Test for conflict resolution on a predicate of a wildcard</purpose>
    <comment>No conflict warnings should be seen.</comment>
  </test>
  <test file="conflictres/conflictres17">
    <purpose>If equal priorities are explicitly assigned, default priority rules have no effect on resolving conflicts.</purpose>
    <comment>should see 1 conflict warning</comment>
  </test>
  <test file="conflictres/conflictres18">
    <purpose>Test that @foo has higher priority than @*.</purpose>
    <comment>should see no conflict warnings</comment>
  </test>
  <test file="conflictres/conflictres19">
    <purpose>Test priority rankings of non-namespaced and namespaced attributes. The @ped:* ranks above @* and below the others.</purpose>
    <comment>should see no conflict warnings</comment>
  </test>
  <test file="conflictres/conflictres20">
    <purpose>Test priority rankings of non-namespaced and namespaced elements. The ped:* ranks above * and below the others.</purpose>
    <comment>should see no conflict warnings</comment>
  </test>
  <test file="conflictres/conflictres21">
    <purpose>Test for conflict resolution on a predicate of a node test.</purpose>
    <comment>should see 1 conflict warning</comment>
  </test>
  <test file="conflictres/conflictres22">
    <purpose>Test for conflict resolution on a predicate of a node test for comments.</purpose>
    <comment>should see 1 conflict warning</comment>
  </test>
  <test file="conflictres/conflictres23">
    <purpose>Test for conflict resolution on processing-instruction() node test.</purpose>
    <comment>should see 1 conflict warning, because presence of a predicate raises priority to 0.5</comment>
  </test>
  <test file="conflictres/conflictres24">
    <purpose>Test for conflict resolution on templates assigned equal priority.</purpose>
  </test>
  <test file="copy/copy01">
    <purpose>Test for simple identity transformation with template match</purpose>
  </test>
  <test file="copy/copy02">
    <purpose>Test for simple tree copy, in main template via copy-of naming the document element</purpose>
  </test>
  <test file="copy/copy03">
    <purpose>Use identity transformation to put document tree into result tree fragment, then use xsl:copy-of to move to result</purpose>
  </test>
  <test file="copy/copy04">
    <purpose>Test for copy-of whole tree via wildcard pattern</purpose>
  </test>
  <test file="copy/copy05">
    <purpose>Test copy-of a string constant</purpose>
  </test>
  <test file="copy/copy06">
    <purpose>Test for copy-of a number</purpose>
  </test>
  <test file="copy/copy07">
    <purpose>Test for copying attributes from source to result tree</purpose>
  </test>
  <test file="copy/copy08">
    <purpose>Test of passing HTML to a named template.</purpose>
  </test>
  <test file="copy/copy09">
    <purpose>Test for xsl:copy-of with nodeset. Shows handling of namespaces.</purpose>
  </test>
  <test file="copy/copy10">
    <purpose>Verify copy-of with a result tree fragment. Copy to element and attribute.</purpose>
  </test>
  <test file="copy/copy11">
    <purpose>Verify copy-of with a nodeset.</purpose>
  </test>
  <test file="copy/copy12">
    <purpose>Test for copy-of with boolean constant</purpose>
  </test>
  <test file="copy/copy13">
    <purpose>Test for copy-of with '*' wildcard pattern</purpose>
    <comment>This test also checks handling of comments by copy-of.</comment>
  </test>
  <test file="copy/copy14">
    <purpose>Test for copy-of with '*' wildcard pattern</purpose>
    <comment>This test also checks handling of processing instructions by copy-of.</comment>
  </test>
  <test file="copy/copy15">
    <purpose>Test for-each inside xsl:copy</purpose>
  </test>
  <test file="copy/copy16">
    <purpose>Use id(node-set) to try to create a set of nodes in random order. Either id() or xsl:copy is arranging them in document order.</purpose>
  </test>
  <test file="copy/copy17">
    <purpose>Test for identity transformation exactly as in spec.</purpose>
  </test>
  <test file="copy/copy18">
    <purpose>Test for copy-of with union of attribute nodes.</purpose>
  </test>
  <test file="copy/copy19">
    <purpose>Test copy-of a string constant containing character entity</purpose>
    <comment>With this output encoding, should get one byte of xE8 for the &amp;egrave</comment>
  </test>
  <test file="copy/copy20">
    <purpose>Test copy-of a string constant containing character entity</purpose>
    <comment>With this output encoding, should get two bytes (xC3,xA6) for the &amp;aelig</comment>
  </test>
  <test file="copy/copy21">
    <purpose>Ensure that external entity reference works in copy.</purpose>
  </test>
  <test file="copy/copy22">
    <purpose>Ensure that external entity reference with high-byte character works in copy.</purpose>
    <comment>With this output encoding, should get one byte of xBE for the &amp;frac34</comment>
  </test>
  <test file="copy/copy23">
    <purpose>Test for copy-of text nodes including CDATA.</purpose>
  </test>
  <test file="copy/err/copyerr01">
    <purpose>Test for xsl:copy-of without select.</purpose>
  </test>
  <test file="copy/err/copyerr02">
    <purpose>Put xsl:copy-of at top level, which is illegal.</purpose>
  </test>
  <test file="copy/err/copyerr03">
    <purpose>Put xsl:copy at top level, which is illegal.</purpose>
  </test>
  <test file="dflt/dflt01">
    <purpose>Test for built-in template rule for attributes.</purpose>
  </test>
  <test file="dflt/dflt02">
    <purpose>Test of built-in template for text nodes.</purpose>
    <comment>For testing this should remain commented out. It shows how all nodes are processed, particularly the text nodes. &lt;xsl:template match="text()"&gt; &lt;xsl:value-of select="position()"/&gt;text:&lt;xsl:value-of select="."/&gt;, &lt;/xsl:template&gt;</comment>
  </test>
  <test file="dflt/dflt03">
    <purpose>Test of built-in template for elements.</purpose>
  </test>
  <test file="dflt/dflt04">
    <purpose>Test of built-in template for elements for a named mode.</purpose>
  </test>
  <test file="embed/embed03">
    <purpose>Stylesheet may consist of just a literal result element. This is the example from the spec.</purpose>
  </test>
  <test file="embed/embed04">
    <purpose>From the spec: reference version, non-embedded, for comparison.</purpose>
  </test>
  <test file="embed/embed06">
    <purpose>Do everything inside an HTML element, including for-each and if structures.</purpose>
  </test>
  <test file="embed/mediaembed08">
    <purpose>Test the media attribute and -MEDIA command-line option</purpose>
  </test>
  <test file="embed/err/embederr01">
    <purpose>Literal Result Element used as stylesheet cannot contain top-level elements. Should fail at line containing xsl:key statement</purpose>
  </test>
  <test file="embed/err/embederr02">
    <purpose>See what happens when version number is missing from xsl namespace (above).</purpose>
  </test>
  <test file="expression/expression01">
    <purpose>Test of lang() function, with exact match on "en"</purpose>
  </test>
  <test file="expression/expression02">
    <purpose>Invoke unparsed-entity-uri function</purpose>
    <comment>To avoid dealing with the top of the file path, we just look for the part of the returned value that's in the supplied data.</comment>
  </test>
  <test file="expression/expression03">
    <purpose>Test of lang() function, matching "en-us" to partial qualifier</purpose>
  </test>
  <test file="expression/expression04">
    <purpose>Test of lang() function</purpose>
  </test>
  <test file="expression/expression05">
    <purpose>Test of lang() function, attempting to match "EN" to "en"</purpose>
  </test>
  <test file="expression/err/expressionerr01">
    <purpose>Invoke unparsed-entity-uri function with zero arguments</purpose>
  </test>
  <test file="expression/err/expressionerr02">
    <purpose>Invoke unparsed-entity-uri function with too many arguments</purpose>
  </test>
  <test file="extend/extend01">
    <purpose>Testing Conformance specific extension stuff. The top-level usage of a extension element is not really allowed and should be ignored. Therefore the first xsl:fallback should also be ignored.</purpose>
  </test>
  <test file="extend/extend02">
    <purpose>Testing that xsl:fallback engages when required.</purpose>
  </test>
  <test file="extend/extend03">
    <purpose>Test function-available and element-available with xslt elements and functions.</purpose>
  </test>
  <test file="extend/extend04">
    <purpose>Test for-each inside xsl:fallback. Also have content with in the extension.</purpose>
  </test>
  <test file="extend/err/extenderr01">
    <purpose>Put xsl:fallback at top level, which is illegal.</purpose>
  </test>
  <test file="extend/err/extenderr02">
    <purpose>Test function-available with too few arguments.</purpose>
  </test>
  <test file="extend/err/extenderr03">
    <purpose>Test function-available with too many arguments.</purpose>
  </test>
  <test file="extend/err/extenderr04">
    <purpose>Test element-available with too few arguments.</purpose>
  </test>
  <test file="extend/err/extenderr05">
    <purpose>Test element-available with too many arguments.</purpose>
  </test>
  <test file="idkey/idkey01">
    <purpose>Build links using keys and generate-id().</purpose>
  </test>
  <test file="idkey/idkey02">
    <purpose>Make one keyspace and use it.</purpose>
  </test>
  <test file="idkey/idkey03">
    <purpose>Test for key() in template pattern matching.</purpose>
  </test>
  <test file="idkey/idkey04">
    <purpose>Test for id().</purpose>
  </test>
  <test file="idkey/idkey05">
    <purpose>Test for xsl:key, where value of use is a string constant.</purpose>
  </test>
  <test file="idkey/idkey06">
    <purpose>Test of 'generate-id()' - ensure same node generates same ID.</purpose>
  </test>
  <test file="idkey/idkey07">
    <purpose>Test of 'generate-id()'</purpose>
    <comment>Results will vary by processor. Should see 5 different values regardless of what they are.</comment>
  </test>
  <test file="idkey/idkey08">
    <purpose>Test for xsl:key, where value of use is an integer.</purpose>
  </test>
  <test file="idkey/idkey09">
    <purpose>Test for id() behaving well when there is no DTD to designate an ID.</purpose>
    <comment>No exception expected, but output is just some blank lines.</comment>
  </test>
  <test file="idkey/idkey10">
    <purpose>Test for match attribute being first in xsl:key.</purpose>
  </test>
  <test file="idkey/idkey11">
    <purpose>Test for use attribute being first in xsl:key.</purpose>
  </test>
  <test file="idkey/idkey12">
    <purpose>Test for xsl:key matching multiple keys on same node.</purpose>
    <comment>"There can be multiple keys in a document with the same node, same key name, but different key values."</comment>
  </test>
  <test file="idkey/idkey13">
    <purpose>Test for xsl:key matching multiple nodes on same looked-up value.</purpose>
    <comment>"There can be multiple keys in a document with the same key name, same key value, but different nodes."</comment>
  </test>
  <test file="idkey/idkey15">
    <purpose>Test xsl:key where match nodes occur at different levels in the document.</purpose>
  </test>
  <test file="idkey/idkey16">
    <purpose>Test for three keyspaces using the same nodes as keys.</purpose>
  </test>
  <test file="idkey/idkey17">
    <purpose>Test key() with a node-set as second argument.</purpose>
    <comment>"When the second argument to key is of type node-set, then the result is the union of the result of applying the key function to the string value of each of the nodes in the argument node-set."</comment>
  </test>
  <test file="idkey/idkey18">
    <purpose>Test combination of key() and document() as suggested in spec.</purpose>
  </test>
  <test file="idkey/idkey19">
    <purpose>Test for xsl:key and key() with a qualified name.</purpose>
  </test>
  <test file="idkey/idkey20">
    <purpose>Test for xsl:key being imported.</purpose>
  </test>
  <test file="idkey/idkey21">
    <purpose>Test for nested calls to key() function.</purpose>
  </test>
  <test file="idkey/idkey22">
    <purpose>Test for id() in complex structure.</purpose>
    <comment>Now the templates for the specific cases</comment>
  </test>
  <test file="idkey/idkey23">
    <purpose>Test for id() with a non-matching value.</purpose>
  </test>
  <test file="idkey/idkey24">
    <purpose>Test for id(string), where string is a whitespace-separated list of values.</purpose>
  </test>
  <test file="idkey/idkey25">
    <purpose>Test for variable as first argument to key().</purpose>
  </test>
  <test file="idkey/idkey26">
    <purpose>Test for id(node-set), where node-set has multiple values.</purpose>
  </test>
  <test file="idkey/idkey27">
    <purpose>Test whether blank keying (use) value works or is ignored.</purpose>
  </test>
  <test file="idkey/idkey28">
    <purpose>Test whether blank keying (use) value works when it's an attribute.</purpose>
  </test>
  <test file="idkey/idkey29">
    <purpose>Use content of an element as the "use" value.</purpose>
  </test>
  <test file="idkey/idkey30">
    <purpose>Test of 'generate-id()' on various kinds of nodes</purpose>
    <comment>Results will vary by processor.</comment>
  </test>
  <test file="idkey/idkey31">
    <purpose>Test of 'generate-id()' on namespace nodes</purpose>
    <comment>Results will vary by processor.</comment>
  </test>
  <test file="idkey/idkey32">
    <purpose>Use key() for sorting with apply-templates.</purpose>
  </test>
  <test file="idkey/idkey33">
    <purpose>Use key() for sorting in for-each.</purpose>
  </test>
  <test file="idkey/idkey34">
    <purpose>Test descendants of node-set from key().</purpose>
  </test>
  <test file="idkey/idkey35">
    <purpose>Test descendants of node-set from key() in a match pattern.</purpose>
  </test>
  <test file="idkey/idkey36">
    <purpose>Test for three keyspaces, some being imported.</purpose>
  </test>
  <test file="idkey/err/idkeyerr01">
    <purpose>Test for missing name attribute in xsl:key.</purpose>
  </test>
  <test file="idkey/err/idkeyerr02">
    <purpose>Test for missing match attribute in xsl:key.</purpose>
  </test>
  <test file="idkey/err/idkeyerr03">
    <purpose>Test for missing use attribute in xsl:key.</purpose>
  </test>
  <test file="idkey/err/idkeyerr04"/>
  <test file="idkey/err/idkeyerr05"/>
  <test file="idkey/err/idkeyerr06"/>
  <test file="idkey/err/idkeyerr07">
    <purpose>Test for invalid value of name attribute in xsl:key.</purpose>
  </test>
  <test file="idkey/err/idkeyerr08">
    <purpose>Test for invalid value of match attribute in xsl:key.</purpose>
  </test>
  <test file="idkey/err/idkeyerr09">
    <purpose>Test for invalid value of use attribute in xsl:key.</purpose>
  </test>
  <test file="idkey/err/idkeyerr10">
    <purpose>Test for use of key() without a corresponding xsl:key declaration.</purpose>
  </test>
  <test file="idkey/err/idkeyerr11">
    <purpose>It is an error for the "match" attribute on xsl:key to contain a variable reference.</purpose>
  </test>
  <test file="idkey/err/idkeyerr12">
    <purpose>It is an error for the "use" attribute on xsl:key to contain a variable reference.</purpose>
  </test>
  <test file="idkey/err/idkeyerr13">
    <purpose>Test for two xsl:key declarations with the same name attribute.</purpose>
    <comment>The spec allows this. If the processor implements the feature, then 'titles' is one keyspace where the two types of 'use' nodes index their designated match nodes, but don't cross-index the others as would happen if | notation was used in one xsl:key.</comment>
  </test>
  <test file="idkey/err/idkeyerr14">
    <purpose>Call key() with too few arguments.</purpose>
  </test>
  <test file="idkey/err/idkeyerr15">
    <purpose>Call key() with too many arguments.</purpose>
  </test>
  <test file="idkey/err/idkeyerr16">
    <purpose>Test of 'generate-id()' with multiple arguments. Should generate an error. Should test for zero, or one argument.</purpose>
  </test>
  <test file="idkey/err/idkeyerr17">
    <purpose>Test placement of xsl:key inside atemplate, which is illegal.</purpose>
  </test>
  <test file="idkey/err/idkeyerr18">
    <purpose>Test for id() with too few arguments.</purpose>
  </test>
  <test file="idkey/err/idkeyerr19">
    <purpose>Test for id() with too many arguments.</purpose>
  </test>
  <test file="idkey/err/idkeyerr20">
    <purpose>Test for xsl:key that uses key() on a different keyspace in its match attribute.</purpose>
  </test>
  <test file="impincl/impincl01">
    <purpose>Test of basic Import &amp; Include functionality.</purpose>
  </test>
  <test file="impincl/impincl02">
    <purpose>Included document's xsl:import (f imports g) is moved into the including document. Import precedence is impincl02, g, h</purpose>
  </test>
  <test file="impincl/impincl03">
    <purpose>Nest imports and includes so that there are two of each, import on top.</purpose>
  </test>
  <test file="impincl/impincl04">
    <purpose>Verifies; "A relative URI is resolved relative to the base URI of the xsl:include element". The included document loads from an included file that resides in a different subdirectory.</purpose>
  </test>
  <test file="impincl/impincl05">
    <purpose>Two imports, each of which has an import, plus an apply-imports in main stylesheet.</purpose>
  </test>
  <test file="impincl/impincl06">
    <purpose>Two includes, each of which has an import.</purpose>
  </test>
  <test file="impincl/impincl07">
    <purpose>Two imports, each of which has an import, plus an apply-imports in main stylesheet.</purpose>
  </test>
  <test file="impincl/impincl08">
    <purpose>Loads document from an included file that resides in a different subdirectory.</purpose>
  </test>
  <test file="impincl/impincl09">
    <purpose>The resource located by the href attribute value is parsed as an XML document, and the children of the xsl:stylesheet element in this document replace the xsl:include element in the including document. (No namespaces should be copied over.</purpose>
  </test>
  <test file="impincl/impincl10">
    <purpose>General test of xsl:apply-imports from spec.</purpose>
  </test>
  <test file="impincl/impincl11">
    <purpose>Nest imports and includes using relative paths.</purpose>
  </test>
  <test file="impincl/impincl12">
    <purpose>Test of basic Import &amp; Include functionality over the network.</purpose>
    <comment>xsl:import href="http://www.oucs.ox.ac.uk/stylesheets/teihtml-param.xsl"/</comment>
  </test>
  <test file="impincl/impincl14">
    <purpose>Show that apply-imports has limited scope of rules to search.</purpose>
    <comment>"xsl:apply-imports processes the current node using only template rules that were imported into the stylesheet CONTAINING THE CURRENT TEMPLATE RULE...." The apply-imports will be done in c.xsl; rules from r won't apply at that time.</comment>
  </test>
  <test file="impincl/impincl15">
    <purpose>Test that apply-imports stays in same mode as what called it.</purpose>
  </test>
  <test file="impincl/impincl16">
    <purpose>Test of importing a basic stylesheet involving matching.</purpose>
  </test>
  <test file="impincl/impincl17">
    <purpose>Test of importing a stylesheet involving keys.</purpose>
  </test>
  <test file="impincl/err/impinclerr01">
    <purpose>It is an error for a stylesheet to import itself.</purpose>
  </test>
  <test file="impincl/err/impinclerr02">
    <purpose>It is an error if apply-imports is instantiated when the current template rule is null, i.e. from within a xsl:for-each loop.</purpose>
  </test>
  <test file="impincl/err/impinclerr03">
    <purpose>Imports must precede all other elements, including Includes, in a stylesheet.</purpose>
  </test>
  <test file="impincl/err/impinclerr04">
    <purpose>It is an error for a stylesheet to include itself.</purpose>
  </test>
  <test file="impincl/err/impinclerr05">
    <purpose>Check that proper error is reported if required attribute, href, is not included.</purpose>
    <comment>Note: SCurcuru 28-Feb-00 added ExpectedException; seems like good error text to me.</comment>
  </test>
  <test file="impincl/err/impinclerr06">
    <purpose>Check that proper error is reported if required attribute, href, is not included.</purpose>
    <comment>Note: SCurcuru 28-Feb-00 added ExpectedException; seems like good error text to me.</comment>
  </test>
  <test file="impincl/err/impinclerr07">
    <purpose>Put xsl:apply-imports at top level, which is illegal.</purpose>
  </test>
  <test file="impincl/err/impinclerr08">
    <purpose>Test placement of xsl:import inside a template, which is illegal.</purpose>
  </test>
  <test file="impincl/err/impinclerr09">
    <purpose>Test placement of xsl:include inside a template, which is illegal.</purpose>
  </test>
  <test file="impincl-test/impincl04"/>
  <test file="impincl-test/impincl08"/>
  <test file="lre/lre01">
    <purpose>In a template, an element in the stylesheet that does not belong to the XSLT namespace and that is not an extension element is instantiated to create an element node with the same expanded-name. ... The created element node will have the attribute nodes that were present on the element node in the stylesheet tree, other than attributes with names in the XSLT namespace</purpose>
  </test>
  <test file="lre/lre02">
    <purpose>The created element node will also have a copy of the namespace nodes that were present on the element node in the stylesheet tree with the exception of any namespace node whose string-value is the XSLT namespace URI, a namespace URI declared as an extension namespace, or a namespace URI designated as an excluded namespace. Excluded namespaces specified with exclude-result-prefixes attribute of xsl:stylesheet .</purpose>
  </test>
  <test file="lre/lre03">
    <purpose>The created element node will also have a copy of the namespace nodes that were present on the element node in the stylesheet tree with the exception of any namespace node whose string-value is the XSLT namespace URI, a namespace URI declared as an extension namespace, or a namespace URI designated as an excluded namespace. Excluded namespaces specified with xsl:exclude-result-prefixes attribute of LRE.</purpose>
  </test>
  <test file="lre/lre04">
    <purpose>The designation of a namespace as an excluded namespace is effective within the subtree of the stylesheet rooted at the element bearing the exclude-result-prefixes or xsl:exclude-result-prefixes attribute.</purpose>
  </test>
  <test file="lre/lre05">
    <purpose>Show that exclude-result-prefixes is scoped to just it's LRE.</purpose>
    <comment>The designation of a namespace as an excluded namespace is effective within the subtree of the stylesheet rooted at the element bearing the exclude-result-prefixes or xsl:exclude-result-prefixes attribute. A subtree rooted at an xsl:stylesheet element does not include any stylesheets imported or included by children of that xsl:stylesheet element.</comment>
  </test>
  <test file="lre/lre06">
    <purpose>Tests that the value of an attribute of a LRE is interpreted as a attribute value template, which can contain expressions within curly braces({}).</purpose>
  </test>
  <test file="lre/lre07">
    <purpose>The xsl:element element allows an element to be created with a computed name. The expanded-name of the element to be created is specified by a required name attribute and an optional namespace attribute.</purpose>
  </test>
  <test file="lre/lre08">
    <purpose>The name attribute of xsl:element is interpreted as an attribute value template.</purpose>
  </test>
  <test file="lre/lre10">
    <purpose>If the namespace attribute is present, then it also is interpreted as an attribute value template...</purpose>
  </test>
  <test file="lre/lre11">
    <purpose>Testing the xsl:transform element and its attributes. english attribute and ped,bdd namespace nodes are all that should be output.</purpose>
  </test>
  <test file="lre/lre12">
    <purpose>Test warning if required element name is null.</purpose>
  </test>
  <test file="lre/lre13">
    <purpose>Try to put out text without any tags.</purpose>
  </test>
  <test file="lre/lre14">
    <purpose>Test for-each inside xsl:element</purpose>
  </test>
  <test file="lre/lre15">
    <purpose>xsl:exclude-result-prefixes should only work to omit namespace declarations that are not actually used.</purpose>
  </test>
  <test file="lre/lre16">
    <purpose>Try to put out value of a variable as an LRE. Get "$var" literally.</purpose>
  </test>
  <test file="lre/lre17">
    <purpose>xsl:exclude-result-prefixes should only work to omit namespace declarations that are not actually used.</purpose>
  </test>
  <test file="lre/lre18">
    <purpose>xsl:exclude-result-prefixes should only work to omit namespace declarations that are not actually used.</purpose>
  </test>
  <test file="lre/err/lreerr01">
    <purpose>It is an error if there is no namespace bound to the prefix named in the exclude-result-prefixes attribute of the stylesheet.</purpose>
    <comment>Note: SCurcuru 28-Feb-00 added ExpectedException; seems like good error text to me.</comment>
  </test>
  <test file="lre/err/lreerr02">
    <purpose>It is an error if there is no namespace bound to the prefix on the element bearing the xsl:exclude-result-prefixes attribute.</purpose>
    <comment>Note: SCurcuru 28-Feb-00 added ExpectedException; seems like good error text to me.</comment>
  </test>
  <test file="lre/err/lreerr03">
    <purpose>Test error reporting if required attribute of xsl:element is not specified.</purpose>
  </test>
  <test file="lre/err/lreerr04">
    <purpose>Test error reporting if required attribute of xsl:attribute is not specified.</purpose>
  </test>
  <test file="lre/err/lreerr05">
    <purpose>Try to put out literal output without a template.</purpose>
  </test>
  <test file="lre/err/lreerr06">
    <purpose>Try to put out value of a variable without a template.</purpose>
  </test>
  <test file="lre/err/lreerr07">
    <purpose>Try to put out literal output without a template.</purpose>
  </test>
  <test file="match/match01">
    <purpose>Test for //name match pattern.</purpose>
  </test>
  <test file="match/match02">
    <purpose>Test of predicate, using attribute, in match pattern.</purpose>
  </test>
  <test file="match/match03">
    <purpose>Test of @attrib=value in predicate in match pattern.</purpose>
  </test>
  <test file="match/match04">
    <purpose>Test of node=value in predicate in match pattern.</purpose>
  </test>
  <test file="match/match05">
    <purpose>Test of or in predicate of match pattern.</purpose>
  </test>
  <test file="match/match06">
    <purpose>Test of boolean not function in match pattern.</purpose>
  </test>
  <test file="match/match07">
    <purpose>Test of node!=value match pattern.</purpose>
  </test>
  <test file="match/match08">
    <purpose>Test of 2 predicates.</purpose>
  </test>
  <test file="match/match09">
    <purpose>Test of boolean and in predicate.</purpose>
  </test>
  <test file="match/match10">
    <purpose>Test of functions in predicate.</purpose>
  </test>
  <test file="match/match11">
    <purpose>Test of id('literal') as match pattern.</purpose>
  </test>
  <test file="match/match12">
    <purpose>Test that apply-templates goes down at least 15 levels.</purpose>
    <comment>Suppress the default action on these.</comment>
  </test>
  <test file="match/match13">
    <purpose>Test of large union.</purpose>
  </test>
  <test file="match/match14">
    <purpose>Show that a variable can be used in a match pattern, though not for the name test. The variable must be top-level, of course.</purpose>
  </test>
  <test file="match/err/matcherr01">
    <purpose>Test for error when xsl:template has neither match nor name.</purpose>
  </test>
  <test file="match/err/matcherr02">
    <purpose>Try to use xsl:template as something other than a top-level element.</purpose>
  </test>
  <test file="match/err/matcherr03">
    <purpose>Test for error when xsl:template is nested in another top-level element.</purpose>
  </test>
  <test file="match/err/matcherr04">
    <purpose>Put content other than sort or param inside apply-templates.</purpose>
  </test>
  <test file="match/err/matcherr05">
    <purpose>Put a disallowed attribute on xsl:template.</purpose>
  </test>
  <test file="match/err/matcherr06">
    <purpose>Test document() function in a match pattern. The spec doesn't say whether it's allowed or not, but NOT seems likely.</purpose>
  </test>
  <test file="match/err/matcherr07">
    <purpose>Put a disallowed attribute on xsl:apply-templates.</purpose>
  </test>
  <test file="match/err/matcherr08">
    <purpose>Test for error when xsl:template has neither match nor name, but has a mode.</purpose>
  </test>
  <test file="match/err/matcherr09">
    <purpose>Put xsl:apply-templates at top level, which is illegal.</purpose>
  </test>
  <test file="math/math01">
    <purpose>Test of number() conversion function on an element.</purpose>
  </test>
  <test file="math/math02">
    <purpose>Test of floor().</purpose>
  </test>
  <test file="math/math03">
    <purpose>Test of ceiling().</purpose>
  </test>
  <test file="math/math04">
    <purpose>Test of round().</purpose>
  </test>
  <test file="math/math05">
    <purpose>Test of sum().</purpose>
  </test>
  <test file="math/math06">
    <purpose>Test of '*' operator.</purpose>
  </test>
  <test file="math/math07">
    <purpose>Test of '+' operator.</purpose>
  </test>
  <test file="math/math08">
    <purpose>Test of '-' operator. Note since XML allows "-" in names the "-" operator typically needs to be preceded by whitespace.</purpose>
  </test>
  <test file="math/math09">
    <purpose>Test of 'div' operator.</purpose>
  </test>
  <test file="math/math10">
    <purpose>Test of 'mod' operator.</purpose>
  </test>
  <test file="math/math11">
    <purpose>Test of number() conversion function on a non-existent node.</purpose>
  </test>
  <test file="math/math12">
    <purpose>Test of number() conversion function on numeric input.</purpose>
  </test>
  <test file="math/math13">
    <purpose>Test of number() conversion function on a string that is convertible.</purpose>
  </test>
  <test file="math/math14">
    <purpose>Test of number() conversion function on a null string.</purpose>
  </test>
  <test file="math/math15">
    <purpose>Test of number() conversion function on a string that is not convertible.</purpose>
  </test>
  <test file="math/math16">
    <purpose>Test of number() and string() conversion functions for numeric accuracy.</purpose>
  </test>
  <test file="math/math17">
    <purpose>Test of number() conversion function on a tree fragment.</purpose>
  </test>
  <test file="math/math18">
    <purpose>Test of number() conversion function on an empty tree fragment.</purpose>
  </test>
  <test file="math/math19">
    <purpose>Test of number() conversion of boolean constant true.</purpose>
  </test>
  <test file="math/math20">
    <purpose>Test of number() conversion of boolean constant false.</purpose>
  </test>
  <test file="math/math21">
    <purpose>Test of consistency number() conversion of non-convertible strings.</purpose>
  </test>
  <test file="math/math22">
    <purpose>Test of number() conversion of a non-convertible string.</purpose>
  </test>
  <test file="math/math23">
    <purpose>Test of floor() on a node.</purpose>
  </test>
  <test file="math/math24">
    <purpose>Test of floor() on a non-integer.</purpose>
  </test>
  <test file="math/math25">
    <purpose>Test of floor() on a node containing a non-integer.</purpose>
  </test>
  <test file="math/math26">
    <purpose>Test of floor() near a boundary.</purpose>
  </test>
  <test file="math/math27">
    <purpose>Test of floor() on a node containing a boundary case.</purpose>
  </test>
  <test file="math/math28">
    <purpose>Test of floor() on a negative non-integer.</purpose>
  </test>
  <test file="math/math29">
    <purpose>Test of floor().</purpose>
  </test>
  <test file="math/math30">
    <purpose>Test of floor() of a non-integer.</purpose>
  </test>
  <test file="math/math31">
    <purpose>Test of floor() on a negative non-integer.</purpose>
  </test>
  <test file="math/math32">
    <purpose>Test of ceiling() on a node containing an integer.</purpose>
  </test>
  <test file="math/math33">
    <purpose>Test of ceiling() on a non-integer.</purpose>
  </test>
  <test file="math/math34">
    <purpose>Test of ceiling() of a node containing a non-integer.</purpose>
  </test>
  <test file="math/math35">
    <purpose>Test of ceiling() on a boundary case.</purpose>
  </test>
  <test file="math/math36">
    <purpose>Test of ceiling() on a node containing a boundary case.</purpose>
  </test>
  <test file="math/math37">
    <purpose>Test of ceiling().</purpose>
  </test>
  <test file="math/math38">
    <purpose>Test of ceiling() on a non-integer.</purpose>
  </test>
  <test file="math/math39">
    <purpose>Test of ceiling() on a negative non-integer.</purpose>
  </test>
  <test file="math/math40">
    <purpose>Test of round() on a node.</purpose>
  </test>
  <test file="math/math41">
    <purpose>Test of round() of a non-integer below halfway.</purpose>
  </test>
  <test file="math/math42">
    <purpose>Test of round() of a node containing a non-integer below halfway.</purpose>
  </test>
  <test file="math/math43">
    <purpose>Test of round() of a boundary case.</purpose>
  </test>
  <test file="math/math44">
    <purpose>Test of round() of a node containing a boundary case.</purpose>
  </test>
  <test file="math/math45">
    <purpose>Test of round() of a non-integer below halfway.</purpose>
  </test>
  <test file="math/math46">
    <purpose>Test of round() of a negative non-integer above halfway.</purpose>
  </test>
  <test file="math/math47">
    <purpose>Test of round() of a non-integer above halfway.</purpose>
  </test>
  <test file="math/math48">
    <purpose>Test of round() of a negative non-integer below halfway.</purpose>
  </test>
  <test file="math/math49">
    <purpose>Test of round() of a non-integer at halfway.</purpose>
  </test>
  <test file="math/math50">
    <purpose>Test of round() of a non-integer at halfway.</purpose>
  </test>
  <test file="math/math51">
    <purpose>Test of round() of a negative non-integer at halfway.</purpose>
  </test>
  <test file="math/math52">
    <purpose>Test of round() of a negative non-integer at halfway.</purpose>
  </test>
  <test file="math/math53">
    <purpose>Test of sum().</purpose>
  </test>
  <test file="math/math54">
    <purpose>Test of sum().</purpose>
  </test>
  <test file="math/math55">
    <purpose>Test of '*' operator on two nodes.</purpose>
  </test>
  <test file="math/math56">
    <purpose>Test of '*' operator on attributes.</purpose>
  </test>
  <test file="math/math57">
    <purpose>Test of '+' operator on two nodes.</purpose>
  </test>
  <test file="math/math58">
    <purpose>Test of '+' operator on two attributes.</purpose>
  </test>
  <test file="math/math59">
    <purpose>Test of '+' operator on two attributes, without parentheses.</purpose>
  </test>
  <test file="math/math60">
    <purpose>Test of '-' operator, negative result.</purpose>
  </test>
  <test file="math/math61">
    <purpose>Test of '-' operator on two nodes whose names have hyphens.</purpose>
  </test>
  <test file="math/math62">
    <purpose>Test of '+' operator and unary '-'.</purpose>
  </test>
  <test file="math/math63">
    <purpose>Test of '+' operator and unary '-' on nodes whose names have hyphens.</purpose>
  </test>
  <test file="math/math64">
    <purpose>Test of '-' operator and unary '-'.</purpose>
  </test>
  <test file="math/math65">
    <purpose>Test of '-' operator and unary '-' on nodes whose names have hyphens.</purpose>
  </test>
  <test file="math/math66">
    <purpose>Test of '-' operator and unary '-'.</purpose>
  </test>
  <test file="math/math67">
    <purpose>Test of '-' operator and unary '-' on nodes whose names have hyphens.</purpose>
  </test>
  <test file="math/math68">
    <purpose>Test of '-' operator and unary '-' on attributes of nodes whose names have hyphens.</purpose>
  </test>
  <test file="math/math69">
    <purpose>Test of '-' operator and unary '-' outside parentheses, with values from attributes.</purpose>
  </test>
  <test file="math/math70">
    <purpose>Test of 'div' operator, negative divisor.</purpose>
  </test>
  <test file="math/math71">
    <purpose>Test of 'div' operator on two nodes.</purpose>
  </test>
  <test file="math/math72">
    <purpose>Test of 'div' operator on two nodes with confusing names.</purpose>
  </test>
  <test file="math/math73">
    <purpose>Test of 'div' operator on two attributes.</purpose>
  </test>
  <test file="math/math74">
    <purpose>Test of 'div' operator on attributes of nodes with confusing names.</purpose>
  </test>
  <test file="math/math75">
    <purpose>Test of 'div' operator with -0 as divisor.</purpose>
  </test>
  <test file="math/math76">
    <purpose>Test of 'div' operator, comparing 0 and -0 as divisors.</purpose>
  </test>
  <test file="math/math77">
    <purpose>Test of 'div' operator with 0 on both sides.</purpose>
  </test>
  <test file="math/math78">
    <purpose>Test of 'div' operator and less-than.</purpose>
  </test>
  <test file="math/math79">
    <purpose>Test of 'mod' operator on two nodes.</purpose>
  </test>
  <test file="math/math80">
    <purpose>Test of 'mod' operator on two nodes with confusing names.</purpose>
  </test>
  <test file="math/math81">
    <purpose>Test of 'mod' operator on two attributes.</purpose>
  </test>
  <test file="math/math82">
    <purpose>Test of 'mod' operator on attributes of nodes with confusing names.</purpose>
  </test>
  <test file="math/math83">
    <purpose>Test of 'mod' operator on positive and negative operands.</purpose>
  </test>
  <test file="math/math84">
    <purpose>Test of sum().</purpose>
  </test>
  <test file="math/math85">
    <purpose>Test of nesting of parentheses.</purpose>
  </test>
  <test file="math/math86">
    <purpose>Test of repeated use of * to multiply.</purpose>
  </test>
  <test file="math/math87">
    <purpose>Test of repeated division.</purpose>
  </test>
  <test file="math/math88">
    <purpose>Mini stress of x-way multiply and divide.</purpose>
  </test>
  <test file="math/math89">
    <purpose>Test that NaN propagates through + and parentheses.</purpose>
  </test>
  <test file="math/math90">
    <purpose>Test that NaN propagates through * and unary -.</purpose>
  </test>
  <test file="math/math91">
    <purpose>Test that NaN propagates through subtraction.</purpose>
  </test>
  <test file="math/math92">
    <purpose>Test that NaN propagates through div.</purpose>
  </test>
  <test file="math/math93">
    <purpose>Test that NaN propagates through mod.</purpose>
  </test>
  <test file="math/math94">
    <purpose>Test that NaN propagates through the numeric functions.</purpose>
  </test>
  <test file="math/math95">
    <purpose>Test of sum() with non-number.</purpose>
  </test>
  <test file="math/math96">
    <purpose>Test of sum() with unary - in some nodes.</purpose>
  </test>
  <test file="math/math97">
    <purpose>Test of repeated use of +.</purpose>
  </test>
  <test file="math/math98">
    <purpose>Test of repeated use of -. Space away from - when required.</purpose>
  </test>
  <test file="math/math99">
    <purpose>Test that * has precedence over + and -.</purpose>
  </test>
  <test file="math/math100">
    <purpose>Test that div has precedence over + and -.</purpose>
  </test>
  <test file="math/math101">
    <purpose>Test that mod has precedence over + and -.</purpose>
  </test>
  <test file="math/math102">
    <purpose>Test that number() with no argument applies to context node.</purpose>
  </test>
  <test file="math/math103">
    <purpose>Test of unary '-' on a union.</purpose>
  </test>
  <test file="math/math104">
    <purpose>Test of is-a-number technique.</purpose>
  </test>
  <test file="math/err/matherr01">
    <purpose>Test reaction to obsolete 'quo' operator.</purpose>
  </test>
  <test file="math/err/matherr02">
    <purpose>Test of invalid function that resembles "true" with unary minus.</purpose>
  </test>
  <test file="math/err/matherr03">
    <purpose>Test of invalid function that resembles "true" with number().</purpose>
  </test>
  <test file="math/err/matherr04">
    <purpose>Test of invalid function that resembles "true" with multiplication.</purpose>
  </test>
  <test file="math/err/matherr05">
    <purpose>Test of invalid function that resembles "true" with div.</purpose>
  </test>
  <test file="math/err/matherr06">
    <purpose>Test of number() with too many arguments.</purpose>
  </test>
  <test file="math/err/matherr07">
    <purpose>Test of sum() with too many arguments.</purpose>
  </test>
  <test file="math/err/matherr08">
    <purpose>Test of sum() with zero arguments.</purpose>
  </test>
  <test file="math/err/matherr09">
    <purpose>Test of floor() with too many arguments.</purpose>
  </test>
  <test file="math/err/matherr10">
    <purpose>Test of floor() with zero arguments.</purpose>
  </test>
  <test file="math/err/matherr11">
    <purpose>Test of ceiling() with too many arguments.</purpose>
  </test>
  <test file="math/err/matherr12">
    <purpose>Test of ceiling() with zero arguments.</purpose>
  </test>
  <test file="math/err/matherr13">
    <purpose>Test of round() with too many arguments.</purpose>
  </test>
  <test file="math/err/matherr14">
    <purpose>Test of round() with zero arguments.</purpose>
  </test>
  <test file="mdocs/mdocs01">
    <purpose>Test document() function: Provides multiple input sources. One argument: string.</purpose>
  </test>
  <test file="mdocs/mdocs02">
    <purpose>Test nesting of document() function.</purpose>
  </test>
  <test file="mdocs/mdocs03">
    <purpose>Test document() function: Provides multiple input sources. Two arguments: string, node-set.</purpose>
  </test>
  <test file="mdocs/mdocs04">
    <purpose>Test document() function with one argument: node-set.</purpose>
  </test>
  <test file="mdocs/mdocs05">
    <purpose>Test document() function with path following.</purpose>
  </test>
  <test file="mdocs/mdocs06">
    <purpose>Test document() function with two arguments: node-set, node-set.</purpose>
  </test>
  <test file="mdocs/mdocs07">
    <purpose>Test document() function: Mini Stress test. The many 'a' elements contain repeats of the file names. Union should not contain duplicate nodes.</purpose>
  </test>
  <test file="mdocs/mdocs08">
    <purpose>Test document() function: Generating nodeset based on ancestors of document() union.</purpose>
  </test>
  <test file="mdocs/mdocs09">
    <purpose>Test that document("") refers to the root node of the stylesheet.</purpose>
    <comment>Remember: every top-level node in the stylesheet must have a namespace.</comment>
  </test>
  <test file="mdocs/mdocs10">
    <purpose>Test document() function with local file specification.</purpose>
  </test>
  <test file="mdocs/mdocs11">
    <purpose>Check that position() counts nodes in external document.</purpose>
  </test>
  <test file="mdocs/mdocs12">
    <purpose>When document('') refers to the root node of the stylesheet, it means the current file, not the main stylesheet. In this test, the call to document() is in the included stylesheet, hence local to it.</purpose>
    <comment>Remember: every top-level node in the stylesheet must have a namespace.</comment>
  </test>
  <test file="mdocs/mdocs13">
    <purpose>When document('') refers to the root node of the stylesheet, it means the current file, not the main stylesheet. In this test, the call to document() is in the imported stylesheet, hence local to it.</purpose>
    <comment>Remember: every top-level node in the stylesheet must have a namespace.</comment>
  </test>
  <test file="mdocs/mdocs14">
    <purpose>Use document() to perform an include-like operation between two files. At the conformance level, this shows that we can put the node-set from document() into a variable, then reference where a node-set is required.</purpose>
  </test>
  <test file="mdocs/mdocs15">
    <purpose>Test / as second argument to document(). Two arguments: string variable, node-set.</purpose>
  </test>
  <test file="mdocs/err/mdocserr01">
    <purpose>Test document() function with non-existent file.</purpose>
  </test>
  <test file="mdocs/err/mdocserr02">
    <purpose>Test document() function with zero arguments.</purpose>
  </test>
  <test file="mdocs/err/mdocserr03">
    <purpose>Test document() function with too many arguments.</purpose>
  </test>
  <test file="mdocs/err/mdocserr04">
    <purpose>Top-level elements must have some namespace.</purpose>
  </test>
  <test file="message/message01">
    <purpose>Issue a message from a literal constant, default on terminate option</purpose>
  </test>
  <test file="message/message02">
    <purpose>Issue a message from a literal constant, "no" on terminate option</purpose>
  </test>
  <test file="message/message03">
    <purpose>Test xsl:text inside xsl:message</purpose>
  </test>
  <test file="message/message04">
    <purpose>Test for-each and value-of inside xsl:message</purpose>
  </test>
  <test file="message/message05">
    <purpose>Test if and copy-of inside xsl:message</purpose>
  </test>
  <test file="message/message06">
    <purpose>Test choose and variable inside xsl:message</purpose>
  </test>
  <test file="message/message07">
    <purpose>Test apply-templates inside xsl:message</purpose>
  </test>
  <test file="message/message08">
    <purpose>Test call-template inside xsl:message</purpose>
  </test>
  <test file="message/message09">
    <purpose>Test one xsl:message inside another</purpose>
  </test>
  <test file="message/message10">
    <purpose>Test xsl:element and xsl:attribute inside xsl:message</purpose>
  </test>
  <test file="message/message11">
    <purpose>Test xsl:comment inside xsl:message</purpose>
  </test>
  <test file="message/message12">
    <purpose>Test xsl:processing-instruction inside xsl:message</purpose>
  </test>
  <test file="message/message13">
    <purpose>Test xsl:copy inside xsl:message</purpose>
  </test>
  <test file="message/message14">
    <purpose>Test xsl:number inside xsl:message; number should appear.</purpose>
  </test>
  <test file="message/message15">
    <purpose>Test xsl:fallback inside xsl:message</purpose>
  </test>
  <test file="message/message16">
    <purpose>Test xsl:message inside xsl:param instead of xsl:template</purpose>
  </test>
  <test file="message/err/messageerr01">
    <purpose>Put xsl:message at top level, which is illegal.</purpose>
  </test>
  <test file="message/err/messageerr02">
    <purpose>Illegal value "duh" on terminate option</purpose>
  </test>
  <test file="message/err/messageerr03">
    <purpose>Use "yes" on terminate option, causing exception</purpose>
  </test>
  <test file="modes/modes01">
    <purpose>Simple test of xsl:apply-templates with mode.</purpose>
  </test>
  <test file="modes/modes02">
    <purpose>Test of moded template calling xsl:apply-templates on another template.</purpose>
  </test>
  <test file="modes/modes03">
    <purpose>Test of xsl:apply-templates with mode not found.</purpose>
  </test>
  <test file="modes/modes04">
    <purpose>Simple test of xsl:apply-templates with no mode, but with same-pattern template that has a mode available.</purpose>
  </test>
  <test file="modes/modes05">
    <purpose>Simple test of xsl:apply-templates with mode, using the default rule.</purpose>
  </test>
  <test file="modes/modes06">
    <purpose>Test of xsl:apply-templates with mode, using a qualified name.</purpose>
  </test>
  <test file="modes/modes07">
    <purpose>Test of xsl:apply-templates with mode, using a non-qualified name, but with a qualified name in scope.</purpose>
  </test>
  <test file="modes/modes08">
    <purpose>Test of several modes being available.</purpose>
  </test>
  <test file="modes/modes09">
    <purpose>Test an apply-templates that has no select but has a mode.</purpose>
    <comment>The "punct" nodes in the input will get processed under the default template, in char mode, which copies the content.</comment>
  </test>
  <test file="modes/modes10">
    <purpose>Show that we only go into a mode via apply-templates. You can't put a mode on call-template, and the fact that you call a named template that has a mode specifier doesn't mean you are in that mode.</purpose>
    <comment>The following template is both applied in mode a and called</comment>
  </test>
  <test file="namedtemplate/namedtemplate01">
    <purpose>General test for xsl:call-template.</purpose>
    <comment>Output should be 'test' and 'pvar2 default data'</comment>
  </test>
  <test file="namedtemplate/namedtemplate02">
    <purpose>Test for xsl:call-template of one that has both match and name.</purpose>
    <comment>Also verifies that xsl:call-template does not change the current node or the current node list resulting in 'top-level-a' being printed twice during the first instantiation of the named template.</comment>
  </test>
  <test file="namedtemplate/namedtemplate03">
    <purpose>Test for recursion of xsl:call-template.</purpose>
    <comment>&lt;xsl:param name="pvar2" select="'stylesheet-var'"/&gt;</comment>
  </test>
  <test file="namedtemplate/namedtemplate04">
    <purpose>Make sure qualified names work for named templates.</purpose>
  </test>
  <test file="namedtemplate/namedtemplate05">
    <purpose>Call named template with non-qualified name, but with qualified name in scope.</purpose>
  </test>
  <test file="namedtemplate/namedtemplate07">
    <purpose>Tests the ability to reset and evaluate a parameter.</purpose>
  </test>
  <test file="namedtemplate/namedtemplate08">
    <purpose>Test of nested template calls.</purpose>
    <comment>Output should not have pvarN default data</comment>
  </test>
  <test file="namedtemplate/namedtemplate09">
    <purpose>Test of nested template calls.</purpose>
  </test>
  <test file="namedtemplate/namedtemplate10">
    <purpose>Test of simulated numerically-indexed for loop.</purpose>
    <comment>This is example 77 from Nic Miloslav's tutorial site.</comment>
  </test>
  <test file="namedtemplate/namedtemplate11">
    <purpose>Test for-each inside xsl:with-param.</purpose>
  </test>
  <test file="namedtemplate/namedtemplate12">
    <purpose>Test use of passed-in value in an AVT. Derived from example code at end of 11.6</purpose>
  </test>
  <test file="namedtemplate/namedtemplate13">
    <purpose>Ensure that we can use the default parameter value on some calls</purpose>
  </test>
  <test file="namedtemplate/namedtemplate14">
    <purpose>Test select= on xsl:param inside named template</purpose>
    <comment>Output should be 'test' and 'pvar2 default data'</comment>
  </test>
  <test file="namedtemplate/err/namedtemplateerr01">
    <purpose>Test what happens with badly-formed select pattern in with-param.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr02">
    <purpose>Error test- parameter of outer template unknown inside inner template.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr03">
    <purpose>Try to do call-template without a template of the specified name.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr04">
    <purpose>Test child of call-template other than with-param.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr05">
    <purpose>Test param lacking name attribute.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr06">
    <purpose>Try to do call-template without its name attribute.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr07">
    <purpose>Test with-param lacking name attribute.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr08">
    <purpose>Put xsl:call-template at top level, which is illegal.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr09">
    <purpose>Put xsl:with-param at top level, which is illegal.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr10">
    <purpose>Put xsl:with-param in a template, which is illegal.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr11">
    <purpose>Try to use an AVT for the template name when invoking.</purpose>
  </test>
  <test file="namedtemplate/err/namedtemplateerr12">
    <purpose>Error to have a stylesheet contain more then one template with the same name and same import precedence.</purpose>
  </test>
  <test file="namespace/namespace01">
    <purpose>Apply namespaces to attributes</purpose>
  </test>
  <test file="namespace/namespace02">
    <purpose>Apply namespaces to elements. Location of declaration is allowed to vary, as long as it's in scope when needed.</purpose>
  </test>
  <test file="namespace/namespace03">
    <purpose>Adding an attribute to an element replaces any existing attribute of that element with the same expanded-name. For attribute L, there is only a local name. Attribute Q has a namespace.</purpose>
  </test>
  <test file="namespace/namespace04">
    <purpose>Test that default namespaces do not apply directly to attributes.</purpose>
  </test>
  <test file="namespace/namespace05">
    <purpose>Stylesheets are free to use any prefix, provided there is a namespace declaration that binds the prefix to the URI of XSLT namespace.</purpose>
  </test>
  <test file="namespace/namespace06">
    <purpose>Testing an attribute not from the XSLT namespace, which is legal provided that the expanded name of the attribute has a non-null namespace URI.</purpose>
  </test>
  <test file="namespace/namespace07">
    <purpose>Test of 'local-name()' function on an element.</purpose>
  </test>
  <test file="namespace/namespace09">
    <purpose>Test of 'local-name()' function on attribute in non-default namespace.</purpose>
  </test>
  <test file="namespace/namespace10">
    <purpose>Test of 'namespace-uri' function.</purpose>
  </test>
  <test file="namespace/namespace11">
    <purpose>Test of 'namespace-uri()' function, with hyphenated node name.</purpose>
  </test>
  <test file="namespace/namespace12">
    <purpose>Test of 'namespace-uri()' function on an element.</purpose>
  </test>
  <test file="namespace/namespace13">
    <purpose>Stylesheets are free to use any prefix, provided there is a namespace declaration that binds the prefix to the URI of XSLT namespace.</purpose>
  </test>
  <test file="namespace/namespace14">
    <purpose>Have more than one prefix bound to the URI of XSLT namespace.</purpose>
  </test>
  <test file="namespace/namespace15">
    <purpose>Stylesheet elements may contain any element not from the XSLT namespace, provided that the expanded name of the element has a non-null namespace URI.</purpose>
  </test>
  <test file="namespace/namespace16">
    <purpose>XSLT processor must ignore a top-level element without giving and error if it does not recognize the namespace URI. The prefix used must still resolve to a URI; but that URI may not be known.</purpose>
  </test>
  <test file="namespace/namespace17">
    <purpose>Test xsl:exclude-result-prefixes, stylesheet level</purpose>
  </test>
  <test file="namespace/namespace18">
    <purpose>Test exclude-result-prefixes, attribute level</purpose>
  </test>
  <test file="namespace/namespace19">
    <purpose>Test basic functionality of namespace-alias. Where XSL elements are created by using Literal Result Elements. namespace24 is very similar, but it creates the axsl:stylesheet element via xsl:element.</purpose>
  </test>
  <test file="namespace/namespace20">
    <purpose>Test exclude-result-prefixes.</purpose>
  </test>
  <test file="namespace/namespace21">
    <purpose>Match namespace between stylesheet, in a select, and input. Prefixes differ but the URIs are the same.</purpose>
  </test>
  <test file="namespace/namespace22">
    <purpose>Determine how namespaces are inherited down to succeeding elements. Currently this is not an atomic test. This needs more investagation.</purpose>
  </test>
  <test file="namespace/namespace23">
    <purpose>Testing an attribute not from the XSLT namespace, which is legal provided that the expanded name of the attribute has a non-null namespace URI. This tests for many xslt elements, apparent code path are different for numerous elements. Should actually output a "bogus" stylesheet.</purpose>
  </test>
  <test file="namespace/namespace24">
    <purpose>Test basic functionality of namespace-alias. Where XSL elements are created by using xsl:element command.</purpose>
  </test>
  <test file="namespace/namespace25">
    <purpose>Simple case of creating LRE with nested namespace declarations.</purpose>
  </test>
  <test file="namespace/namespace26">
    <purpose>Test of 'local-name()' with zero arguments.</purpose>
  </test>
  <test file="namespace/namespace27">
    <purpose>Test of 'namespace-uri()' with no arguments.</purpose>
  </test>
  <test file="namespace/namespace28">
    <purpose>Test of local-name on namespace axis.</purpose>
  </test>
  <test file="namespace/namespace29">
    <purpose>Test name functions on processing instructions.</purpose>
  </test>
  <test file="namespace/namespace30">
    <purpose>Test name functions on comments.</purpose>
  </test>
  <test file="namespace/namespace31">
    <purpose>Test name functions on text nodes.</purpose>
  </test>
  <test file="namespace/namespace32">
    <purpose>Test of local-name() on default namespace declaration.</purpose>
  </test>
  <test file="namespace/namespace33">
    <purpose>Test of namespace-uri() on namespaces.</purpose>
  </test>
  <test file="namespace/namespace34">
    <purpose>Test of namespace-uri() on default namespace declaration.</purpose>
    <comment>Part 4 of the Namespaces in XML spec says "The prefix xmlns is used only for namespace bindings and is not itself bound to any namespace name.</comment>
  </test>
  <test file="namespace/namespace35">
    <purpose>Get xmlns declaration attached to outermost LRE. Prefix "axsl" should also be literal.</purpose>
  </test>
  <test file="namespace/err/namespaceerr01">
    <purpose>It is an error for an element from XSLT namespace to have attributes with expanded-names that have null namespace URI's.</purpose>
  </test>
  <test file="namespace/err/namespaceerr02">
    <purpose>Test missing attribute in namespace-alias.</purpose>
  </test>
  <test file="namespace/err/namespaceerr03">
    <purpose>Test missing attribute in namespace-alias.</purpose>
  </test>
  <test file="namespace/err/namespaceerr04">
    <purpose>Testing an attribute not from the XSLT namespace, which is legal provided that the expanded name of the attribute has a non-null namespace URI. This tests for many xslt TOP-LEVEL elements, apparent code path are different for numerous elements. Should not have namespaces to inherit.</purpose>
    <comment>xsl:import href="..\test1.xsl" a="a"/</comment>
  </test>
  <test file="namespace/err/namespaceerr05">
    <purpose>Test placement of namespace-alias inside a template, which is illegal.</purpose>
  </test>
  <test file="namespace/err/namespaceerr06">
    <purpose>Test of 'local-name()' with too many arguments.</purpose>
  </test>
  <test file="namespace/err/namespaceerr07">
    <purpose>Test of 'namespace-uri()' with too many arguments.</purpose>
  </test>
  <test file="namespace/err/namespaceerr08">
    <purpose>Test of 'name()' with too many arguments.</purpose>
  </test>
  <test file="namespace/err/namespaceerr09">
    <purpose>Test for meaningful message when expression begins with : (has null namespace)</purpose>
  </test>
  <test file="namespace/err/namespaceerr10">
    <purpose>Test for meaningful message when attempting to use namespace wildcard (*)</purpose>
  </test>
  <test file="node/node01">
    <purpose>Test for text() node test.</purpose>
    <comment>Should say "test"</comment>
  </test>
  <test file="node/node02">
    <purpose>Test for comment() node test.</purpose>
  </test>
  <test file="node/node03">
    <purpose>Test for processing-instruction() node test.</purpose>
    <comment>should say "Found-pi,,Found-pi"</comment>
  </test>
  <test file="node/node04">
    <purpose>Test of 'local-name()'</purpose>
  </test>
  <test file="node/node05">
    <purpose>Test of 'namespace-uri()'</purpose>
  </test>
  <test file="node/node06">
    <purpose>Test of 'name()', without arguments</purpose>
  </test>
  <test file="node/node07">
    <purpose>Processing Instructions and comments within a stylesheet are ignored.</purpose>
    <comment>This is the named template that is called from above</comment>
  </test>
  <test file="node/node08">
    <purpose>String value of the root node is the concatenation of the string values of all text node descendants of the root node in document order.</purpose>
  </test>
  <test file="node/node09">
    <purpose>Test for value-of with comment() node test.</purpose>
  </test>
  <test file="node/node10">
    <purpose>Test for value-of with processing-instruction() node test.</purpose>
  </test>
  <test file="node/node11">
    <purpose>Test for node tests in match patterns (and union in select).</purpose>
  </test>
  <test file="node/node12">
    <purpose>Test for node tests in select in for-each.</purpose>
  </test>
  <test file="node/node13">
    <purpose>Test for access to comments hanging off the root.</purpose>
  </test>
  <test file="node/node14">
    <purpose>Test for access to PIs hanging off the root.</purpose>
  </test>
  <test file="node/node15">
    <purpose>Test for node() in match patterns. Default axis is child.</purpose>
  </test>
  <test file="node/node16">
    <purpose>Test for 'attribute::*' in match pattern.</purpose>
  </test>
  <test file="node/node17">
    <purpose>Test that 'namespace::node()' selects all namespaces.</purpose>
  </test>
  <test file="numberformat/numberformat01">
    <purpose>Test of format-number with 2 arguments, showing zeroes.</purpose>
  </test>
  <test file="numberformat/numberformat02">
    <purpose>Test of format-number and # and 0 in format string.</purpose>
  </test>
  <test file="numberformat/numberformat03">
    <purpose>Test of format-number on a negative number.</purpose>
  </test>
  <test file="numberformat/numberformat04">
    <purpose>Test of format-number on a negative number; should choose second pattern.</purpose>
  </test>
  <test file="numberformat/numberformat05">
    <purpose>Test of format-number percentage format.</purpose>
  </test>
  <test file="numberformat/numberformat06">
    <purpose>Test of format-number per-mille format.</purpose>
  </test>
  <test file="numberformat/numberformat07">
    <purpose>Test of format-number currency symbol, which is not supposed to be there.</purpose>
  </test>
  <test file="numberformat/numberformat08">
    <purpose>Test of format-number with prefix and suffix in format string.</purpose>
  </test>
  <test file="numberformat/numberformat09">
    <purpose>Test default decimal-format on separator characters, changing both.</purpose>
  </test>
  <test file="numberformat/numberformat11">
    <purpose>Test default decimal-format on pattern-only characters, positive number.</purpose>
  </test>
  <test file="numberformat/numberformat12">
    <purpose>Test default decimal-format on pattern-only characters, negative number.</purpose>
  </test>
  <test file="numberformat/numberformat13">
    <purpose>Test default decimal-format on pattern-only characters, negative number and one pattern.</purpose>
  </test>
  <test file="numberformat/numberformat14">
    <purpose>Test specified result pattern for infinity.</purpose>
  </test>
  <test file="numberformat/numberformat15">
    <purpose>Test specified result pattern for not-a-number.</purpose>
  </test>
  <test file="numberformat/numberformat16">
    <purpose>Test of decimal-format per-mille format with character being changed.</purpose>
  </test>
  <test file="numberformat/numberformat17">
    <purpose>Test decimal-format output character for negative, 2 patterns.</purpose>
  </test>
  <test file="numberformat/numberformat18">
    <purpose>Test decimal-format output character for negative, one pattern.</purpose>
  </test>
  <test file="numberformat/numberformat19">
    <purpose>Test decimal-format declaration with a name.</purpose>
  </test>
  <test file="numberformat/numberformat20">
    <purpose>Test of decimal-format with qualified name. Unqualified name provided as a trap.</purpose>
  </test>
  <test file="numberformat/numberformat21">
    <purpose>Test include of a decimal-format.</purpose>
  </test>
  <test file="numberformat/numberformat22">
    <purpose>Test import of a decimal-format. Three formats should not conflict.</purpose>
  </test>
  <test file="numberformat/numberformat23">
    <purpose>Test of include that does an import, providing two named decimal-formats. Three formats should not conflict.</purpose>
  </test>
  <test file="numberformat/numberformat24">
    <purpose>Test of import that does an import, providing two named decimal-formats. Three formats should not conflict.</purpose>
  </test>
  <test file="numberformat/numberformat25">
    <purpose>Create a conflict in the use of the '.' character.</purpose>
  </test>
  <test file="numberformat/numberformat26">
    <purpose>Designate a space as the grouping separator.</purpose>
  </test>
  <test file="numberformat/numberformat27">
    <purpose>Test of format-number minus-sign behavior on positive numbers.</purpose>
  </test>
  <test file="numberformat/numberformat28">
    <purpose>Test what happens to minus sign embedded in second pattern.</purpose>
  </test>
  <test file="numberformat/numberformat29">
    <purpose>Test decimal-format output character does not influence input.</purpose>
  </test>
  <test file="numberformat/numberformat30">
    <purpose>Test effects of minus-sign in one pattern.</purpose>
  </test>
  <test file="numberformat/numberformat31">
    <purpose>Test output of altered minus, 2 patterns but no sign marker in pattern.</purpose>
  </test>
  <test file="numberformat/numberformat32">
    <purpose>Test of format-number percent format with character being changed.</purpose>
  </test>
  <test file="numberformat/numberformat34">
    <purpose>Test changing both digit and zero-digit in format string.</purpose>
  </test>
  <test file="numberformat/numberformat35">
    <purpose>Test of unequal spacing of grouping-separator.</purpose>
  </test>
  <test file="numberformat/numberformat36">
    <purpose>Test what happens when we overflow available digits on the left.</purpose>
  </test>
  <test file="numberformat/numberformat37">
    <purpose>Test result pattern for infinity, unchanged.</purpose>
  </test>
  <test file="numberformat/numberformat38">
    <purpose>Test result pattern for not-a-number, unchanged.</purpose>
  </test>
  <test file="numberformat/numberformat39">
    <purpose>Test result pattern for negative infinity, unchanged.</purpose>
  </test>
  <test file="numberformat/numberformat40">
    <purpose>Test specification of result pattern for infinity when quantity to be displayed is negative infinity.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr01">
    <purpose>Test repeat declaration of decimal-format, un-named.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr02">
    <purpose>Test repeat declaration of decimal-format, named the same.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr03">
    <purpose>Attempt to put a child on decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr04">
    <purpose>Test illegal attribute on decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr05">
    <purpose>Set one-character attribute grouping-separator too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr06">
    <purpose>Show what happens if there are any filler digits (#) between zero-digits and the decimal-separator on the left.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr07">
    <purpose>Show what happens if there are any filler digits (#) between zero-digits and the decimal-separator on the right.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr08">
    <purpose>Show what happens if there are any filler digits (#) between zero-digits and the decimal-separator. Change both characters.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr09">
    <purpose>Test of two occurrences of the decimal-separator.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr10">
    <purpose>Test of grouping-separator after the decimal-separator.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr11">
    <purpose>Set one-character attribute decimal-separator too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr12">
    <purpose>Set one-character attribute percent too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr13">
    <purpose>Set one-character attribute per-mille too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr14">
    <purpose>Set one-character attribute zero-digit too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr15">
    <purpose>Set one-character attribute digit too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr16">
    <purpose>Set one-character attribute pattern-separator too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr17">
    <purpose>Set one-character attribute minus-sign too large in decimal-format.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr18">
    <purpose>Show what happens if there are any literal characters between two groups of filler digits (#).</purpose>
  </test>
  <test file="numberformat/err/numberformaterr19">
    <purpose>Show what happens if there are any literal characters between two groups of zero digits.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr20">
    <purpose>Put grouping separator adjacent to decimal-separator.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr21">
    <purpose>Put grouping separator adjacent to percent.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr22">
    <purpose>Put grouping separator adjacent to per-mille character.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr23">
    <purpose>Put grouping separator adjacent to pattern-separator.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr24">
    <purpose>Test of percent in middle of format string.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr25">
    <purpose>Test of per-mille in middle of format string.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr26">
    <purpose>Test of more than two patterns.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr27">
    <purpose>Test of both percent and per-mille in format string.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr28">
    <purpose>Test of format-number with too few arguments.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr29">
    <purpose>Test of format-number with too many arguments.</purpose>
  </test>
  <test file="numberformat/err/numberformaterr30">
    <purpose>Test placement of decimal-format inside atemplate, which is illegal.</purpose>
  </test>
  <test file="numbering/numbering01">
    <purpose>Test of numbering of multi-level document with no attributes specified.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="DocFrag" place="id(number)"</comment>
  </test>
  <test file="numbering/numbering02">
    <purpose>Test of simple numbering, no attributes specified.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="DocFrag" place="id(number)"</comment>
  </test>
  <test file="numbering/numbering03">
    <purpose>Test of level (multiple), count, format attributes.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering04">
    <purpose>Test of level (any) and from attributes.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering05">
    <purpose>Test of level (any) and nested from/count.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering06">
    <purpose>Test level=single specified explicitly</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering07">
    <purpose>Simple test of non-alphanumeric separator</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering08">
    <purpose>Test of leading zeroes in numbering. Last separator propagates.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering09">
    <purpose>Test of value attribute.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/p[1]/text()[3]"</comment>
  </test>
  <test file="numbering/numbering10">
    <purpose>Test of format attributes that vary per level.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering11">
    <purpose>Test of grouping attributes.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering12">
    <purpose>Test of alphabetic "numbering" sequence.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering13">
    <purpose>Test of roman-numeral "numbering" sequence.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering14">
    <purpose>Test of greek-numeral "alphabetic" sequence.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering15">
    <purpose>Test of greek-numeral "traditional" sequence.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering16">
    <purpose>Test of unrecognized alphabetic format code; should just give digits.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering17">
    <purpose>Test of proper formation of Roman numerals.</purpose>
    <comment>SpecCitation: Rec="XSLT" VersionDrop="1.1"</comment>
  </test>
  <test file="numbering/numbering18">
    <purpose>Test of node numbering before and after the nodes specified in from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering19">
    <purpose>Test of node numbering before and after the nodes specified in from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering20">
    <purpose>Test of node numbering before and after the nodes specified in from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering21">
    <purpose>Test of level (any) and counting only some nodes.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering22">
    <purpose>Test of level (single) and counting only some nodes.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering23">
    <purpose>Test of value attribute with popular "of n" format.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering24">
    <purpose>Number without value= inside sorted for-each.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering25">
    <purpose>Number without value= inside template called within sorted for-each.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering26">
    <purpose>Numbering comes from sorted order if value attribute used.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering27">
    <purpose>Test of numbering of multi-level document, level=multiple and default from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering28">
    <purpose>Test of numbering of multi-level document, level=single and default from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering29">
    <purpose>Test of numbering of multi-level document, level=any and default from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering30">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering31">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering32">
    <purpose>Test xsl:number formatting separators, propagating last one, watching for confusion with default (.) separator.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering33">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering34">
    <purpose>Test xsl:number formatting separators, propagating last one, with default (.) elsewhere in format.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering35">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering36">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering37">
    <purpose>Test xsl:number formatting separators, with extra characters that look the same.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering38">
    <purpose>Test xsl:number formatting separators, with extra characters that look the same.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering39">
    <purpose>Test xsl:number formatting separators, propagating last one, with extra characters that look the same.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering40">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering41">
    <purpose>Test xsl:number formatting separators, propagating last one (which is the last one between).</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering42">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering43">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering44">
    <purpose>Test xsl:number formatting separators, propagating last one.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering45">
    <purpose>Test more than one xsl:number counter active at the same time.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering46">
    <purpose>Test xsl:number formatting separators, with multiple characters in between numbering tokens.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering47">
    <purpose>Establish that the default for level is single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering48">
    <purpose>Count only top-level changes but number all the way down, level=single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering49">
    <purpose>Count only bottom-level changes but number all the way down, level=any.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering50">
    <purpose>Allow level to default to single and count top-level items all the way down.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering51">
    <purpose>Test xsl:number with from and count defaulted but level=any.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering52">
    <purpose>Test xsl:number with a filtered count pattern, from defaulted, level=single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering53">
    <purpose>Test xsl:number with from and count defaulted, level=single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering54">
    <purpose>Test xsl:number with from and count defaulted, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering55">
    <purpose>Test xsl:number with count on same level, from defaulted, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering56">
    <purpose>Test xsl:number with count from higher level, from defaulted, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering57">
    <purpose>Test xsl:number with count specifying same and higher level, from defaulted, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering58">
    <purpose>Test xsl:number with a filtered count pattern, from defaulted, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering59">
    <purpose>Test of level (any) and counting only some nodes, with from defaulted.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering60">
    <purpose>Test of level (any) and counting only some nodes, from specifies next-higher level.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering61">
    <purpose>Test of numbering of multi-level document, level=any, from specifies middle level.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering62">
    <purpose>Count one level of changes and number below there, level=single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering63">
    <purpose>Count all levels of changes and number by level, level=single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering64">
    <purpose>Test xsl:number with count on same level, from is next higher level, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering65">
    <purpose>Test of numbering of multi-level document with specified from level, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering66">
    <purpose>Test of numbering of multi-level document with specified from level, count filtered.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering67">
    <purpose>Test xsl:number with with from set for two levels, level=any, count defaulted.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering68">
    <purpose>Test xsl:number with from set for two levels, level=any.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering69">
    <purpose>Test xsl:number with from set for two levels, level=any, counting two levels.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering70">
    <purpose>Test of level (any) and counting only some nodes, from specifies two higher levels.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering71">
    <purpose>Test of level (single) and counting only some nodes, from specifies two higher levels.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering72">
    <purpose>Test of level (single), from specifies two higher levels, count defaulted.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering73">
    <purpose>Test of level (single), from specifies two higher levels.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering74">
    <purpose>Test of level (single) and counting two types of nodes, from specifies two higher levels.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering75">
    <purpose>Test xsl:number with level=multiple, from specifies two levels.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering76">
    <purpose>Test xsl:number with count on same level, from is two higher levels, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering77">
    <purpose>Test of numbering of multi-level document with two from levels, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering78">
    <purpose>Test of numbering of multi-level document with two from levels and filtering the lowest count level.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering79">
    <purpose>Test of non-numeric assignment to value attribute.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/p[1]/text()[5]"</comment>
  </test>
  <test file="numbering/numbering80">
    <purpose>Test of grouping attributes. If only one of the two is present, it is ignored.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering81">
    <purpose>Test of grouping attributes. If only one of the two is present, it is ignored.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[6]"</comment>
  </test>
  <test file="numbering/numbering82">
    <purpose>Count non-existant nodes, level=single.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[1]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering83">
    <purpose>Count non-existant nodes, level=any.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[3]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/numbering84">
    <purpose>Count non-existant nodes, level=multiple.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[2]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr01">
    <purpose>Test of excessive size of grouping-separator.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(convert)/p[6]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr02">
    <purpose>Test of bad value for level attribute.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[1]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr03">
    <purpose>Test of bad specification for letter-value.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(convert)/p[5]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr04">
    <purpose>Test invalid path specified in from.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[3]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr05">
    <purpose>Test invalid path specified in count.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(number)/ulist[1]/item[2]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr06">
    <purpose>Test of attempt to express negative numbers in Roman numerals.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(convert)/ulist[1]/item[5]/p[1]/text()[1]"</comment>
  </test>
  <test file="numbering/err/numberingerr07">
    <purpose>Put xsl:number at top level, which is illegal.</purpose>
    <comment>SpecCitation: Rec="XSLT" Version="1.0" type="OASISptr1" place="id(stylesheet-element)/p[3]/text()[1]"</comment>
  </test>
  <test file="output/output01">
    <purpose>Test for SCRIPT handling</purpose>
  </test>
  <test file="output/output02">
    <purpose>Test for STYLE handling</purpose>
  </test>
  <test file="output/output03">
    <purpose>Test for disabling output escaping in xsl:text</purpose>
  </test>
  <test file="output/output04">
    <purpose>Test for numbered character entities</purpose>
  </test>
  <test file="output/output05">
    <purpose>Test for extra space around the img tag</purpose>
  </test>
  <test file="output/output06">
    <purpose>Test for disabling output escaping in xsl:value-of</purpose>
  </test>
  <test file="output/output07">
    <purpose>Test for enabling output escaping in xsl:value-of, XML output</purpose>
  </test>
  <test file="output/output08">
    <purpose>Test for enabling output escaping in xsl:text, HTML output</purpose>
  </test>
  <test file="output/output09">
    <purpose>Test for disabling output escaping in a variable with xsl:text, HTML output</purpose>
  </test>
  <test file="output/output10">
    <purpose>test for disabling output escaping in a variable with xsl:value-of</purpose>
  </test>
  <test file="output/output11">
    <purpose>Test for the xml output method by itself</purpose>
  </test>
  <test file="output/output12">
    <purpose>Test for the xml output method by itself with omit-xml-declaration</purpose>
  </test>
  <test file="output/output13">
    <purpose>Test for doctype-system</purpose>
  </test>
  <test file="output/output14">
    <purpose>Test for doctype-public only</purpose>
  </test>
  <test file="output/output15">
    <purpose>Test for doctype-system and doctype-public</purpose>
  </test>
  <test file="output/output16">
    <purpose>Test for doctype-system with html method</purpose>
  </test>
  <test file="output/output17">
    <purpose>Test for doctype-public only with html method</purpose>
  </test>
  <test file="output/output18">
    <purpose>Test for doctype-system and doctype-public with html method</purpose>
  </test>
  <test file="output/output19">
    <purpose>Test US-ASCII encoding.</purpose>
  </test>
  <test file="output/output20">
    <purpose>Test SHIFT_JIS encoding.</purpose>
  </test>
  <test file="output/output21">
    <purpose>Test BIG5 encoding.</purpose>
  </test>
  <test file="output/output22">
    <purpose>Test EBCDIC-CP-IT encoding.</purpose>
  </test>
  <test file="output/output23">
    <purpose>Test ISO-2022-JP encoding.</purpose>
  </test>
  <test file="output/output24">
    <purpose>Escape of non-ASCII chars in URI attribute values using method cited in Section B.2.1 of HTML 4.0 Spec. This test is a duplicate of OUTP31, except that the output is XML.</purpose>
  </test>
  <test file="output/output25">
    <purpose>???</purpose>
  </test>
  <test file="output/output26">
    <purpose>Text output of characters encoded between 128 and 255</purpose>
  </test>
  <test file="output/output27">
    <purpose>Test of simple output, HTML with xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"</purpose>
  </test>
  <test file="output/output28">
    <purpose>Result tree here defaults to XML Test for cdata-section-elements with nonrepresentable character.</purpose>
  </test>
  <test file="output/output29">
    <purpose>Test cdata-section-elements.</purpose>
  </test>
  <test file="output/output30">
    <purpose>Test cdata-section-elements that looks like end of CDATA.</purpose>
  </test>
  <test file="output/output31">
    <purpose>ESC of non-ASCII chars in URI attribute values using method cited in Section B.2.1 of HTML 4.0 Spec.</purpose>
  </test>
  <test file="output/output32">
    <purpose>ESC of non-ASCII chars in URI attribute values using method sited in Section B.2.1 of HTML 4.0 Spec.</purpose>
    <comment>test for SCRIPT handling</comment>
  </test>
  <test file="output/output33">
    <purpose>html output method should not output an end-tag for empty elements.</purpose>
  </test>
  <test file="output/output34">
    <purpose>Names of HTML elements should be recognized regardless of case.</purpose>
  </test>
  <test file="output/output35">
    <purpose>Boolean attributes should be output in minimized form.</purpose>
  </test>
  <test file="output/output36">
    <purpose>Processing instructions should be terminated with "&gt;".</purpose>
  </test>
  <test file="output/output37">
    <purpose>"&amp;" should not be escaped when occuring in an attribute value immediately followed by a "{". See to Section B.7.1 HTML 4.0 Recommendation.</purpose>
  </test>
  <test file="output/output38">
    <purpose>Meta should be added immediately after after the start-tag of the HEAD element specifying the character encoding actually used.</purpose>
  </test>
  <test file="output/output39">
    <purpose>Test of indent</purpose>
  </test>
  <test file="output/output40">
    <purpose>Test of indent</purpose>
  </test>
  <test file="output/output41">
    <purpose>Text node containing "]]&gt;" and closure of CDATA section.</purpose>
  </test>
  <test file="output/output42">
    <purpose>Test of cdata-section-elements processing.</purpose>
  </test>
  <test file="output/output43">
    <purpose>Test of cdata-section-elements processing. &lt;example&gt; should not be processed.</purpose>
  </test>
  <test file="output/output44">
    <purpose>xml method should output XML declaration.</purpose>
  </test>
  <test file="output/output45">
    <purpose>xml method should not output XML declaration if omit-xml-declaration="yes".</purpose>
  </test>
  <test file="output/output46">
    <purpose>All xsl:output elements are merged into a single element. cdata-section-elements will contain the union of the specified values. It is an error if there is more than one such value for an attribute. The processor may signal an error; or recover by using the value that occurs last in the stylesheet. Both example and test should be wrapped by CDATA, and the output should be HTML.</purpose>
  </test>
  <test file="output/output47">
    <purpose>Illegal use of disable-output-escaping.</purpose>
  </test>
  <test file="output/output48">
    <purpose>... html output method should output a DTD immediately before the first element.</purpose>
  </test>
  <test file="output/output49">
    <purpose>HTML output method should not escape '&lt;' in attribute values.</purpose>
  </test>
  <test file="output/output50">
    <purpose>Valid use of disable-output-escaping.</purpose>
  </test>
  <test file="output/output51">
    <purpose>Test of indent attribute by itself.</purpose>
  </test>
  <test file="output/output52">
    <purpose>html output method should not output white space after the image tag within the anchor tag.</purpose>
  </test>
  <test file="output/output53">
    <purpose>Basic test for creating a comment.</purpose>
  </test>
  <test file="output/output54">
    <purpose>Test for creating a comment using a formula.</purpose>
  </test>
  <test file="output/output55">
    <purpose>Test creating a comment from a path expression.</purpose>
  </test>
  <test file="output/output56">
    <purpose>Test creating a comment from a variable.</purpose>
  </test>
  <test file="output/output57">
    <purpose>Test use of xsl:if and xsl:text inside xsl:comment.</purpose>
  </test>
  <test file="output/output58">
    <purpose>Test creation of a top-level comment.</purpose>
  </test>
  <test file="output/output59">
    <purpose>Test creation of a top-level processing-instruction before the document element.</purpose>
  </test>
  <test file="output/output60">
    <purpose>Do everything inside an HTML element. Note first item in this file.</purpose>
  </test>
  <test file="output/output61">
    <purpose>Test for disabling output escaping in xsl:value-of on ., which has special code. XML method.</purpose>
  </test>
  <test file="output/output62">
    <purpose>Test for disabling output escaping in xsl:value-of on ., which has special code. HTML method.</purpose>
  </test>
  <test file="output/output63">
    <purpose>The html output method should not output an element differently from the xml output method unless the expanded-name of the element has a null namespace URI; an element whose expanded-name has a non-null namespace URI should be output as XML. So the html tags &lt;p&gt;, &lt;hr&gt; and &lt;br&gt; in this case, due to the default html namespace will be output as xml not html.</purpose>
  </test>
  <test file="output/output64">
    <purpose>Generate output tagged for WML</purpose>
  </test>
  <test file="output/output65">
    <purpose>Test for special case for XHTML</purpose>
  </test>
  <test file="output/output66">
    <purpose>Verify standalone attribute set to "no".</purpose>
  </test>
  <test file="output/output67">
    <purpose>Verify standalone attribute set to "yes".</purpose>
  </test>
  <test file="output/output68">
    <purpose>Test for-each inside xsl:comment.</purpose>
  </test>
  <test file="output/output69">
    <purpose>Test for-each inside xsl:processing-instruction.</purpose>
  </test>
  <test file="output/output70">
    <purpose>Quotes and apostrophes can be used inside themselves, without terminating the string, if entered as entities.</purpose>
  </test>
  <test file="output/output71">
    <purpose>Test that implied HTML output assumes indent=yes.</purpose>
  </test>
  <test file="output/output72">
    <purpose>Test the generation of Processing instructions.</purpose>
  </test>
  <test file="output/output73">
    <purpose>Test SHIFT_JIS encoding on HTML output.</purpose>
  </test>
  <test file="output/output74">
    <purpose>Spec states:It is an error for output escaping to be disabled for a text node that is used for something other than a text node in the result tree. Thus, it is an error to disable output escaping for an xsl:value-of or xsl:text element that is used to generate the string-value of a comment, processing instruction or attribute node;. OUTPUT = HTML</purpose>
  </test>
  <test file="output/output75">
    <purpose>Spec states:It is an error for output escaping to be disabled for a text node that is used for something other than a text node in the result tree. Thus, it is an error to disable output escaping for an xsl:value-of or xsl:text element that is used to generate the string-value of a comment, processing instruction or attribute node; OUTPUT = XML</purpose>
  </test>
  <test file="output/output76">
    <purpose>Test for text output with special characters.</purpose>
  </test>
  <test file="output/output77">
    <purpose>Test of ficticous encoding. This is generating an Illegal argument exception, with other known encodings such as "ISO-8859-11" too</purpose>
  </test>
  <test file="output/output80">
    <purpose>Test UTF-16 encoding.</purpose>
  </test>
  <test file="output/err/outputerr01">
    <purpose>Test error reporting for missing required select attribute.</purpose>
  </test>
  <test file="output/err/outputerr02">
    <purpose>Try to create processing instruction without a name.</purpose>
  </test>
  <test file="output/err/outputerr03">
    <purpose>Try to create processing instruction with "xml" as name.</purpose>
  </test>
  <test file="output/err/outputerr04">
    <purpose>Try to create processing instruction with an improper name.</purpose>
  </test>
  <test file="output/err/outputerr05">
    <purpose>Put processing-instruction at top level, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr06">
    <purpose>Test for bad child in xsl:text</purpose>
  </test>
  <test file="output/err/outputerr07">
    <purpose>Put attribute at top level, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr08">
    <purpose>Put comment at top level, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr09">
    <purpose>Put element at top level, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr10">
    <purpose>Put xsl:text at top level, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr11">
    <purpose>Put value-of at top level, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr12">
    <purpose>Test placement of xsl:output inside atemplate, which is illegal.</purpose>
  </test>
  <test file="output/err/outputerr13">
    <purpose>Processing instruction content can't create nodes other then text nodes.</purpose>
  </test>
  <test file="output/err/outputerr14">
    <purpose>Attempt text output of characters above 127 when encoding doesn't support them.</purpose>
    <comment>"If the result tree contains a character that cannot be represented in the encoding that the XSLT processor is using for output, the XSLT processor should signal an error."</comment>
  </test>
  <test file="position/position01">
    <purpose>Test of position() function in value-of select. Look for 1.</purpose>
  </test>
  <test file="position/position02">
    <purpose>Test of position() function in predicate on wildcard. Look for last item.</purpose>
  </test>
  <test file="position/position03">
    <purpose>Test of position() function anded with attribute test.</purpose>
  </test>
  <test file="position/position04">
    <purpose>Test of position() in 2nd predicate.</purpose>
  </test>
  <test file="position/position05">
    <purpose>Test of position() predicate on node-set from key(). Look for item 4.</purpose>
  </test>
  <test file="position/position06">
    <purpose>Test of count() on wildcard.</purpose>
  </test>
  <test file="position/position07">
    <purpose>Test of last() in predicate, all spelled out.</purpose>
  </test>
  <test file="position/position08">
    <purpose>Test of position() in match pattern. Used in predicate of name. Look for 1, last, others.</purpose>
  </test>
  <test file="position/position09">
    <purpose>Test of position in match pattern predicates, both long and short versions.</purpose>
    <comment>Override default template matching, otherwise the values 10, 11, 12 will be displayed</comment>
  </test>
  <test file="position/position10">
    <purpose>Test of position() function and sorting.</purpose>
  </test>
  <test file="position/position11">
    <purpose>Test of position() and last() in xsl:if test.</purpose>
  </test>
  <test file="position/position12">
    <purpose>Test of position() function in value-of select.</purpose>
  </test>
  <test file="position/position13">
    <purpose>Test of last() function in value-of select.</purpose>
  </test>
  <test file="position/position14">
    <purpose>Test of last() function in a numeric equality.</purpose>
  </test>
  <test file="position/position15">
    <purpose>Test of position() function in predicate. Look for last item.</purpose>
  </test>
  <test file="position/position16">
    <purpose>Test of position() function in a predicate. Look for item 3.</purpose>
  </test>
  <test file="position/position17">
    <purpose>Test of position() function in a predicate. Look for first.</purpose>
  </test>
  <test file="position/position18">
    <purpose>Test of position() function and a variable in a predicate.</purpose>
  </test>
  <test file="position/position19">
    <purpose>Test of positional indexing (shorthand) in select. Look for last item.</purpose>
  </test>
  <test file="position/position20">
    <purpose>Test of shorthand positional indexing. Look for middle item.</purpose>
  </test>
  <test file="position/position21">
    <purpose>Test of shorthand positional indexing. Look for first.</purpose>
  </test>
  <test file="position/position22">
    <purpose>Test of positional indexing on the text() nodes. Look for first.</purpose>
  </test>
  <test file="position/position23">
    <purpose>Test of positional indexing on the text() nodes. Look for middle item.</purpose>
  </test>
  <test file="position/position24">
    <purpose>Test of last() function with current context position.</purpose>
  </test>
  <test file="position/position25">
    <purpose>Test of position() function in predicate of wildcard. Look for middle item.</purpose>
  </test>
  <test file="position/position26">
    <purpose>Test of position() function on predicate of wildcard. Look for first.</purpose>
  </test>
  <test file="position/position27">
    <purpose>Test of positional capabilities with choose.</purpose>
  </test>
  <test file="position/position28">
    <purpose>Test of shorthand positional indexing with wildcard. Look for last item.</purpose>
  </test>
  <test file="position/position29">
    <purpose>Test of positional indexing with wildcard. Look for middle item.</purpose>
  </test>
  <test file="position/position30">
    <purpose>Test of shorthand positional indexing with wildcard. Look for first.</purpose>
  </test>
  <test file="position/position31">
    <purpose>Test of position() with a sibling axis.</purpose>
  </test>
  <test file="position/position32">
    <purpose>Test of position() on predicate of wildcard, anded with attribute test.</purpose>
  </test>
  <test file="position/position33">
    <purpose>Test of position() on predicate of wildcard, anded with attribute test. Look for first.</purpose>
  </test>
  <test file="position/position34">
    <purpose>Test of position() on predicate of wildcard, anded with attribute test.</purpose>
  </test>
  <test file="position/position35">
    <purpose>Test of position() in 2nd predicate.</purpose>
  </test>
  <test file="position/position36">
    <purpose>Test of position() in 2nd predicate. Look for first.</purpose>
  </test>
  <test file="position/position37">
    <purpose>Test of position() in a for-each node set.</purpose>
  </test>
  <test file="position/position38">
    <purpose>Test of positional indexing (shorthand) in 2nd predicate. Look for last item.</purpose>
  </test>
  <test file="position/position39">
    <purpose>Test of shorthand positional indexing in 2nd predicate.</purpose>
  </test>
  <test file="position/position40">
    <purpose>Test of positional indexing in 2nd predicate. Look for first.</purpose>
  </test>
  <test file="position/position41">
    <purpose>Test of position() in a for-each node set involving parent axis.</purpose>
  </test>
  <test file="position/position42">
    <purpose>Test of position() on node-set from key().</purpose>
  </test>
  <test file="position/position43">
    <purpose>Test of position() on node-set from key(). Look for first.</purpose>
  </test>
  <test file="position/position44">
    <purpose>Test of position() on node-set from key(). Look for first.</purpose>
  </test>
  <test file="position/position45">
    <purpose>Test of shorthand positional indexing on node-set from key().</purpose>
  </test>
  <test file="position/position46">
    <purpose>Test of shorthand positional indexing on node-set from key().</purpose>
  </test>
  <test file="position/position47">
    <purpose>Test of shorthand positional indexing on node-set from key(). Look for first.</purpose>
  </test>
  <test file="position/position48">
    <purpose>Test position predicate on sort key.</purpose>
  </test>
  <test file="position/position49">
    <purpose>Test of positional indexing when used with key() in xsl:apply-templates. Look for last.</purpose>
  </test>
  <test file="position/position50">
    <purpose>Test of position() when used with key() in xsl:apply-templates.</purpose>
  </test>
  <test file="position/position51">
    <purpose>Test of position() when used with key() in xsl:apply-templates. Look for first.</purpose>
  </test>
  <test file="position/position52">
    <purpose>Test of count() on a set filtered by position.</purpose>
  </test>
  <test file="position/position53">
    <purpose>Test of count() with attribute wildcard.</purpose>
  </test>
  <test file="position/position54">
    <purpose>Test of count() of wildcarded attribute axis, long-form notation.</purpose>
  </test>
  <test file="position/position55">
    <purpose>Test of last() by itself in a predicate.</purpose>
  </test>
  <test file="position/position56">
    <purpose>Test of last() with node-set from key(). Long-form predicate.</purpose>
  </test>
  <test file="position/position57">
    <purpose>Test of last() in predicate of node-set from key().</purpose>
  </test>
  <test file="position/position58">
    <purpose>Test of last() in second predicate, in long form.</purpose>
  </test>
  <test file="position/position59">
    <purpose>Test of last() in second predicate.</purpose>
  </test>
  <test file="position/position60">
    <purpose>Test of greater-than with position().</purpose>
  </test>
  <test file="position/position61">
    <purpose>Test of less-than with position().</purpose>
  </test>
  <test file="position/position62">
    <purpose>Test of greater-than-or-equal-to with position().</purpose>
  </test>
  <test file="position/position63">
    <purpose>Test of less-than-or-equal-to with position().</purpose>
  </test>
  <test file="position/position64">
    <purpose>Test of not-equal-to with position().</purpose>
  </test>
  <test file="position/position65">
    <purpose>Test of a numeric formula in positional indexing.</purpose>
  </test>
  <test file="position/position66">
    <purpose>Test of zero in positional indexing.</purpose>
  </test>
  <test file="position/position67">
    <purpose>Test of number function to make positional indexing definite.</purpose>
  </test>
  <test file="position/position68">
    <purpose>Test positional indexing with for-each loop and all-but-last xsl:if for comma.</purpose>
  </test>
  <test file="position/position69">
    <purpose>Test positional indexing with for-each loop and apply-templates.</purpose>
  </test>
  <test file="position/position70">
    <purpose>Test that set of nodes changes when strip-space is in effect.</purpose>
    <comment>"The xsl:apply-templates instruction processes all children of the current node, including text nodes. However, text nodes that have been stripped as specified in 3.4 Whitespace Stripping will not be processed."</comment>
  </test>
  <test file="position/position71">
    <purpose>Test that position test can be applied to PI nodes.</purpose>
  </test>
  <test file="position/position72">
    <purpose>Test of position() and the ancestor-or-self axis.</purpose>
  </test>
  <test file="position/position73">
    <purpose>Test of position() and for-each resetting the frame of reference of a node-set.</purpose>
  </test>
  <test file="position/position74">
    <purpose>Test of position() and for-each resetting the frame of reference of a node-set. Show position via value-of before going into for-each loop.</purpose>
  </test>
  <test file="position/position75">
    <purpose>Test of last() on various sets of children.</purpose>
  </test>
  <test file="position/position76">
    <purpose>Test of position() with namespace axis.</purpose>
    <comment>The XML parser has freedom to present namespaces in any order it wants. Nevertheless, the position() function should work on this axis, not raise an error. The input should have only one namespace if you want consistent results across parsers.</comment>
  </test>
  <test file="position/position77">
    <purpose>Test positional indexing in current node list passed via apply-templates with select that has predicate.</purpose>
  </test>
  <test file="position/err/positionerr01">
    <purpose>Last should not have any arguments.</purpose>
  </test>
  <test file="position/err/positionerr02">
    <purpose>position() should not have any arguments.</purpose>
  </test>
  <test file="position/err/positionerr03">
    <purpose>Test too few arguments to count().</purpose>
  </test>
  <test file="position/err/positionerr04">
    <purpose>Test too many arguments to count().</purpose>
  </test>
  <test file="position/err/positionerr05">
    <purpose>last() should not have any arguments.</purpose>
  </test>
  <test file="predicate/predicate01">
    <purpose>Test of implied conversion to boolean.</purpose>
  </test>
  <test file="predicate/predicate02">
    <purpose>Test of implied conversion to boolean.</purpose>
  </test>
  <test file="predicate/predicate03">
    <purpose>Test of implied conversion of node-set to boolean.</purpose>
  </test>
  <test file="predicate/predicate04">
    <purpose>Test of implied conversion to number.</purpose>
  </test>
  <test file="predicate/predicate05">
    <purpose>Test of implied conversion of node-set to number.</purpose>
  </test>
  <test file="predicate/predicate06">
    <purpose>Test of implied conversion of node-set to string.</purpose>
  </test>
  <test file="predicate/predicate07">
    <purpose>Test of implied conversion to number for an inequality test.</purpose>
  </test>
  <test file="predicate/predicate08">
    <purpose>Test of implied conversion to number for an inequality test.</purpose>
  </test>
  <test file="predicate/predicate09">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate10">
    <purpose>Test of association of inequality symbols.</purpose>
  </test>
  <test file="predicate/predicate11">
    <purpose>Test of comparison of 2 node-sets.</purpose>
  </test>
  <test file="predicate/predicate12">
    <purpose>Test of boolean or.</purpose>
  </test>
  <test file="predicate/predicate13">
    <purpose>Test of boolean not compounded with or.</purpose>
  </test>
  <test file="predicate/predicate14">
    <purpose>Test of boolean and, or with parens retaining usual precedence.</purpose>
  </test>
  <test file="predicate/predicate15">
    <purpose>Test of boolean and, or with parens overriding precedence.</purpose>
  </test>
  <test file="predicate/predicate16">
    <purpose>Test of boolean and, or without parens.</purpose>
  </test>
  <test file="predicate/predicate17">
    <purpose>Test of boolean not with @* to test for lack of attributes.</purpose>
  </test>
  <test file="predicate/predicate18">
    <purpose>Test of starts-with on node name.</purpose>
  </test>
  <test file="predicate/predicate19">
    <purpose>Test of string-length on node name.</purpose>
  </test>
  <test file="predicate/predicate20">
    <purpose>Test of implied conversion of node-set to string, ensure = is symmetric.</purpose>
  </test>
  <test file="predicate/predicate21">
    <purpose>Test of implied conversion of node-set to string on != predicate.</purpose>
  </test>
  <test file="predicate/predicate22">
    <purpose>Test of implied conversion of node-set to string, and that != is symmetric.</purpose>
  </test>
  <test file="predicate/predicate23">
    <purpose>Test of implied conversion of node-set to boolean, ensure = is symmetric.</purpose>
  </test>
  <test file="predicate/predicate24">
    <purpose>Test of implied conversion of node-set to boolean with !=, boolean first.</purpose>
  </test>
  <test file="predicate/predicate25">
    <purpose>Test of implied conversion of node-set to boolean with !=, boolean last.</purpose>
  </test>
  <test file="predicate/predicate26">
    <purpose>Test of implied conversion of node-set to number, ensure = is symmetric.</purpose>
  </test>
  <test file="predicate/predicate27">
    <purpose>Test of implied conversion of node-set to number with a != relation.</purpose>
  </test>
  <test file="predicate/predicate28">
    <purpose>Test of implied conversion of node-set to number with a != relation.</purpose>
  </test>
  <test file="predicate/predicate29">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate30">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate31">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate32">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate33">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate34">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate35">
    <purpose>Test of implied conversion of node-set to number with an inequality relation.</purpose>
  </test>
  <test file="predicate/predicate36">
    <purpose>Test of association of inequality symbols.</purpose>
  </test>
  <test file="predicate/predicate37">
    <purpose>Show that we can limit match to non-empty elements.</purpose>
  </test>
  <test file="predicate/predicate38">
    <purpose>Stress test of nested and multiple predicates. The production rules allow such nesting.</purpose>
  </test>
  <test file="processorinfo/processorinfo01">
    <purpose>Test the xsl:version system property</purpose>
  </test>
  <test file="processorinfo/processorinfo02">
    <purpose>Test the xsl:vendor system property</purpose>
  </test>
  <test file="processorinfo/processorinfo03">
    <purpose>Test the xsl:vendor-url system property</purpose>
  </test>
  <test file="processorinfo/err/processorinfoerr01">
    <purpose>Test bad argument to system-property</purpose>
  </test>
  <test file="processorinfo/err/processorinfoerr02">
    <purpose>Test bad argument to system-property, no namespace</purpose>
  </test>
  <test file="processorinfo/err/processorinfoerr03">
    <purpose>Test bad argument to system-property, different namespace</purpose>
  </test>
  <test file="processorinfo/err/processorinfoerr04">
    <purpose>Test too few arguments to system-property</purpose>
  </test>
  <test file="processorinfo/err/processorinfoerr05">
    <purpose>Test too many arguments to system-property</purpose>
  </test>
  <test file="reluri/reluri01">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: import, import, import import</comment>
  </test>
  <test file="reluri/reluri02">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: import, import, include, import</comment>
  </test>
  <test file="reluri/reluri03">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: import, include, import, import</comment>
  </test>
  <test file="reluri/reluri04">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: import, include, include, import</comment>
  </test>
  <test file="reluri/reluri05">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: include, import, import, include</comment>
  </test>
  <test file="reluri/reluri06">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: include, import, include, include</comment>
  </test>
  <test file="reluri/reluri07">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: include, include, import, include</comment>
  </test>
  <test file="reluri/reluri08">
    <purpose>This test verifies correct URI resolution with relative URI's.</purpose>
    <comment>Case: include, include, include, include</comment>
  </test>
  <test file="reluri/reluri09">
    <purpose>Testing document() function with two arguments: string, node-set: verifying that a relative URL specified in first argument is resolved based on base URI of document in second argument nodeset.</purpose>
  </test>
  <test file="reluri/reluri10">
    <purpose>Testing document() function with two arguments: node-set, node-set: verifying that a relative URL specified in first argument is resolved based on base URI of document in second argument nodeset.</purpose>
  </test>
  <test file="select/select01">
    <purpose>Test for absolute path selection.</purpose>
  </test>
  <test file="select/select02">
    <purpose>Test of current() function - just select it.</purpose>
  </test>
  <test file="select/select03">
    <purpose>Test for select in for-each and current().</purpose>
  </test>
  <test file="select/select04">
    <purpose>Test of unions, returned in document order.</purpose>
  </test>
  <test file="select/select05">
    <purpose>Test for selecting parent nodes.</purpose>
  </test>
  <test file="select/select06">
    <purpose>Test nesting of for-each.</purpose>
  </test>
  <test file="select/select07">
    <purpose>Try to put out computed text without any tags.</purpose>
  </test>
  <test file="select/select08">
    <purpose>Test assignment of a node-set to a parameter, then use in select.</purpose>
  </test>
  <test file="select/select09">
    <purpose>Test assignment of a node-set to a local parameter, then use in select.</purpose>
  </test>
  <test file="select/select10">
    <purpose>Test for-each with select expression in a global variable.</purpose>
  </test>
  <test file="select/select11">
    <purpose>Test for-each with select expression in a local variable.</purpose>
  </test>
  <test file="select/select12">
    <purpose>Test for select that comes up empty.</purpose>
  </test>
  <test file="select/select13">
    <purpose>Test that for-each doesn't care about current node</purpose>
    <comment>Collect a node-set, outside any template</comment>
  </test>
  <test file="select/select15">
    <purpose>NCName followed by :: must be recognized as an AxisName.</purpose>
  </test>
  <test file="select/select16">
    <purpose>NCName followed by :: must be recognized as an AxisName, even if there is intervening whitespace.</purpose>
  </test>
  <test file="select/select17">
    <purpose>NCName followed by ( must be recognized as a NodeType or FunctionName.</purpose>
  </test>
  <test file="select/select18">
    <purpose>NCName followed by ( must be recognized as a NodeType or FunctionName, even if there is intervening whitespace.</purpose>
  </test>
  <test file="select/select19">
    <purpose>NCName followed by ( must be recognized as a NodeType or FunctionName.</purpose>
  </test>
  <test file="select/select20">
    <purpose>NCName followed by ( must be recognized as a NodeType or FunctionName, even if there is intervening whitespace.</purpose>
  </test>
  <test file="select/select21">
    <purpose>NCName as first item must not be treated as an operator</purpose>
  </test>
  <test file="select/select22">
    <purpose>* as first item must not be treated as an operator</purpose>
  </test>
  <test file="select/select23">
    <purpose>NCName after @ must not be treated as an operator</purpose>
  </test>
  <test file="select/select24">
    <purpose>NCName after @ must not be treated as an operator; space after is questionable.</purpose>
  </test>
  <test file="select/select25">
    <purpose>NCName after @ must not be treated as an operator; lack of spaces around hyphen makes it part of name.</purpose>
  </test>
  <test file="select/select26">
    <purpose>* after @ must be treated as all attributes</purpose>
  </test>
  <test file="select/select27">
    <purpose>NCName after :: must be treated as part of path</purpose>
  </test>
  <test file="select/select28">
    <purpose>NCName after :: must be treated as part of path</purpose>
  </test>
  <test file="select/select29">
    <purpose>NCName after ( must not be treated as operator</purpose>
  </test>
  <test file="select/select30">
    <purpose>* after ( must not be treated as operator, but * after ) is, and being tokenized means following * is not (because it follows an operator)</purpose>
  </test>
  <test file="select/select31">
    <purpose>NCName after [ must not be treated as operator</purpose>
  </test>
  <test file="select/select32">
    <purpose>* after [ must not be treated as operator</purpose>
  </test>
  <test file="select/select33">
    <purpose>NCName after operator must not be treated as operator</purpose>
  </test>
  <test file="select/select34">
    <purpose>* after (ambiguous) operator must not be treated as operator</purpose>
  </test>
  <test file="select/select35">
    <purpose>* after (named) operator must not be treated as operator</purpose>
  </test>
  <test file="select/select36">
    <purpose>name after ) must be treated as operator</purpose>
  </test>
  <test file="select/select37">
    <purpose>name after literal should be treated as operator</purpose>
  </test>
  <test file="select/select38">
    <purpose>name after * should not be treated as operator</purpose>
  </test>
  <test file="select/select39">
    <purpose>. after operator should be treated as path</purpose>
  </test>
  <test file="select/select40">
    <purpose>* after operator should be treated as path</purpose>
  </test>
  <test file="select/select67">
    <purpose>Test that document('') refers to this stylesheet, and exploit that fact to choose a template dynamically. Idea from Mike Kay.</purpose>
  </test>
  <test file="select/select68">
    <purpose>Test that document('') refers to this stylesheet, and exploit that fact to have data file select which template to use.</purpose>
  </test>
  <test file="select/select69">
    <purpose>Test whether null string as attribute value causes selection problem.</purpose>
  </test>
  <test file="select/select70">
    <purpose>Show that current() produces a node-set.</purpose>
  </test>
  <test file="select/select71">
    <purpose>test union operator using overlapping node-sets. Results should always be output in doc order regardless of order of select attribute.</purpose>
  </test>
  <test file="select/select72">
    <purpose>NodeSet union using two copies of same node, and variables</purpose>
  </test>
  <test file="select/select73">
    <purpose>Test that entity does not cause splitting of one text node into many.</purpose>
    <comment>With this output encoding, should get one byte of xE9 for the &amp;eacute</comment>
  </test>
  <test file="select/err/selecterr01">
    <purpose>Test for select with empty value.</purpose>
  </test>
  <test file="select/err/selecterr02">
    <purpose>Test for-each lacking a select.</purpose>
  </test>
  <test file="select/err/selecterr03">
    <purpose>Test of invalid function that resembles "true" where a node-set is expected.</purpose>
  </test>
  <test file="select/err/selecterr04">
    <purpose>Try to provide an argument to current().</purpose>
  </test>
  <test file="select/err/selecterr05">
    <purpose>Put xsl:for-each at top level, which is illegal.</purpose>
  </test>
  <test file="select/err/selecterr06">
    <purpose>NCName followed by :: must be recognized as an AxisName.</purpose>
  </test>
  <test file="select/err/selecterr07">
    <purpose>NCName followed by ( must be recognized as a NodeType or FunctionName.</purpose>
  </test>
  <test file="select/err/selecterr08">
    <purpose>name after ) must be treated as operator</purpose>
  </test>
  <test file="select/err/selecterr09">
    <purpose>. after number but with space should be treated as path</purpose>
  </test>
  <test file="select/err/selecterr10">
    <purpose>Try to use a number where a node-set is needed in for-each.</purpose>
  </test>
  <test file="select/err/selecterr11">
    <purpose>Try to use a boolean where a node-set is needed in for-each.</purpose>
  </test>
  <test file="select/err/selecterr12">
    <purpose>Try to use a string where a node-set is needed in for-each.</purpose>
  </test>
  <test file="select/err/selecterr13">
    <purpose>Try to use an RTF where a node-set is needed in for-each.</purpose>
  </test>
  <test file="select/err/selecterr14">
    <purpose>Try to use a number where a node-set is needed in apply-templates.</purpose>
  </test>
  <test file="select/err/selecterr15">
    <purpose>Try to use a boolean where a node-set is needed in apply-templates.</purpose>
  </test>
  <test file="select/err/selecterr16">
    <purpose>Try to use a string where a node-set is needed in apply-templates.</purpose>
  </test>
  <test file="sort/sort01">
    <purpose>Simple test for xsl:sort on numbers, default order.</purpose>
  </test>
  <test file="sort/sort02">
    <purpose>Test for xsl:sort on strings without specifying data-type or order.</purpose>
  </test>
  <test file="sort/sort03">
    <purpose>Test for xsl:sort on a descendant element.</purpose>
  </test>
  <test file="sort/sort04">
    <purpose>Test for xsl:sort and value-of the same element in the same loop.</purpose>
  </test>
  <test file="sort/sort05">
    <purpose>Test for xsl:sort on a descendant element with no order specified.</purpose>
  </test>
  <test file="sort/sort06">
    <purpose>Test for 2 xsl:sort elements with different sequence than SORT05.</purpose>
  </test>
  <test file="sort/sort07">
    <purpose>Test for xsl:sort on a different element (not always present) which should have tie-breakers.</purpose>
  </test>
  <test file="sort/sort08">
    <purpose>Test for xsl:sort on letters and spaces.</purpose>
  </test>
  <test file="sort/sort09">
    <purpose>Simple test for xsl:sort on numbers, descending order.</purpose>
  </test>
  <test file="sort/sort10">
    <purpose>Test for xsl:sort on strings without specifying data-type, descending order.</purpose>
  </test>
  <test file="sort/sort11">
    <purpose>Sort strings that all can be numbers without specifying data-type or order.</purpose>
  </test>
  <test file="sort/sort12">
    <purpose>Sort numbers with leading zeroes and decimal points.</purpose>
  </test>
  <test file="sort/sort13">
    <purpose>Numeric sort, all items that aren't true numbers should cluster together.</purpose>
  </test>
  <test file="sort/sort14">
    <purpose>Test for xsl:sort on strings without specifying case-order.</purpose>
  </test>
  <test file="sort/sort15">
    <purpose>Test for xsl:sort on strings, upper-first case-order.</purpose>
  </test>
  <test file="sort/sort16">
    <purpose>Test for xsl:sort on strings, lower-first case-order.</purpose>
  </test>
  <test file="sort/sort20">
    <purpose>Test that lang has no effect on numeric data.</purpose>
  </test>
  <test file="sort/sort21">
    <purpose>Test for xsl:sort using a numeric expression for the select.</purpose>
  </test>
  <test file="sort/sort22">
    <purpose>Test for xsl:sort using a string function for the select.</purpose>
  </test>
  <test file="sort/sort23">
    <purpose>Test for xsl:sort using a numeric expression for the select.</purpose>
  </test>
  <test file="sort/sort24">
    <purpose>Test for xsl:sort using a numeric expression for the select.</purpose>
    <comment>Note that we show that this sort does NOT do the expected rearrangement of nodes! Apparently, the conversion of the select expression to a string occurs at a bad time.</comment>
  </test>
  <test file="sort/sort25">
    <purpose>Reverse the order of the nodes using an expression that is reliable.</purpose>
  </test>
  <test file="sort/sort26">
    <purpose>Test for xsl:sort on apply-templates that does not have a select attribute.</purpose>
  </test>
  <test file="sort/sort27">
    <purpose>Test for xsl:sort on apply-templates that will get text and element children.</purpose>
  </test>
  <test file="sort/sort28">
    <purpose>Test for xsl:sort on apply-templates without select, numeric sort.</purpose>
  </test>
  <test file="sort/sort29">
    <purpose>Test for xsl:sort using a variable in the select, for-each loop.</purpose>
  </test>
  <test file="sort/sort30">
    <purpose>Test for xsl:sort using a local variable in the select, apply-templates.</purpose>
  </test>
  <test file="sort/sort31">
    <purpose>Test for xsl:sort using a global variable in the select, apply-templates.</purpose>
  </test>
  <test file="sort/sort32">
    <purpose>Try to set data-type from a variable.</purpose>
  </test>
  <test file="sort/sort33">
    <purpose>Try to set order from a variable.</purpose>
  </test>
  <test file="sort/sort34">
    <purpose>Try to set case-order from a variable.</purpose>
  </test>
  <test file="sort/sort35">
    <purpose>Test the famous technique for choosing the sort key dynamically.</purpose>
    <comment>Set value to either 'left' or 'right' above. Could change to external param.</comment>
  </test>
  <test file="sort/sort36">
    <purpose>Test the famous technique for sorting with conditionals. In this case, we want to sort strings with and without "Re: " prefix by the rest of the string. Technique from Oliver Becker (obecker@informatik.hu-berlin.de).</purpose>
  </test>
  <test file="sort/sort37">
    <purpose>If nothing comes through select, should get document order.</purpose>
  </test>
  <test file="sort/sort38">
    <purpose>Numeric sort, but no items are true numbers.</purpose>
  </test>
  <test file="sort/err/sorterr01">
    <purpose>Undefined value for data-type attribute on sort.</purpose>
  </test>
  <test file="sort/err/sorterr02">
    <purpose>Incorrect value for order attribute on sort.</purpose>
  </test>
  <test file="sort/err/sorterr03">
    <purpose>Incorrect value for case-order attribute on sort.</purpose>
  </test>
  <test file="sort/err/sorterr04">
    <purpose>Undefined attribute on sort.</purpose>
  </test>
  <test file="sort/err/sorterr05">
    <purpose>Try to put a child node inside xsl:sort.</purpose>
  </test>
  <test file="sort/err/sorterr06">
    <purpose>Test use of xsl:sort inside a directive where it's not allowed.</purpose>
  </test>
  <test file="sort/err/sorterr07">
    <purpose>Test use of xsl:sort at top level, where it's not allowed.</purpose>
  </test>
  <test file="sort/err/sorterr08">
    <purpose>Undefined value for data-type attribute on sort, but it's qualified.</purpose>
  </test>
  <test file="sort/err/sorterr09">
    <purpose>Try to use an AVT for the select value.</purpose>
  </test>
  <test file="sort/err/sorterr10">
    <purpose>When can't sort on primary key, should not sort at all. Raise warning?</purpose>
  </test>
  <test file="string/string01">
    <purpose>Test of string-length() on literal string.</purpose>
  </test>
  <test file="string/string02">
    <purpose>Test of string-length() of element node</purpose>
  </test>
  <test file="string/string04">
    <purpose>Test of string-length() without arguments, and with node path.</purpose>
  </test>
  <test file="string/string05">
    <purpose>Test of 'string()' conversion w/ element node</purpose>
  </test>
  <test file="string/string06">
    <purpose>Test of 'starts-with()'</purpose>
  </test>
  <test file="string/string07">
    <purpose>Test of 'contains()'</purpose>
  </test>
  <test file="string/string08">
    <purpose>Test of 'substring-before()'</purpose>
  </test>
  <test file="string/string09">
    <purpose>Test of 'substring-after()'</purpose>
  </test>
  <test file="string/string10">
    <purpose>Test of 'normalize-space()' function</purpose>
  </test>
  <test file="string/string11">
    <purpose>Test of 'translate()'</purpose>
  </test>
  <test file="string/string12">
    <purpose>Test of 'concat()'</purpose>
  </test>
  <test file="string/string13">
    <purpose>Test of 'format-number()' function.</purpose>
  </test>
  <test file="string/string14">
    <purpose>Test of string() conversion on a variable containing a node-set</purpose>
  </test>
  <test file="string/string15">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string16">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string17">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string18">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string19">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string20">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string21">
    <purpose>Test of 'substring()' function.</purpose>
  </test>
  <test file="string/string22">
    <purpose>Test of 'substring()' function on non-existent node</purpose>
  </test>
  <test file="string/string30">
    <purpose>Test of 'namespace-uri()'.</purpose>
  </test>
  <test file="string/string31">
    <purpose>Test of 'namespace-uri()'.</purpose>
  </test>
  <test file="string/string32">
    <purpose>Test of 'name()'.</purpose>
  </test>
  <test file="string/string33">
    <purpose>Test of 'name()'.</purpose>
  </test>
  <test file="string/string34">
    <purpose>Test of 'name()'.</purpose>
  </test>
  <test file="string/string35">
    <purpose>Test of 'name()'.</purpose>
  </test>
  <test file="string/string36">
    <purpose>Test of 'name()'.</purpose>
  </test>
  <test file="string/string37">
    <purpose>Test of 'string()' function.</purpose>
  </test>
  <test file="string/string38">
    <purpose>Test of 'string()' function.</purpose>
  </test>
  <test file="string/string39">
    <purpose>Test of 'string()' function.</purpose>
  </test>
  <test file="string/string40">
    <purpose>Test of 'string()' function.</purpose>
  </test>
  <test file="string/string41">
    <purpose>Test of 'string()' function.</purpose>
  </test>
  <test file="string/string42">
    <purpose>Test of 'string()' function on a simple RTF.</purpose>
  </test>
  <test file="string/string43">
    <purpose>Test of 'string()' function with empty RTF.</purpose>
  </test>
  <test file="string/string44">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string45">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string46">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string47">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string48">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string49">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string50">
    <purpose>Test of 'starts-with()' function.</purpose>
  </test>
  <test file="string/string51">
    <purpose>Test of 'starts-with()' function with node.</purpose>
  </test>
  <test file="string/string52">
    <purpose>Test of 'starts-with()' function with node.</purpose>
  </test>
  <test file="string/string53">
    <purpose>Test of 'starts-with()' function w/ attribute.</purpose>
  </test>
  <test file="string/string54">
    <purpose>Test of 'starts-with()' function with attribute.</purpose>
  </test>
  <test file="string/string55">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string56">
    <purpose>Test of 'contains()' function using variables.</purpose>
  </test>
  <test file="string/string57">
    <purpose>Test of 'contains()' function using expressions.</purpose>
  </test>
  <test file="string/string58">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string59">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string60">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string61">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string62">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string63">
    <purpose>Test of 'contains()' function.</purpose>
  </test>
  <test file="string/string64">
    <purpose>Test of 'contains()' function with node as 1st argument, string is in it.</purpose>
  </test>
  <test file="string/string65">
    <purpose>Test of 'contains()' function with node as 1st argument, string is not in it.</purpose>
  </test>
  <test file="string/string66">
    <purpose>Test of 'contains()' function with attribute as 1st argument, string is in it.</purpose>
  </test>
  <test file="string/string67">
    <purpose>Test of 'contains()' function with attribute as 1st argument, string is not in it.</purpose>
  </test>
  <test file="string/string68">
    <purpose>Test of 'substring-before()' function.</purpose>
  </test>
  <test file="string/string69">
    <purpose>Test of 'substring-before()' function.</purpose>
  </test>
  <test file="string/string70">
    <purpose>Test of 'substring-before()' function.</purpose>
  </test>
  <test file="string/string71">
    <purpose>Test of 'substring-before()' function with node.</purpose>
  </test>
  <test file="string/string72">
    <purpose>Test of 'substring-before()' function with empty node.</purpose>
  </test>
  <test file="string/string73">
    <purpose>Test of 'substring-before()' function with attribute.</purpose>
  </test>
  <test file="string/string74">
    <purpose>Test of 'substring-before()' function with attribute.</purpose>
  </test>
  <test file="string/string75">
    <purpose>Test of 'substring-before()' function with attribute.</purpose>
  </test>
  <test file="string/string76">
    <purpose>Test of 'substring-after()' function.</purpose>
  </test>
  <test file="string/string77">
    <purpose>Test of 'substring-after()' function.</purpose>
  </test>
  <test file="string/string78">
    <purpose>Test of 'substring-after()' function.</purpose>
  </test>
  <test file="string/string79">
    <purpose>Test of 'substring-after()' function.</purpose>
  </test>
  <test file="string/string80">
    <purpose>Test of 'substring-after()' function with node.</purpose>
  </test>
  <test file="string/string81">
    <purpose>Test of 'substring-after()' function with empty node.</purpose>
  </test>
  <test file="string/string82">
    <purpose>Test of 'substring-after()' function with attribute</purpose>
  </test>
  <test file="string/string83">
    <purpose>Test of 'substring-after()' function with attribute.</purpose>
  </test>
  <test file="string/string84">
    <purpose>Test of 'substring-after()' function with attribute.</purpose>
  </test>
  <test file="string/string85">
    <purpose>Test of 'normalize-space()' function with node.</purpose>
  </test>
  <test file="string/string86">
    <purpose>Test of 'normaliz-space()' function with empty node.</purpose>
  </test>
  <test file="string/string87">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string88">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string89">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string90">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string91">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string92">
    <purpose>Test of 'translate()' function with attributes.</purpose>
  </test>
  <test file="string/string93">
    <purpose>Test of 'translate()' function with attributes.</purpose>
  </test>
  <test file="string/string94">
    <purpose>Test of 'translate()' function with attributes.</purpose>
  </test>
  <test file="string/string95">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string96">
    <purpose>Test of 'translate()' function.</purpose>
  </test>
  <test file="string/string97">
    <purpose>Test of 'concat()' function.</purpose>
  </test>
  <test file="string/string98">
    <purpose>Test of 'concat()' function with nodes.</purpose>
  </test>
  <test file="string/string99">
    <purpose>Test of 'concat()' function with nodes.</purpose>
  </test>
  <test file="string/string100">
    <purpose>Test of 'concat()'</purpose>
  </test>
  <test file="string/string101">
    <purpose>Test of 'concat()'</purpose>
  </test>
  <test file="string/string102">
    <purpose>Test of concat() on entities and expressions</purpose>
  </test>
  <test file="string/string103">
    <purpose>Test of 'concat()'</purpose>
  </test>
  <test file="string/string104">
    <purpose>Test of 'concat()'</purpose>
  </test>
  <test file="string/string105">
    <purpose>Special case of concat() with one argument. Strictly speaking, this should fail just like STRerr14.</purpose>
  </test>
  <test file="string/string106">
    <purpose>Test of 'format-number()'</purpose>
  </test>
  <test file="string/string107">
    <purpose>Test of string() function on an RTF with sub-nodes.</purpose>
  </test>
  <test file="string/string108">
    <purpose>Test of 'format-number()'</purpose>
  </test>
  <test file="string/string109">
    <purpose>Test of 'format-number()'</purpose>
  </test>
  <test file="string/string110">
    <purpose>Test of 'format-number()'</purpose>
  </test>
  <test file="string/string111">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string112">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string113">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string114">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string115">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string116">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string117">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string118">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string119">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string120">
    <purpose>Test of 'substring()'</purpose>
  </test>
  <test file="string/string121">
    <purpose>Test of 'translate()'</purpose>
  </test>
  <test file="string/string122">
    <purpose>string(nodeset) returns string value of the node in the node-set that is first in document order.'</purpose>
  </test>
  <test file="string/string123">
    <purpose>Test of string() function with no arguments.</purpose>
    <comment>"If the argument is omitted, it defaults to a node-set with the context node as its only member." BUT this node has text and element children, all of which get concatenated.</comment>
  </test>
  <test file="string/string124">
    <purpose>Test of contains() function searching for an entity.</purpose>
    <comment>Suppress text copying if contains() fails</comment>
  </test>
  <test file="string/string125">
    <purpose>Test of contains() function with nodes for both arguments, string is not in it.</purpose>
  </test>
  <test file="string/string126">
    <purpose>Test of contains() function with nodes for both arguments, string is in it.</purpose>
  </test>
  <test file="string/string127">
    <purpose>Test of contains() function with two paths, first argument is multiple nodes, first of those nodes does NOT contain the string.</purpose>
  </test>
  <test file="string/string128">
    <purpose>Test of contains() function with two paths, second argument is multiple nodes, first of those nodes does NOT contain the string.</purpose>
  </test>
  <test file="string/string129">
    <purpose>Test of contains() function using a numbered entity.</purpose>
  </test>
  <test file="string/string130">
    <purpose>Test of contains() function using a numbered entity.</purpose>
  </test>
  <test file="string/string131">
    <purpose>Test of string() with zero arguments. Context node just has one text child.</purpose>
  </test>
  <test file="string/string132">
    <purpose>Test of default (no functions) conversion of integers.</purpose>
  </test>
  <test file="string/string133">
    <purpose>Test of default (no functions) conversion of decimal numbers with fractions.</purpose>
  </test>
  <test file="string/string134">
    <purpose>Test of default (no functions) conversion of decimal numbers with decimal point at all positions.</purpose>
  </test>
  <test file="string/string135">
    <purpose>Test of default (no functions) conversion of small decimal numbers.</purpose>
  </test>
  <test file="string/err/stringerr01">
    <purpose>Test of invalid function that resembles "true" with string().</purpose>
  </test>
  <test file="string/err/stringerr02">
    <purpose>Test of invalid function that resembles "true" with string-length().</purpose>
  </test>
  <test file="string/err/stringerr03">
    <purpose>Test of 'normalize-space()' function with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr04">
    <purpose>Test of 'contains()' with one argument</purpose>
  </test>
  <test file="string/err/stringerr05">
    <purpose>Test of 'contains()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr06">
    <purpose>Test of 'starts-with()' with one argument</purpose>
  </test>
  <test file="string/err/stringerr07">
    <purpose>Test of 'starts-with()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr08">
    <purpose>Test of 'substring-before()' with one argument</purpose>
  </test>
  <test file="string/err/stringerr09">
    <purpose>Test of 'substring-before()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr10">
    <purpose>Test of 'substring-after()' with one argument</purpose>
  </test>
  <test file="string/err/stringerr11">
    <purpose>Test of 'substring-after()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr12">
    <purpose>Test of 'substring()' with one argument</purpose>
  </test>
  <test file="string/err/stringerr13">
    <purpose>Test of 'substring()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr14">
    <purpose>Test of 'concat()' with one argument</purpose>
  </test>
  <test file="string/err/stringerr15">
    <purpose>Test of 'string-length()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr16">
    <purpose>Test of 'translate()' with 2 arguments</purpose>
  </test>
  <test file="string/err/stringerr17">
    <purpose>Test of 'translate()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr18">
    <purpose>Test of 'string()' with too many arguments</purpose>
  </test>
  <test file="string/err/stringerr19">
    <purpose>Special case of concat() with one argument. Strictly speaking, this should fail just like STRerr14.</purpose>
  </test>
  <test file="variable/variable01">
    <purpose>Set top-level xsl:variable to a string</purpose>
  </test>
  <test file="variable/variable02">
    <purpose>Test top-level xsl:variable set to be an RTF</purpose>
  </test>
  <test file="variable/variable03">
    <purpose>Test xsl:variable inside a template set to be an RTF</purpose>
  </test>
  <test file="variable/variable04">
    <purpose>Test for passing variable into other template via with-param.</purpose>
  </test>
  <test file="variable/variable05">
    <purpose>Verify top-level xsl:variable, HTML text RTF</purpose>
  </test>
  <test file="variable/variable06">
    <purpose>Set variable by name but no value, should get null string</purpose>
  </test>
  <test file="variable/variable07">
    <purpose>Test for handling of RTF used as positional index by setting variable as the content of the xsl:variable element. Reference as [$n]. This is the case that will NOT obtain what a naive person expects.</purpose>
  </test>
  <test file="variable/variable08">
    <purpose>Test for handling of RTF used as positional index by setting variable as the content of the xsl:variable element. Reference as [position()=$n] This is the case that will NOT obtain what the naive person expects.</purpose>
  </test>
  <test file="variable/variable09">
    <purpose>Test for handling of number used as positional index by setting variable using select attribute. Reference as [$n]</purpose>
  </test>
  <test file="variable/variable10">
    <purpose>Test for using xsl:copy-of with empty (null string) variable.</purpose>
  </test>
  <test file="variable/variable11">
    <purpose>Import precedence applies to top-level params (even when template referencing it is in the imported file)</purpose>
  </test>
  <test file="variable/variable12">
    <purpose>Set top-level xsl:param to a string</purpose>
  </test>
  <test file="variable/variable13">
    <purpose>Test for setting a param using a choose</purpose>
  </test>
  <test file="variable/variable14">
    <purpose>Verify that a variable defined within a xsl:with-param content is scoped correctly. Idea sent in on xalan-dev list. We should recognize 'test' within the with-param statement. The named template 'foo' really plays no part here.</purpose>
  </test>
  <test file="variable/variable15">
    <purpose>Test for-each inside xsl:variable</purpose>
  </test>
  <test file="variable/variable16">
    <purpose>Test for-each inside xsl:param</purpose>
  </test>
  <test file="variable/variable17">
    <purpose>Show that there is always a current node</purpose>
  </test>
  <test file="variable/variable18">
    <purpose>Test param being set to default in a named template.</purpose>
  </test>
  <test file="variable/variable19">
    <purpose>Verify that a variable in an inner template can take on a new value</purpose>
  </test>
  <test file="variable/variable20">
    <purpose>Verify that a variable in a for-each can take on a new value</purpose>
    <comment>It's unclear whether the spec allows this. XT does; Saxon doesn't.</comment>
  </test>
  <test file="variable/variable21">
    <purpose>Test setting several parameters locally</purpose>
  </test>
  <test file="variable/variable22">
    <purpose>Import precedence applies to top-level params (testing references from various import levels)</purpose>
  </test>
  <test file="variable/variable23">
    <purpose>Test how big a string can be passed to a template.</purpose>
  </test>
  <test file="variable/variable24">
    <purpose>Test the ability of variable to hold the result of document()</purpose>
  </test>
  <test file="variable/variable25">
    <purpose>Variable name is a QName.</purpose>
  </test>
  <test file="variable/variable26">
    <purpose>It is not an error to pass a parameter to a template that does not have an element for it, the parameter is simpily ignored.</purpose>
  </test>
  <test file="variable/variable27">
    <purpose>Import precedence applies to top-level params (testing references from various import levels)</purpose>
  </test>
  <test file="variable/variable28">
    <purpose>Import precedence applies to top-level params (first template from middle, then up/down/up)</purpose>
  </test>
  <test file="variable/variable29">
    <purpose>Import precedence applies to top-level params (order of imports in this sheet matters)</purpose>
  </test>
  <test file="variable/variable30">
    <purpose>Import precedence applies to top-level params (start at bottom; all use variable set in middle)</purpose>
  </test>
  <test file="variable/variable31">
    <purpose>Test passing value from top-level param to top-level variable via value-of.</purpose>
  </test>
  <test file="variable/variable32">
    <purpose>Test passing value from top-level param to top-level variable via value-of.</purpose>
  </test>
  <test file="variable/variable33">
    <purpose>Set top-level variable with a forward reference to see what happens.</purpose>
  </test>
  <test file="variable/variable34">
    <purpose>Set cascaded top-level variables in arbitrary order.</purpose>
  </test>
  <test file="variable/variable35">
    <purpose>Try to catch lazy-evaluation scheme picking up local instead of global.</purpose>
  </test>
  <test file="variable/variable36">
    <purpose>Set variable to null string explicitly and implicitly, compare.</purpose>
  </test>
  <test file="variable/variable37">
    <purpose>Set a variable to a boolean, and show it being used in xsl:if</purpose>
  </test>
  <test file="variable/variable38">
    <purpose>Test for using xsl:copy-of with variable set to a number.</purpose>
    <comment>This should have the same result as xsl:value-of, stringified number.</comment>
  </test>
  <test file="variable/variable39">
    <purpose>Build an RTF from instructions, then use xsl:copy-of.</purpose>
  </test>
  <test file="variable/variable40">
    <purpose>Test top-level xsl:variable set using apply-templates</purpose>
  </test>
  <test file="variable/variable41">
    <purpose>Because root node is current when top-level param is set, can get top-level comment.</purpose>
  </test>
  <test file="variable/variable42">
    <purpose>Use copy to set a variable to an RTF. REMINDER: we won't get the whole sub-tree, just the 'doc' element node.</purpose>
  </test>
  <test file="variable/variable43">
    <purpose>Test xsl:variable inside xsl:copy</purpose>
  </test>
  <test file="variable/variable44">
    <purpose>Set a variable inside a template based on variable defined earlier in that template.</purpose>
  </test>
  <test file="variable/variable45">
    <purpose>Use param whose name is a QName in with-param passing.</purpose>
  </test>
  <test file="variable/variable46">
    <purpose>Test proper construction of an RTF containing multiple top level nodes.</purpose>
  </test>
  <test file="variable/err/variableerr01">
    <purpose>Negative test, attempt to access undefined variable.</purpose>
  </test>
  <test file="variable/err/variableerr02">
    <purpose>Negative test, attempt to access variable that's not in scope.</purpose>
  </test>
  <test file="variable/err/variableerr03">
    <purpose>Test for missing name attribute in xsl:variable</purpose>
  </test>
  <test file="variable/err/variableerr04">
    <purpose>Negative test, attempt to use variable RTF as a nodeset.</purpose>
  </test>
  <test file="variable/err/variableerr05">
    <purpose>Test for xsl:variable with both content and select.</purpose>
  </test>
  <test file="variable/err/variableerr06">
    <purpose>Test for xsl:param with both content and select.</purpose>
  </test>
  <test file="variable/err/variableerr07"/>
  <test file="variable/err/variableerr08">
    <purpose>Put xsl:param somewhere other than first in a template.</purpose>
  </test>
  <test file="variable/err/variableerr09">
    <purpose>Try to set same top-level xsl:variable twice</purpose>
  </test>
  <test file="variable/err/variableerr10">
    <purpose>Try to set same top-level xsl:param twice</purpose>
  </test>
  <test file="variable/err/variableerr11">
    <purpose>Try to set same top-level param twice using different instructions, param first</purpose>
  </test>
  <test file="variable/err/variableerr12">
    <purpose>Try to set same top-level param twice using different instructions, variable first</purpose>
  </test>
  <test file="variable/err/variableerr13">
    <purpose>Try to set same in-template param twice</purpose>
  </test>
  <test file="variable/err/variableerr14">
    <purpose>Try to set same in-template variable twice</purpose>
  </test>
  <test file="variable/err/variableerr15">
    <purpose>Try to set same in-template param twice using different instructions, param first</purpose>
  </test>
  <test file="variable/err/variableerr16">
    <purpose>Try to set same in-template param twice using different instructions, variable first</purpose>
  </test>
  <test file="variable/err/variableerr17">
    <purpose>Try to set top-level params with circular references</purpose>
  </test>
  <test file="variable/err/variableerr18">
    <purpose>Try to set in-template params with circular references</purpose>
  </test>
  <test file="variable/err/variableerr19">
    <purpose>Try to set a variable inside a template based on variable defined later in that template.</purpose>
  </test>
  <test file="variable/err/variableerr20">
    <purpose>Try to set same param twice inside a template, after setting via with-param.</purpose>
  </test>
  <test file="ver/ver01">
    <purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
  </test>
  <test file="ver/ver02">
    <purpose>Prove that transform is a synonym for stylesheet.</purpose>
    <comment>Explicitly match text nodes so the output is just 39</comment>
  </test>
  <test file="ver/ver03">
    <purpose>Prove that transform takes the "id" attribute.</purpose>
    <comment>Explicitly match text nodes so the output is just 39</comment>
  </test>
  <test file="ver/ver04">
    <purpose>Test for explicit specification of version attribute in stylesheet declaration above.</purpose>
    <comment>Explicitly match text nodes so the output is just 39</comment>
  </test>
  <test file="ver/ver05">
    <purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
    <comment>Note that this test obviously needs updating as soon as we support XSLT 1.1!</comment>
  </test>
  <test file="ver/ver06">
    <purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
    <comment>Note that this test obviously needs updating as soon as we support XSLT 1.2!</comment>
  </test>
  <test file="ver/ver07">
    <purpose>Test the basics of the XSLT version declaration. Should not raise an error.</purpose>
    <comment>Note that this test obviously needs updating as soon as we support XSLT 2.0!</comment>
  </test>
  <test file="ver/err/vererr01">
    <purpose>Test validation when version matches supported version.</purpose>
  </test>
  <test file="ver/err/vererr02">
    <purpose>Test validation when version is lower than supported version.</purpose>
  </test>
  <test file="ver/err/vererr03"/>
  <test file="ver/err/vererr04">
    <purpose>Don't allow xsl:stylesheet inside the stylesheet element.</purpose>
  </test>
  <test file="ver/err/vererr05">
    <purpose>Test use of an undefined element (garbage) as if was part of XSLT.</purpose>
  </test>
  <test file="ver/err/vererr06">
    <purpose>Don't allow xsl:stylesheet inside a template.</purpose>
  </test>
  <test file="ver/err/vererr07">
    <purpose>Don't allow xsl:transform inside a template.</purpose>
  </test>
  <test file="ver/err/vererr08">
    <purpose>Don't allow xsl:transform inside the stylesheet element.</purpose>
  </test>
  <test file="ver/err/vererr09">
    <purpose>Test that version number is required.</purpose>
  </test>
  <test file="whitespace/whitespace01">
    <purpose>Test strip-space directive.</purpose>
  </test>
  <test file="whitespace/whitespace02">
    <purpose>Test strip-space on list of specified elements.</purpose>
  </test>
  <test file="whitespace/whitespace03">
    <purpose>Test strip-space with wildcard element selector.</purpose>
  </test>
  <test file="whitespace/whitespace04">
    <purpose>Test wildcard on strip-space overridden by preserve-space for one element.</purpose>
  </test>
  <test file="whitespace/whitespace05">
    <purpose>Test stripping an element that has whitespace plus a comment containing whitespace.</purpose>
  </test>
  <test file="whitespace/whitespace06">
    <purpose>Test element specifier that has a namespace qualifier.</purpose>
  </test>
  <test file="whitespace/whitespace07">
    <purpose>Test for element specifier that is a wildcard but qualified by a namespace.</purpose>
  </test>
  <test file="whitespace/whitespace08">
    <purpose>Test default whitespace handling.</purpose>
  </test>
  <test file="whitespace/whitespace09">
    <purpose>Test output of newline via CDATA section in template.</purpose>
  </test>
  <test file="whitespace/whitespace10">
    <purpose>Test whitespace as LRE in template.</purpose>
  </test>
  <test file="whitespace/whitespace11">
    <purpose>Test whitespace in template matched on root.</purpose>
  </test>
  <test file="whitespace/whitespace12">
    <purpose>Test xsl:output with indent.</purpose>
  </test>
  <test file="whitespace/whitespace13">
    <purpose>Test default whitespace handling where both source and template have space.</purpose>
  </test>
  <test file="whitespace/whitespace14">
    <purpose>Test use of whitespace character entities.</purpose>
  </test>
  <test file="whitespace/whitespace15">
    <purpose>Test default whitespace handling.</purpose>
  </test>
  <test file="whitespace/whitespace16">
    <purpose>This is a general test of whitespace handling. It verifies the handling of the special whitespace characters (space, tab, CR, LF) In different situations. 1. within xsl:text where they should not be stripped, 2. within LREs &lt;end2&gt; where they may be stripped.</purpose>
  </test>
  <test file="whitespace/whitespace17">
    <purpose>Test indent on xsl:output with copy-of.</purpose>
  </test>
  <test file="whitespace/whitespace18">
    <purpose>xsl:text node should not contribute any text nodes to the result tree.</purpose>
  </test>
  <test file="whitespace/whitespace19">
    <purpose>Stylesheet is whitespace stripped before processing.</purpose>
  </test>
  <test file="whitespace/whitespace20">
    <purpose>xml:space attributes need to be perserved.</purpose>
  </test>
  <test file="whitespace/whitespace21">
    <purpose>Test for whitespace handling with comments in literal sections</purpose>
  </test>
  <test file="whitespace/whitespace22">
    <purpose>Testing the applicable match for a particular element, also verifying that preserve-space works with namespace-prefixed element. This generate an error, recovering with the match that occurs last in the stylesheet.</purpose>
  </test>
  <test file="whitespace/err/whitespaceerr01">
    <purpose>Test error reporting when required attribute, elements, is missing from xsl:strip-space.</purpose>
  </test>
  <test file="whitespace/err/whitespaceerr02">
    <purpose>Test error reporting when required attribute, elements, is missing from xsl:preserve-space.</purpose>
  </test>
  <test file="whitespace/err/whitespaceerr03">
    <purpose>Test placement of preserve-space inside a template, which is illegal.</purpose>
  </test>
  <test file="whitespace/err/whitespaceerr04">
    <purpose>Test placement of strip-space inside atemplate, which is illegal.</purpose>
  </test>
</xalantests>
