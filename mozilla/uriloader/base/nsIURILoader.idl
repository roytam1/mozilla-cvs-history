/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * The contents of this file are subject to the Netscape Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is Netscape
 * Communications Corporation.  Portions created by Netscape are
 * Copyright (C) 1999 Netscape Communications Corporation. All
 * Rights Reserved.
 *
 * Contributor(s): 
 */

/* The uri dispatcher is responsible for taking uri's, determining
   the content and routing the opened url to the correct content 
   handler. 

  When you encounter a url you want to open, you typically call 
  openURI, passing it the content listener for the window the uri is 
  originating from. The uri dispatcher opens the url to discover the 
  content type. It then gives the content listener first crack at 
  handling the content. If it doesn't want it, the dispatcher tries
  to hand it off one of the registered content listeners. This allows
  running applications the chance to jump in and handle the content.

  If that also fails, then the uri dispatcher goes to the registry
  looking for the preferred content handler for the content type
  of the uri. The content handler may create an app instance
  or it may hand the contents off to a platform specific plugin
  or helper app. Or it may hand the url off to an OS registered 
  application. 
*/

#include "nsISupports.idl"

interface nsIURIContentListener;
interface nsIURI;
interface nsIProgressEventSink;
interface nsIChannel;
interface nsIStreamListener;
interface nsIInputStream;

typedef long nsURILoadCommand;

[scriptable, uuid(40AECB53-8B65-11d3-989D-001083010E9B)]
interface nsIURILoader : nsISupports
{
  /* as applications such as messenger and the browser are instantiated,
     they register content listener's with the uri dispatcher corresponding
     to content windows within that application. 

     Note to self: we may want to optimize things a bit more by requiring
     the content types the registered content listener cares about.
  */
  void registerContentListener   (in nsIURIContentListener aContentListener);
  void unRegisterContentListener (in nsIURIContentListener aContentListener);

  /* OpenURI requires the following parameters.....
     aURI --> the uri you wish to open
	 aCommand --> describes the context of the url. most often, you want to pass viewNormal here.
				  but if it the action was from a user click or you want to view source, or you want
				  a new window, these are all passed in via aCommand.
	 aWindowTarget -> the name of the desired target window (can be null)
	 aWindowContext --> if you are running the url from a doc shell or a web shell,
					    this is your window context. If you have a content listener
						you want to give first crack to, the uri loader needs to be able
						to get it from the window context (we'll use nsIInterfaceRequestor).
						we will also be using nsIInterfaceRequestor to get at the progress event
						sink interface.
     aReferringURI --> if a uri referral was involved....
	 aOpenContext (in) --> if you've already opened a url before, and you still have
						   the associated open context, you should pass it in here (can be null)
						   This is used to help keep track of urls opened by the same caller!!
	 aCurrentOpenContext --> a cookie returned to the caller which can be used by the caller
						    to make future open calls on the uriloader. 

  */ 

  void openURI(in nsIChannel aChannel, 
			   in nsURILoadCommand aCommand,
			   in string aWindowTarget,
			   in nsISupports aWindowContext,
			   in nsISupports aOpenContext,
			   out nsISupports aCurrentOpenContext);


  /* same call as OpenURI except this one takes an IP address to use as well...
     adapterBinding -> the local IP address to bind to*/			   

  void openURIVia(in nsIChannel aChannel,
				  in nsURILoadCommand aCommand,
				  in string aWindowTarget,
				  in nsISupports aWindowContext,
			      in nsISupports aOpenContext,
			      out nsISupports aCurrentOpenContext,
				  in unsigned long adapterBinding); 


    /* these are nsURILoadCommand */
	const long viewNormal = 0;
    const long viewSource = 1;
    const long viewUserClick = 2;
	const long viewNewWindow = 3;
	const long viewNormalBackground = 4;

  /* mscott -> I'm going to move this out into a separate private interface
   */
  void dispatchContent(in string aContentType,
					   in nsURILoadCommand aCommand,
					   in string aWindowTarget,
					   in nsIChannel aChannel, 
					   in nsISupports aCtxt,
					   in nsIURIContentListener aContentListener,
					   out string aDesiredContentType,
					   out nsIURIContentListener aTargetListener);
  /* this command should become obsolete once we get rid of the old layout "verb" command
     string and replace it with the enumerated type nsURILoaderCommand
  */
  void getStringForCommand (in nsURILoadCommand aCommand, out string aStringVersion);
};

