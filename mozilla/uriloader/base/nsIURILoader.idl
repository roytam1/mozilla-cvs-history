/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * The contents of this file are subject to the Netscape Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is Netscape
 * Communications Corporation.  Portions created by Netscape are
 * Copyright (C) 1999 Netscape Communications Corporation. All
 * Rights Reserved.
 *
 * Contributor(s): 
 */

/* The uri dispatcher is responsible for taking uri's, determining
   the content and routing the opened url to the correct content 
   handler. 

  When you encounter a url you want to open, you typically call 
  openURI, passing it the content listener for the window the uri is 
  originating from. The uri dispatcher opens the url to discover the 
  content type. It then gives the content listener first crack at 
  handling the content. If it doesn't want it, the dispatcher tries
  to hand it off one of the registered content listeners. This allows
  running applications the chance to jump in and handle the content.

  If that also fails, then the uri dispatcher goes to the registry
  looking for the preferred content handler for the content type
  of the uri. The content handler may create an app instance
  or it may hand the contents off to a platform specific plugin
  or helper app. Or it may hand the url off to an OS registered 
  application. 
*/

#include "nsISupports.idl"

interface nsIURIContentListener;
interface nsIURI;
interface nsIProgressEventSink;
interface nsIChannel;
interface nsIStreamListener;

[scriptable, uuid(40AECB53-8B65-11d3-989D-001083010E9B)]
interface nsIURILoader : nsISupports
{
  /* as applications such as messenger and the browser are instantiated,
     they register content listener's with the uri dispatcher corresponding
     to content windows within that application. 

     Note to self: we may want to optimize things a bit more by requiring
     the content types the registered content listener cares about.
  */
  void registerContentListener   (in nsIURIContentListener aContentListener);
  void unRegisterContentListener (in nsIURIContentListener aContentListener);

  /* OpenURI requires the following parameters.....
     aURI --> the uri you wish to open
	 aWindowTarget -> the name of the desired target window (can be null)
	 aProgressEventSink -> a progress event sink associated with the url (can be null)
     aContentListener --> a content listener you want to give first crack
                          at handling the uri. (can be null) 
     aReferringURI --> if a uri referral was involved....
	 aOpenContext (in) --> if you've already opened a url before, and you still have
						   the associated open context, you should pass it in here (can be null)
						   This is used to help keep track of urls opened by the same caller!!
	 aCurrentOpenContext --> a cookie returned to the caller which can be used by the caller
						    to make future open calls on the uriloader. 

  */ 

  void openURI(in nsIURI aURI, 
			   in string aWindowTarget,
			   in nsIProgressEventSink aProgressEventSink,
			   in nsIURIContentListener aContentListener, 
			   in nsIURI aReferringURI,
			   in nsISupports aOpenContext,
			   out nsISupports aCurrentOpenContext);


  /* same call as OpenURI except this one takes an IP address to use as well...
     adapterBinding -> the local IP address to bind to*/			   

  void openURIVia(in nsIURI aURI,
				  in string aWindowTarget,
				  in nsIProgressEventSink aProgressEventSink,
			      in nsIURIContentListener aContentListener, 
			      in nsIURI aReferringURI,
			      in nsISupports aOpenContext,
			      out nsISupports aCurrentOpenContext,
				  in unsigned long adapterBinding); 

  /* mscott -> I'm going to move this out into a separate private interface
   */
  void dispatchContent(in string aContentType,
					   in string aCommand,
					   in string aWindowTarget,
					   in nsIChannel aChannel, 
					   in nsISupports aCtxt,
					   in nsIURIContentListener aContentListener,
					   out nsIStreamListener aTargetListener);
};
