#!/usr/bin/perl
# 
# The contents of this file are subject to the Mozilla Public
# License Version 1.1 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of
# the License at http://www.mozilla.org/MPL/
# 
# Software distributed under the License is distributed on an "AS
# IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
# implied. See the License for the specific language governing
# rights and limitations under the License.
# 
# The Original Code is the Netscape Security Services for Java.
# 
# The Initial Developer of the Original Code is Netscape
# Communications Corporation.  Portions created by Netscape are 
# Copyright (C) 1998-2000 Netscape Communications Corporation.  All
# Rights Reserved.
# 
# Contributor(s):
# 
# Alternatively, the contents of this file may be used under the
# terms of the GNU General Public License Version 2 or later (the
# "GPL"), in which case the provisions of the GPL are applicable 
# instead of those above.  If you wish to allow use of your 
# version of this file only under the terms of the GPL and not to
# allow others to use your version of this file under the MPL,
# indicate your decision by deleting the provisions above and
# replace them with the notice and other provisions required by
# the GPL.  If you do not delete the provisions above, a recipient
# may use your version of this file under either the MPL or the
# GPL.
# 

############################################################################
# (I) Offer a standard "Usage:" statement and process command line options #
############################################################################

    # (A) Print out the "Usage:" statement since there must always
    #     be at least TWO command line arguments to $0.

    if ( "$ARGV[1]" eq "" )
    {
USAGE:
	print( STDERR "Usage:  perl " );
	print( STDERR $0 );
	print( STDERR " <generated_filename>" );
	print( STDERR " <jni_header_1>" );
	print( STDERR " [jni_header_2] . . ." );
	print( STDERR " [jni_header_n]\n" );
	exit( -1 );
    }

    # (B) Initialize array index

    $index = 0;

    # (C) Process all command line options

    while( $_ = $ARGV[0] )
    {
	if( ( "$ARGV[0]" eq "help" ) || ( "$ARGV[0]" eq "?" ) )
	{
	    # (1) print Usage: message
	    goto USAGE;
	}
	elsif( "$ARGV[0]" =~ /^(.*).h$/ )
	{
	    # (2) retrieve name of generated file
	    $generated_header_filename = $ARGV[0];
	}
	else
	{
	    # (3) retrieve name of jni file
	    $jni_header_filename[$index] = "_jni/";
	    $jni_header_filename[$index] .= $ARGV[0];
	    $jni_header_filename[$index] =~ s/\./_/g;
	    $jni_header_filename[$index] .= ".h";

	    # (4) store class "path" of jni
	    $jni_class_path[$index] = $ARGV[0];
	    $jni_class_path[$index] =~ s/\./\//g;

	    # (5) compose native "name" of jni array entry
	    $jni_native_methods[$index] = "&";
	    $jni_native_methods[$index] .= $ARGV[0];
	    $jni_native_methods[$index] =~ s/\./_/g;
	    $jni_native_methods[$index] .= "_natives[0]";

	    $index++;
	}

	shift;
    }

############################################################################
# (II) Generate header file containing native method registration material #
############################################################################

    # (A) If it exists, remove the old header file
    #     prior to regenerating a new header file

    if( -e $generated_header_filename )
    {
	unlink $generated_header_filename;
    }

    # (B) Create a new file that will contain all
    #     native method registration material

    open( FD, ">>$generated_header_filename" );

    # (C) Compose header section of new file

    #     (1) print the static portion
    print( FD "/**-- DO NOT EDIT THIS FILE. IT IS MACHINE GENERATED --**/\n" );
    print( FD "#include <jni.h>\n\n" );

    #     (2) print the computed portion
    for( $index = 0; $index < scalar( @jni_header_filename ); $index++ )
    {
	print( FD "#include \"$jni_header_filename[$index]\"\n" );
    }

    print( FD "\n" );

    # (D) Process all jni files

    for( $index = 0; $index < scalar( @jni_header_filename ); $index++ )
    {
	# (1) initialize $class, $method, $signature,
	#     $jnimethod, and $jnimethod_count
	$class     = "";
	$method    = "";
	$signature = "";
	$jnimethod = "";

	$jnimethod_count[$index] = 0;

	# (2) open this jni file
	open( JNIFD, $jni_header_filename[$index] );

	# (3) process first value of "Class:" in this jni file
	while( $line = <JNIFD> )
	{
	    if( $line =~ /Class:/ )
	    {
		# (a) remove all trailing white space
		$line =~ s/\s*$//;

		# (b) assign relevant portion of "Class:" string
		$class = substr( $line, rindex( $line, " " ) + 1 );

		# (c) print "Class:" string to file as an array name
		print( FD "const JNINativeMethod ", $class, "_natives[] =\n" );
		print( FD "{\n" );

		# (d) break
		last;
	    }
	}

	# (4) process each value of "Method:", "Signature:",
	#     and "JNIEXPORT" in this jni file
	while( $line = <JNIFD> )
	{
	    if( $line =~ /Method:/ )
	    {
		# (a) remove all trailing white space
		$line =~ s/\s*$//;

		# (b) assign relevant portion of "Method:" string
		$method = substr( $line, rindex( $line, " " ) + 1 );
	    }
	    elsif( $line =~ /Signature:/ )
	    {
		# (c) remove all trailing white space
		$line =~ s/\s*$//;

		# (d) assign relevant portion of "Signature:" string
		$signature = substr( $line, rindex( $line, " " ) + 1 );
	    }
	    elsif( $line =~ /JNIEXPORT/ )
	    {
		# (e) remove all trailing white space
		$line =~ s/\s*$//;

		# (f) assign relevant portion of "JNIEXPORT" string
		$jnimethod = substr( $line, rindex( $line, " " ) + 1 );
	    }

	    # (5) construct array entry from $method,
	    #     $signature, and $jnimethod
	    if( ( $method ne "" ) &&
		( $signature ne "" ) &&
		( $jnimethod ne "" ) )
	    {
		# (a) print an array value
		print( FD "    {\"", $method, "\", " );
		print( FD "\"", $signature, "\", " );
		print( FD "(void *)", $jnimethod, "},\n" );

		# (b) increment the total number of
		#     JNI methods for this file
		$jnimethod_count[$index]++;

		# (c) reset $method, $signature,
		#     and $jnimethod to be empty
		$method    = "";
		$signature = "";
		$jnimethod = "";
	    }
	}

	# (5) terminate this native JNI methods array
	print( FD "    0\n" );
	print( FD "};\n\n" );

	# (6) close this jni file
	close( JNIFD );

	# (7) move to next jni file
	shift;
    }

    # (E) Compose footer section of new file

    #     (1) print the static portion
    print( FD "struct native_methods {\n" );
    print( FD "	char *classname;\n" );
    print( FD "	int  nmethods;\n" );
    print( FD "	const JNINativeMethod *nat_methods;\n" );
    print( FD "} nativeMethods[] =\n" );
    print( FD "{\n" );

    #     (2) print the computed portion
    for( $index = 0; $index < scalar( @jni_header_filename ); $index++ )
    {
	print( FD "  {\"$jni_class_path[$index]\", " );
	print( FD "$jnimethod_count[$index], " );
	print( FD "$jni_native_methods[$index]},\n" );
    }

    #     (3) terminate the footer
    print( FD "  0\n" );
    print( FD "};\n\n" );

    # (F) Close the new file that now contains all
    #     native method registration material

    close( FD );

