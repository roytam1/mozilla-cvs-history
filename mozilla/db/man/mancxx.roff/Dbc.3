.ds TYPE CXX
.\"
.\" See the file LICENSE for redistribution information.
.\"
.\" Copyright (c) 1997, 1998
.\"	Sleepycat Software.  All rights reserved.
.\"
.\"	@(#)Dbc.sox	10.11 (Sleepycat) 4/10/98
.\"
.\"
.\" See the file LICENSE for redistribution information.
.\"
.\" Copyright (c) 1997, 1998
.\"	Sleepycat Software.  All rights reserved.
.\"
.\"	@(#)macros.so	10.45 (Sleepycat) 5/4/98
.\"
.\" We don't want hyphenation for any HTML documents.
.ie '\*[HTML]'YES'\{\
.nh
\}
.el\{\
.ds Hy
.hy
..
.ds Nh
.nh
..
\}
.\" The alternative text macro
.\" This macro takes two arguments:
.\"	+ the text produced if this is a "C" manpage
.\"	+ the text produced if this is a "CXX" or "JAVA" manpage
.\"
.de Al
.ie '\*[TYPE]'C'\{\\$1
\}
.el\{\\$2
\}
..
.\" Scoped name macro.
.\" Produces a_b, a::b, a.b depending on language
.\" This macro takes two arguments:
.\"	+ the class or prefix (without underscore)
.\"	+ the name within the class or following the prefix
.de Sc
.ie '\*[TYPE]'C'\{\\$1_\\$2
\}
.el\{\
.ie '\*[TYPE]'CXX'\{\\$1::\\$2
\}
.el\{\\$1.\\$2
\}
\}
..
.\" Scoped name for Java.
.\" Produces Db.b, for Java, otherwise just b.  This macro is used for
.\" constants that must be scoped in Java, but are global otherwise.
.\" This macro takes two arguments:
.\"	+ the class
.\"	+ the name within the class or following the prefix
.de Sj
.ie '\*[TYPE]'JAVA'\{\
.TP 5
Db.\\$1\}
.el\{\
.TP 5
\\$1\}
..
.\" The general information text macro.
.de Gn
.ie '\*[TYPE]'C'\{The DB library is a family of groups of functions that provides a modular
programming interface to transactions and record-oriented file access.
The library includes support for transactions, locking, logging and file
page caching, as well as various indexed access methods.
Many of the functional groups (e.g., the file page caching functions)
are useful independent of the other DB functions,
although some functional groups are explicitly based on other functional
groups (e.g., transactions and logging).
\}
.el\{The DB library is a family of classes that provides a modular
programming interface to transactions and record-oriented file access.
The library includes support for transactions, locking, logging and file
page caching, as well as various indexed access methods.
Many of the classes (e.g., the file page caching class)
are useful independent of the other DB classes,
although some classes are explicitly based on other classes
(e.g., transactions and logging).
\}
For a general description of the DB package, see
.IR db_intro (3).
..
.\" The library error macro, the local error macro.
.\" These macros take one argument:
.\"	+ the function name.
.de Ee
The
.I \\$1
.ie '\*[TYPE]'C'\{function may fail and return
.I errno
\}
.el\{method may fail and throw a
.IR DbException (3)
.if '\*[TYPE]'CXX'\{
or return
.I errno
\}
\}
for any of the errors specified for the following DB and library functions:
..
.de Ec
In addition, the
.I \\$1
.ie '\*[TYPE]'C'\{function may fail and return
.I errno
\}
.el\{method may fail and throw a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or return
.I errno
\}
.el\{encapsulating an
.I errno
\}
\}
for the following conditions:
..
.de Ea
[EAGAIN]
A lock was unavailable.
..
.de Eb
[EBUSY]
The shared memory region was in use and the force flag was not set.
..
.de Em
[EAGAIN]
The shared memory region was locked and (repeatedly) unavailable.
..
.de Ei
[EINVAL]
An invalid flag value or parameter was specified.
..
.de Es
[EACCES]
An attempt was made to modify a read-only database.
..
.de Et
The DB_THREAD flag was specified and spinlocks are not implemented for
this architecture.
..
.de Ep
[EPERM]
Database corruption was detected.
All subsequent database calls (other than
.ie '\*[TYPE]'C'\{\
.IR DB->close )
\}
.el\{\
.IR Db::close )
\}
will return EPERM.
..
.de Ek
.if '\*[TYPE]'CXX'\{\
Methods marked as returning
.I errno
will, by default, throw an exception that encapsulates the error information.
The default error behavior can be changed, see
.IR DbException (3).
\}
..
.\" The SEE ALSO text macro
.de Sa
.\" make the line long for nroff.
.if n .ll 72
.nh
.na
.IR db_archive (1),
.IR db_checkpoint (1),
.IR db_deadlock (1),
.IR db_dump (1),
.IR db_load (1),
.IR db_recover (1),
.IR db_stat (1),
.IR db_intro (3),
.ie '\*[TYPE]'C'\{\
.IR db_appinit (3),
.IR db_cursor (3),
.IR db_dbm (3),
.IR db_internal (3),
.IR db_lock (3),
.IR db_log (3),
.IR db_mpool (3),
.IR db_open (3),
.IR db_thread (3),
.IR db_txn (3)
\}
.el\{\
.IR db_internal (3),
.IR db_thread (3),
.IR Db (3),
.IR Dbc (3),
.IR DbEnv (3),
.IR DbException (3),
.IR DbInfo (3),
.IR DbLock (3),
.IR DbLockTab (3),
.IR DbLog (3),
.IR DbLsn (3),
.IR DbMpool (3),
.if !'\*[TYPE]'JAVA'\{\
.IR DbMpoolFile (3),
\}
.IR Dbt (3),
.IR DbTxn (3),
.IR DbTxnMgr (3)
\}
.ad
.Hy
..
.\" The function header macro.
.\" This macro takes one argument:
.\"	+ the function name.
.de Fn
.in 2
.I \\$1
.in
..
.\" The XXX_open function text macro, for merged create/open calls.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix, e.g., "txn" (or the class name for C++, e.g., "DbTxn")
.de Co
.ie '\*[TYPE]'C'\{\
.Fn \\$2_open
The
.I \\$2_open
function copies a pointer, to the \\$1 identified by the
.B directory
.IR dir ,
into the memory location referenced by
.IR regionp .
.PP
If the
.I dbenv
argument to
.I \\$2_open
was initialized using
.IR db_appinit ,
.I dir
is interpreted as described by
.IR db_appinit (3).
\}
.el\{\
.Fn \\$2::open
The
.I \\$2::open
.ie '\*[TYPE]'CXX'\{\
method copies a pointer, to the \\$1 identified by the
.B directory
.IR dir ,
into the memory location referenced by
.IR regionp .
\}
.el\{\
method returns a \\$1 identified by the
.B directory
.IR dir .
\}
.PP
If the
.I dbenv
argument to
.I \\$2::open
was initialized using
.IR DbEnv::appinit ,
.I dir
is interpreted as described by
.IR DbEnv (3).
\}
.PP
Otherwise,
if
.I dir
is not NULL,
it is interpreted relative to the current working directory of the process.
If
.I dir
is NULL,
the following environment variables are checked in order:
``TMPDIR'', ``TEMP'', and ``TMP''.
If one of them is set,
\\$1 files are created relative to the directory it specifies.
If none of them are set, the first possible one of the following
directories is used:
.IR /var/tmp ,
.IR /usr/tmp ,
.IR /temp ,
.IR /tmp ,
.I C:/temp
and
.IR C:/tmp .
.PP
All files associated with the \\$1 are created in this directory.
This directory must already exist when
.ie '\*[TYPE]'C'\{
\\$1_open
\}
.el\{\
\\$2::open
\}
is called.
If the \\$1 already exists,
the process must have permission to read and write the existing files.
If the \\$1 does not already exist,
it is optionally created and initialized.
..
.\" The common close language macro, for discarding created regions
.\" This macro takes one argument:
.\"	+ the function prefix, e.g., txn (the class name for C++, e.g., DbTxn)
.de Cc
In addition, if the
.I dir
argument to
.ie '\*[TYPE]'C'\{\
.ds Va db_appinit
.ds Vo \\$1_open
.ds Vu \\$1_unlink
\}
.el\{\
.ds Va DbEnv::appinit
.ds Vo \\$1::open
.ds Vu \\$1::unlink
\}
.I \\*(Vo
was NULL
and
.I dbenv
was not initialized using
.IR \\*(Va ,
.if '\\$1'memp'\{\
or the DB_MPOOL_PRIVATE flag was set,
\}
all files created for this shared region will be removed,
as if
.I \\*(Vu
were called.
.rm Va
.rm Vo
.rm Vu
..
.\" The DB_ENV information macro.
.\" This macro takes two arguments:
.\"	+ the function called to open, e.g., "txn_open"
.\"	+ the function called to close, e.g., "txn_close"
.de En
.ie '\*[TYPE]'C'\{\
based on the
.I dbenv
argument to
.IR \\$1 ,
which is a pointer to a structure of type DB_ENV (typedef'd in <db.h>).
Applications will normally use the same DB_ENV structure (initialized
by
.IR db_appinit (3)),
as an argument to all of the subsystems in the DB package.
.PP
References to the DB_ENV structure are maintained by DB,
so it may not be discarded until the last close function,
corresponding to an open function for which it was an argument,
has returned.
In order to ensure compatibility with future releases of DB, all fields of
the DB_ENV structure that are not explicitly set should be initialized to 0
before the first time the structure is used.
Do this by declaring the structure external or static, or by calling the C
library routine
.IR bzero (3)
or
.IR memset (3).
.PP
The fields of the DB_ENV structure used by
.I \\$1
are described below.
.if '\*[TYPE]'CXX'\{\
As references to the DB_ENV structure may be maintained by
.IR \\$1 ,
it is necessary that the DB_ENV structure and memory it references be valid
until the
.I \\$2
function is called.
\}
.ie '\\$1'db_appinit'\{The
.I dbenv
argument may not be NULL.
If any of the fields of the
.I dbenv
are set to 0,
defaults appropriate for the system are used where possible.
\}
.el\{If
.I dbenv
is NULL
or any of its fields are set to 0,
defaults appropriate for the system are used where possible.
\}
.PP
The following fields in the DB_ENV structure may be initialized before calling
.IR \\$1 :
\}
.el\{\
based on which set methods have been used.
It is expected that applications will use a single DbEnv object as the
argument to all of the subsystems in the DB package.
The fields of the DbEnv object used by
.I \\$1
are described below.
As references to the DbEnv object may be maintained by
.IR \\$1 ,
it is necessary that the DbEnv object and memory it references be valid
until the object is destroyed.
.ie '\\$1'appinit'\{\
The
.I dbenv
argument may not be NULL.
If any of the fields of the
.I dbenv
are set to 0,
defaults appropriate for the system are used where possible.
\}
.el\{\
Any of the DbEnv fields that are not explicitly set will default to
appropriate values.
\}
.PP
The following fields in the DbEnv object may be initialized, using the
appropriate set method, before calling
.IR \\$1 :
\}
..
.\" The DB_ENV common fields macros.
.de Se
.if '\*[TYPE]'JAVA'\{\
.TP 5
DbErrcall db_errcall;
.ns
.TP 5
String db_errpfx;
.ns
.TP 5
int db_verbose;
The error fields of the DbEnv behave as described for
.IR DbEnv (3).
\}
.ie '\*[TYPE]'CXX'\{\
.TP 5
void *(*db_errcall)(char *db_errpfx, char *buffer);
.ns
.TP 5
FILE *db_errfile;
.ns
.TP 5
const char *db_errpfx;
.ns
.TP 5
class ostream *db_error_stream;
.ns
.TP 5
int db_verbose;
The error fields of the DbEnv behave as described for
.IR DbEnv (3).
\}
.el\{\
void *(*db_errcall)(char *db_errpfx, char *buffer);
.ns
.TP 5
FILE *db_errfile;
.ns
.TP 5
const char *db_errpfx;
.ns
.TP 5
int db_verbose;
The error fields of the DB_ENV behave as described for
.IR db_appinit (3).
.sp
\}
..
.\" The open flags.
.de Fm
The
.I flags
and
.I mode
arguments specify how files will be opened and/or created when they
don't already exist.
The flags value is specified by
.BR or 'ing
together one or more of the following values:
.Sj DB_CREATE
Create any underlying files, as necessary.
If the files do not already exist and the DB_CREATE flag is not specified,
the call will fail.
..
.\" DB_THREAD open flag macro.
.\" This macro takes two arguments:
.\"	+ the open function name
.\"	+ the object it returns.
.de Ft
.TP 5
.Sj DB_THREAD
Cause the \\$2 handle returned by the
.I \\$1
.Al function method
to be useable by multiple threads within a single address space,
i.e., to be ``free-threaded''.
.if '\*[TYPE]'JAVA'\{\
Threading is assumed in the Java API,
so no special flags are required,
and DB functions will always behave as if the DB_THREAD flag was specified.
\}
..
.\" The mode macro.
.\" This macro takes one argument:
.\"	+ the subsystem name.
.de Mo
All files created by the \\$1 are created with mode
.I mode
(as described in
.IR chmod (2))
and modified by the process' umask value at the time of creation (see
.IR umask (2)).
The group ownership of created files is based on the system and directory
defaults, and is not further specified by DB.
..
.\" The application exits macro.
.\" This macro takes one argument:
.\"	+ the application name.
.de Ex
The
.I \\$1
utility exits 0 on success, and >0 if an error occurs.
..
.\" The application -h section.
.\" This macro takes one argument:
.\"	+ the application name
.de Dh
DB_HOME
If the
.B \-h
option is not specified and the environment variable
.I DB_HOME
is set, it is used as the path of the database home, as described in
.IR db_appinit (3).
..
.\" The function DB_HOME ENVIRONMENT VARIABLES section.
.\" This macro takes one argument:
.\"	+ the open function name
.de Eh
DB_HOME
If the
.I dbenv
argument to
.I \\$1
was initialized using
.IR db_appinit ,
the environment variable DB_HOME may be used as the path of the database
home for the interpretation of the
.I dir
argument to
.IR \\$1 ,
as described in
.IR db_appinit (3).
.if \\n(.$>1 \{Specifically,
.I \\$1
is affected by the configuration string value of \\$2.\}
..
.\" The function TMPDIR ENVIRONMENT VARIABLES section.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix, e.g., "txn" (or the class name for C++, e.g., "DbTxn")
.de Ev
TMPDIR
If the
.I dbenv
argument to
.ie '\*[TYPE]'C'\{\
.ds Vo \\$2_open
\}
.el\{\
.ds Vo \\$2::open
\}
.I \\*(Vo
was NULL or not initialized using
.IR db_appinit ,
the environment variable TMPDIR may be used as the directory in which to
create the \\$1,
as described in the
.I \\*(Vo
section above.
.rm Vo
..
.\" The unused flags macro.
.de Fl
The
.I flags
parameter is currently unused, and must be set to 0.
..
.\" The no-space TP macro.
.de Nt
.br
.ns
.TP 5
..
.\" The return values of the functions macros.
.\" Rc is the standard two-value return with a suffix for more values.
.\" Ro is the standard two-value return but there were previous values.
.\" Rt is the standard two-value return, returning errno, 0, or < 0.
.\" These macros take one argument:
.\"	+ the routine name
.de Rc
The
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure,
0 on success,
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure,
0 on success,
\}
.el\{that encapsulates an
.I errno
on failure,
\}
\}
..
.de Ro
Otherwise, the
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure and 0 on success.
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure and 0 on success.
\}
.el\{that encapsulates an
.I errno
on failure,
\}
\}
..
.de Rt
The
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure and 0 on success.
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure and 0 on success.
\}
.el\{that encapsulates an
.I errno
on failure.
\}
\}
..
.\" The TXN id macro.
.de Tx
.IP
If the file is being accessed under transaction protection,
the
.I txnid
parameter is a transaction ID returned from
.IR txn_begin ,
otherwise, NULL.
..
.\" The XXX_unlink function text macro.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix (for C++, this is the class name)
.de Un
.ie '\*[TYPE]'C'\{\
.ds Va db_appinit
.ds Vc \\$2_close
.ds Vo \\$2_open
.ds Vu \\$2_unlink
\}
.el\{\
.ds Va DbEnv::appinit
.ds Vc \\$2::close
.ds Vo \\$2::open
.ds Vu \\$2::unlink
\}
.Fn \\*(Vu
The
.I \\*(Vu
.Al function method
destroys the \\$1 identified by the directory
.IR dir ,
removing all files used to implement the \\$1.
.ie '\\$2'log' \{(The log files themselves and the directory
.I dir
are not removed.)\}
.el \{(The directory
.I dir
is not removed.)\}
If there are processes that have called
.I \\*(Vo
without calling
.I \\*(Vc
(i.e., there are processes currently using the \\$1),
.I \\*(Vu
will fail without further action,
unless the force flag is set,
in which case
.I \\*(Vu
will attempt to remove the \\$1 files regardless of any processes
still using the \\$1.
.PP
The result of attempting to forcibly destroy the region when a process
has the region open is unspecified.
Processes using a shared memory region maintain an open file descriptor
for it.
On UNIX systems, the region removal should succeed
and processes that have already joined the region should continue to
run in the region without change,
however processes attempting to join the \\$1 will either fail or
attempt to create a new region.
On other systems, e.g., WNT, where the
.IR unlink (2)
system call will fail if any process has an open file descriptor
for the file,
the region removal will fail.
.PP
In the case of catastrophic or system failure,
database recovery must be performed (see
.IR db_recover (1)
or the DB_RECOVER and DB_RECOVER_FATAL flags to
.IR \\*(Va (3)).
Alternatively, if recovery is not required because no database state is
maintained across failures,
it is possible to clean up a \\$1 by removing all of the
files in the directory specified to the
.I \\*(Vo
.Al function, method,
as \\$1 files are never created in any directory other than the one
specified to
.IR \\*(Vo .
Note, however,
that this has the potential to remove files created by the other DB
subsystems in this database environment.
.PP
.Rt \\*(Vu
.rm Va
.rm Vo
.rm Vu
.rm Vc
..
.\" Signal paragraph for standard utilities.
.\" This macro takes one argument:
.\"	+ the utility name.
.de Si
The
.I \\$1
utility attaches to DB shared memory regions.
In order to avoid region corruption,
it should always be given the chance to detach and exit gracefully.
To cause
.I \\$1
to clean up after itself and exit,
send it an interrupt signal (SIGINT).
..
.\" Logging paragraph for standard utilities.
.\" This macro takes one argument:
.\"	+ the utility name.
.de Pi
.B \-L
Log the execution of the \\$1 utility to the specified file in the
following format, where ``###'' is the process ID, and the date is
the time the utility starting running.
.sp
\\$1: ### Wed Jun 15 01:23:45 EDT 1995
.sp
This file will be removed if the \\$1 utility exits gracefully.
..
.\" Malloc paragraph.
.\" This macro takes one argument:
.\"	+ the allocated object
.de Ma
.if !'\*[TYPE]'JAVA'\{\
\\$1 are created in allocated memory.
If
.I db_malloc
is non-NULL,
it is called to allocate the memory,
otherwise,
the library function
.IR malloc (3)
is used.
The function
.I db_malloc
must match the calling conventions of the
.IR malloc (3)
library routine.
Regardless,
the caller is responsible for deallocating the returned memory.
To deallocate the returned memory,
free each returned memory pointer;
pointers inside the memory do not need to be individually freed.
\}
..
.\" Underlying function paragraph.
.\" This macro takes two arguments:
.\"	+ the function name
.\"	+ the utility name
.de Uf
The
.I \\$1
.Al function method
is the underlying function used by the
.IR \\$2 (1)
utility.
See the source code for the
.I \\$2
utility for an example of using
.I \\$1
in a UNIX environment.
..
.\" Underlying function paragraph, for C++.
.\" This macro takes three arguments:
.\"	+ the C++ method name
.\"	+ the function name for C
.\"	+ the utility name
.de Ux
The
.I \\$1
method is based on the C
.I \\$2
function, which
is the underlying function used by the
.IR \\$3 (1)
utility.
See the source code for the
.I \\$3
utility for an example of using
.I \\$2
in a UNIX environment.
..
.TH Dbc 3 "April 10, 1998"
.UC 7
.SH NAME
Dbc \- database sequential access functions
.SH SYNOPSIS
.nf
.ft B
.ie '\*[TYPE]'CXX'\{
#include <db_cxx.h>

int
Dbc::close(void);

int
Dbc::del(u_int32_t flags);

int
Dbc::get(Dbt *key, Dbt *data, u_int32_t flags);

int
Dbc::put(Dbt *key, Dbt *data, u_int32_t flags);
\}
.el\{\
import com.sleepycat.db.*;

public void close()
.ti +5
throws DbException;

public void del(int flags)
.ti +5
throws DbException;

public int get(Dbt key, Dbt data, int flags)
.ti +5
throws DbException;

public void put(Dbt key, Dbt data, int flags)
.ti +5
throws DbException;
\}
.ft R
.fi
.SH DESCRIPTION
.Gn
.PP
This manual page describes the specific details of the cursor support
for the access methods in
.IR Db(3) .
.PP
The
.I Dbc
functions are the library interface supporting sequential access to the
records stored by the access methods of the Db library.
Cursors are created by calling
.I Db::cursor
method described in
.IR Db (3),
which returns a
.if '\*[TYPE]'CXX'\{\
pointer to a
\}
Dbc object.
.PP
Each cursor maintains positioning information within a set of key/data pairs.
In the presence of transactions, cursors are only valid within the
context of a single transaction, the one specified during the
.I Db::cursor
call described in
.IR Db (3).
All cursor operations will be executed in the context of that transaction.
Before aborting or committing a transaction, all cursors used within that
transaction must be closed.
In the presence of transactions, the application must call
.I DbTxn::abort
if any of the cursor operations returns that a deadlock (EAGAIN) or
system failure occurred.
.PP
When locking is enabled,
page locks are retained between consecutive cursor calls.
For this reason, in the presence of locking,
applications should discard cursors as soon as they are done with them.
Calling the
.I Db::close
method (see
.IR Db (3))
discards any cursors opened in the context of a particular Db object
returned by the
.I Db::open
call.
.PP
The methods of the Dbc are defined as follows:
.TP 5
int Dbc::close();
A method that discards the cursor.
No further references to the Dbc object should be made.
.IP
.Rt Dbc::close
.TP 5
int Dbc::del(u_int32_t flags);
A method that deletes the key/data pair currently
referenced by the cursor.
.IP
.Fl
.IP
The cursor position is unchanged after a delete and subsequent calls
to cursor functions expecting the cursor to reference an existing
key will fail.
.IP
.Rc Dbc::del
and DB_KEYEMPTY if the element has already been deleted.
.ie '\*[TYPE]'CXX'\{\
.TP 5
int Dbc::get(Dbt *key, Dbt *data, u_int32_t flags);
A method that retrieves key/data pairs from the database.
The address
\}
.el\{\
.TP 5
int Dbc::get(Dbt key, Dbt data, int flags);
A method that retrieves key/data pairs from the database.
The byte array
\}
and length of the key are returned in the object referenced by
.I key
(except for the case of the DB_SET flag where the
.I key
object is unchanged), and the
.ie '\*[TYPE]'CXX'\{\
address
\}
.el\{\
byte array
\}
and length of the data are returned in the object
referenced by
.IR data .
.sp
Modifications to the database during a sequential scan will be reflected
in the scan,
i.e. records inserted behind a cursor will not be returned while records
inserted in front of a cursor will be returned.
.sp
In recno databases, missing entries
(i.e., entries that were never explicitly created or that were created
and then deleted),
will be skipped during a sequential scan.
.sp
If multiple threads or processes insert items into the same database file
without using locking, the results are undefined.
For more detail, see the section below on cursor stability.
.IP
The parameter
.I flags
must be set to exactly one of the following values:
.RS
.TP 5
.Sj DB_FIRST
The cursor is set to reference the first key/data pair of the database,
and that pair is returned.
In the presence of duplicate key values,
the first data item in the set of duplicates is returned.
.IP
If the database is empty,
the
.I Dbc::get
method will return DB_NOTFOUND.
.TP 5
.Sj DB_LAST
The cursor is set to reference the last key/data pair of the database,
and that pair is returned.
In the presence of duplicate key values,
the last data item in the set of duplicates is returned.
.IP
If the database is empty,
the
.I Dbc::get
method will return DB_NOTFOUND.
.TP 5
.Sj DB_NEXT
If the cursor is not yet initialized, DB_NEXT is identical to DB_FIRST.
.IP
Otherwise,
move the cursor to the next key/data pair of the database,
and that pair is returned.
In the presence of duplicate key values,
the value of the key may not change.
.IP
If the cursor is already on the last record in the database,
the
.I Dbc::get
method will return DB_NOTFOUND.
.TP 5
.Sj DB_PREV
If the cursor is not yet initialized, DB_PREV is identical to DB_LAST.
.IP
Otherwise,
move the cursor to the previous key/data pair of the database,
and that pair is returned.
In the presence of duplicate key values,
the value of the key may not change.
.IP
If the cursor is already on the first record in the database,
the
.I Dbc::get
method will return DB_NOTFOUND.
.TP 5
.Sj DB_CURRENT
Return the key/data pair currently referenced by the cursor.
.IP
If the cursor key/data pair has been deleted,
the
.I Dbc::get
method will return DB_KEYEMPTY.
.IP
If the cursor is not yet initialized,
the
.I Dbc::get
method will return EINVAL.
.TP 5
.Sj DB_SET
Move the cursor to the specified key/data pair of the database,
and return the datum associated with the given key.
.IP
In the presence of duplicate key values,
.I Dbc::get
will return the first data item for the given key.
.IP
If the database is a recno database and the requested key exists,
but was never explicitly created by the application or was later
deleted, the
.I Dbc::get
method returns DB_KEYEMPTY.
.IP
If no matching keys are found,
the
.I Dbc::get
method will return DB_NOTFOUND.
.TP 5
.Sj DB_SET_RANGE
The DB_SET_RANGE flag is identical to the DB_SET flag,
except that the key is returned as well as the data item,
and, in the case of the btree access method,
the returned key/data pair is the smallest key greater than or
equal to the specified key (as determined by the comparison function),
permitting partial key matches and range searches.
.TP 5
.Sj DB_SET_RECNO
Move the cursor to the specific numbered record of the database,
and return the associated key/data pair.
The
.I data
field of the specified
.I key
.ie '\*[TYPE]'CXX'\{\
must be a pointer to a memory location from which a
.I db_recno_t
may be read, as described in
.IR Dbt (3).
This memory location will be read to determine the record to be retrieved.
\}
.el\{\
must be a byte array containing a record number,
as described in
.IR Dbt (3).
This determines the record to be retrieved.
\}
.sp
For DB_SET_RECNO to be specified, the underlying database must be of type
btree and it must have been created with the DB_RECNUM flag (see
.I Db::open
in
.IR Db (3)).
.TP 5
.Sj DB_GET_RECNO
Return the record number associated with the cursor.
The record number
will be returned in the data Dbt as described in
.IR Dbt (3).
The
.I key
parameter is ignored.
.sp
For DB_GET_RECNO to be specified, the underlying database must be of type
btree and it must have been created with the DB_RECNUM flag (see
.I Db::open
in
.IR Db (3)).
.RE
.IP
.Ro Dbc::get
.IP
If
.I Dbc::get
fails for any reason, the state of the cursor will be unchanged.
.TP 5
.ie '\*[TYPE]'CXX'\{\
int Dbc::put(Dbt *key, Dbt *data, u_int32_t flags);
\}
.el\{\
int Dbc::put(Dbt key, Dbt data, int flags);
\}
A method that stores key/data pairs into the database.
.IP
The
.I flags
parameter must be set to exactly one of the following values:
.RS
.TP 5
.Sj DB_AFTER
In the case of the btree and hash access methods,
insert the data element as a duplicate element of the key referenced
by the cursor.
The new element appears immediately after the current cursor position.
It is an error to specify DB_AFTER if the underlying btree or hash database
was not created with the DB_DUP flag.
The
.I key
parameter is ignored.
.IP
In the case of the recno access method,
it is an error to specify DB_AFTER if the underlying recno database was
not created with the DB_RENUMBER flag.
If the DB_RENUMBER flag was specified, a new key is created,
all records after the inserted item are automatically renumbered,
and the key of the new record is returned in the object referenced
by the parameter
.IR key .
The initial value of the
.I key
parameter is ignored.
See
.I Db::open
in
.IR Db (3)
for more information.
.IP
If the cursor is not yet initialized,
the
.I Dbc::put
method will return EINVAL.
.TP 5
.Sj DB_BEFORE
In the case of the btree and hash access methods,
insert the data element as a duplicate element of the key referenced
by the cursor.
The new element appears immediately before the current cursor position.
It is an error to specify DB_BEFORE if the underlying btree or hash database
was not created with the DB_DUP flag.
The
.I key
parameter is ignored.
.IP
In the case of the recno access method,
it is an error to specify DB_BEFORE if the underlying recno database was
not created with the DB_RENUMBER flag.
If the DB_RENUMBER flag was specified, a new key is created,
the current record and all records after it are automatically renumbered,
and the key of the new record is returned in the object referenced by
the parameter
.IR key .
The initial value of the
.I key
parameter is ignored.
See
.I Db::open
in
.IR Db (3)
for more information.
.IP
If the cursor is not yet initialized,
the
.I Dbc::put
method will return EINVAL.
.TP 5
.Sj DB_CURRENT
Overwrite the data of the key/data pair referenced by the cursor with the
specified data item.
.IP
The
.I key
parameter is ignored.
.IP
If the cursor is not yet initialized,
the
.I Dbc::put
method will return EINVAL.
.TP 5
.Sj DB_KEYFIRST
In the case of the btree and hash access methods,
insert the specified key/data pair into the database.
If the key already exists in the database,
the inserted data item is added as the first of the data items for that key.
.IP
The DB_KEYFIRST flag may not be specified to the recno access method.
.TP 5
.Sj DB_KEYLAST
Insert the specified key/data pair into the database.
If the key already exists in the database,
the inserted data item is added as the last of the data items for that key.
.IP
The DB_KEYLAST flag may not be specified to the recno access method.
.RE
.IP
If the cursor record has been deleted,
the
.I Dbc::put
method will return DB_KEYEMPTY.
.IP
.Ro Dbc::put
.IP
If
.I Dbc::put
fails for any reason, the state of the cursor will be unchanged.
If
.I Dbc::put
succeeds and an item is inserted into the database,
the cursor is always positioned to reference the newly inserted item.
.SH "CURSOR STABILITY"
.PP
In the absence of locking, no guarantees are made about the stability
of cursors in different processes or threads.
However,
the btree and recno access methods guarantee that cursor operations,
interspersed with other cursor or non-cursor operations in the same
thread of control (i.e., thread or single-threaded process),
will always return keys in order and will return each non-deleted
key/data pair exactly once.
Because the hash access method uses a dynamic hashing algorithm,
it cannot guarantee any form of stability in the presence of inserts and
deletes unless locking is performed.
.PP
If locking was specified when the Db file was opened,
but transactions are not in effect,
the access methods provide repeatable reads with respect to the cursor.
That is, a DB_CURRENT call on the cursor is guaranteed to return the same
record as was returned on the last call to the cursor.
.PP
In the presence of transactions, the access method calls between
.I DbTxnMgr::begin
and
.I DbTxn::abort
or
.I DbTxn::commit
provide degree 3 consistency.
For all access methods,
a cursor scan of the database performed within the context of a transaction
is guaranteed to return each key/data pair once and only once,
except in the following case.
If, while performing a cursor scan using the hash access method,
the transaction performing the scan inserts a new pair into the database,
it is possible that duplicate key/data pairs will be returned.
.SH ERRORS
.Ek
.PP
.Ee Dbc::close
.na
.Nh
DbLock::get(3), 
DbLock::put(3), 
DbLockTab::id(3), 
DbLockTab::vec(3), 
DbLog::put(3), 
DbMpoolFile::get(3), 
DbMpoolFile::put(3), 
DbMpoolFile::set(3), 
calloc(3), 
fcntl(2), 
fflush(3), 
malloc(3), 
memcpy(3), 
memmove(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec Dbc::close
.TP 5
.Ea
.TP 5
.Ep
.PP
.Ee Dbc::del
.na
.Nh
Db::del(3), 
DbLock::get(3), 
DbLock::put(3), 
DbLockTab::id(3), 
DbLockTab::vec(3), 
DbLog::put(3), 
DbMpoolFile::get(3), 
DbMpoolFile::put(3), 
DbMpoolFile::set(3), 
calloc(3), 
fcntl(2), 
fflush(3), 
malloc(3), 
memcpy(3), 
memmove(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec Dbc::del
.TP 5
.Ea
.TP 5
.Ei
.TP 5
.Ep
.PP
.Ee Dbc::get
.na
.Nh
Db::get(3), 
DbLock::get(3), 
DbLock::put(3), 
DbLockTab::id(3), 
DbLockTab::vec(3), 
DbLog::put(3), 
DbMpoolFile::get(3), 
DbMpoolFile::put(3), 
DbMpoolFile::set(3), 
calloc(3), 
fcntl(2), 
fflush(3), 
malloc(3), 
memcmp(3), 
memcpy(3), 
memmove(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec Dbc::get
.TP 5
.Ea
.TP 5
.Ei
.sp
The DB_THREAD flag was specified to the
.I Db::open
method
described in
.IR Db (3)
and neither the DB_DBT_MALLOC or DB_DBT_USERMEM flags were set
in the Dbt.
.TP 5
.Ep
.PP
.Ee Dbc::put
.na
.Nh
DbLock::get(3), 
DbLock::put(3), 
DbLockTab::id(3), 
DbLockTab::vec(3), 
DbLog::put(3), 
DbMpoolFile::get(3), 
DbMpoolFile::put(3), 
DbMpoolFile::set(3), 
calloc(3), 
fcntl(2), 
fflush(3), 
malloc(3), 
memcmp(3), 
memcpy(3), 
memmove(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec Dbc::put
.TP 5
.Es
.TP 5
.Ea
.TP 5
.Ei
.TP 5
.Ep
.SH "SEE ALSO"
.Sa
