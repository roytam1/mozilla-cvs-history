.ds TYPE CXX
.\"
.\" See the file LICENSE for redistribution information.
.\"
.\" Copyright (c) 1997, 1998
.\"	Sleepycat Software.  All rights reserved.
.\"
.\"	@(#)Dbt.sox	10.10 (Sleepycat) 4/10/98
.\"
.\"
.\" See the file LICENSE for redistribution information.
.\"
.\" Copyright (c) 1997, 1998
.\"	Sleepycat Software.  All rights reserved.
.\"
.\"	@(#)macros.so	10.45 (Sleepycat) 5/4/98
.\"
.\" We don't want hyphenation for any HTML documents.
.ie '\*[HTML]'YES'\{\
.nh
\}
.el\{\
.ds Hy
.hy
..
.ds Nh
.nh
..
\}
.\" The alternative text macro
.\" This macro takes two arguments:
.\"	+ the text produced if this is a "C" manpage
.\"	+ the text produced if this is a "CXX" or "JAVA" manpage
.\"
.de Al
.ie '\*[TYPE]'C'\{\\$1
\}
.el\{\\$2
\}
..
.\" Scoped name macro.
.\" Produces a_b, a::b, a.b depending on language
.\" This macro takes two arguments:
.\"	+ the class or prefix (without underscore)
.\"	+ the name within the class or following the prefix
.de Sc
.ie '\*[TYPE]'C'\{\\$1_\\$2
\}
.el\{\
.ie '\*[TYPE]'CXX'\{\\$1::\\$2
\}
.el\{\\$1.\\$2
\}
\}
..
.\" Scoped name for Java.
.\" Produces Db.b, for Java, otherwise just b.  This macro is used for
.\" constants that must be scoped in Java, but are global otherwise.
.\" This macro takes two arguments:
.\"	+ the class
.\"	+ the name within the class or following the prefix
.de Sj
.ie '\*[TYPE]'JAVA'\{\
.TP 5
Db.\\$1\}
.el\{\
.TP 5
\\$1\}
..
.\" The general information text macro.
.de Gn
.ie '\*[TYPE]'C'\{The DB library is a family of groups of functions that provides a modular
programming interface to transactions and record-oriented file access.
The library includes support for transactions, locking, logging and file
page caching, as well as various indexed access methods.
Many of the functional groups (e.g., the file page caching functions)
are useful independent of the other DB functions,
although some functional groups are explicitly based on other functional
groups (e.g., transactions and logging).
\}
.el\{The DB library is a family of classes that provides a modular
programming interface to transactions and record-oriented file access.
The library includes support for transactions, locking, logging and file
page caching, as well as various indexed access methods.
Many of the classes (e.g., the file page caching class)
are useful independent of the other DB classes,
although some classes are explicitly based on other classes
(e.g., transactions and logging).
\}
For a general description of the DB package, see
.IR db_intro (3).
..
.\" The library error macro, the local error macro.
.\" These macros take one argument:
.\"	+ the function name.
.de Ee
The
.I \\$1
.ie '\*[TYPE]'C'\{function may fail and return
.I errno
\}
.el\{method may fail and throw a
.IR DbException (3)
.if '\*[TYPE]'CXX'\{
or return
.I errno
\}
\}
for any of the errors specified for the following DB and library functions:
..
.de Ec
In addition, the
.I \\$1
.ie '\*[TYPE]'C'\{function may fail and return
.I errno
\}
.el\{method may fail and throw a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or return
.I errno
\}
.el\{encapsulating an
.I errno
\}
\}
for the following conditions:
..
.de Ea
[EAGAIN]
A lock was unavailable.
..
.de Eb
[EBUSY]
The shared memory region was in use and the force flag was not set.
..
.de Em
[EAGAIN]
The shared memory region was locked and (repeatedly) unavailable.
..
.de Ei
[EINVAL]
An invalid flag value or parameter was specified.
..
.de Es
[EACCES]
An attempt was made to modify a read-only database.
..
.de Et
The DB_THREAD flag was specified and spinlocks are not implemented for
this architecture.
..
.de Ep
[EPERM]
Database corruption was detected.
All subsequent database calls (other than
.ie '\*[TYPE]'C'\{\
.IR DB->close )
\}
.el\{\
.IR Db::close )
\}
will return EPERM.
..
.de Ek
.if '\*[TYPE]'CXX'\{\
Methods marked as returning
.I errno
will, by default, throw an exception that encapsulates the error information.
The default error behavior can be changed, see
.IR DbException (3).
\}
..
.\" The SEE ALSO text macro
.de Sa
.\" make the line long for nroff.
.if n .ll 72
.nh
.na
.IR db_archive (1),
.IR db_checkpoint (1),
.IR db_deadlock (1),
.IR db_dump (1),
.IR db_load (1),
.IR db_recover (1),
.IR db_stat (1),
.IR db_intro (3),
.ie '\*[TYPE]'C'\{\
.IR db_appinit (3),
.IR db_cursor (3),
.IR db_dbm (3),
.IR db_internal (3),
.IR db_lock (3),
.IR db_log (3),
.IR db_mpool (3),
.IR db_open (3),
.IR db_thread (3),
.IR db_txn (3)
\}
.el\{\
.IR db_internal (3),
.IR db_thread (3),
.IR Db (3),
.IR Dbc (3),
.IR DbEnv (3),
.IR DbException (3),
.IR DbInfo (3),
.IR DbLock (3),
.IR DbLockTab (3),
.IR DbLog (3),
.IR DbLsn (3),
.IR DbMpool (3),
.if !'\*[TYPE]'JAVA'\{\
.IR DbMpoolFile (3),
\}
.IR Dbt (3),
.IR DbTxn (3),
.IR DbTxnMgr (3)
\}
.ad
.Hy
..
.\" The function header macro.
.\" This macro takes one argument:
.\"	+ the function name.
.de Fn
.in 2
.I \\$1
.in
..
.\" The XXX_open function text macro, for merged create/open calls.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix, e.g., "txn" (or the class name for C++, e.g., "DbTxn")
.de Co
.ie '\*[TYPE]'C'\{\
.Fn \\$2_open
The
.I \\$2_open
function copies a pointer, to the \\$1 identified by the
.B directory
.IR dir ,
into the memory location referenced by
.IR regionp .
.PP
If the
.I dbenv
argument to
.I \\$2_open
was initialized using
.IR db_appinit ,
.I dir
is interpreted as described by
.IR db_appinit (3).
\}
.el\{\
.Fn \\$2::open
The
.I \\$2::open
.ie '\*[TYPE]'CXX'\{\
method copies a pointer, to the \\$1 identified by the
.B directory
.IR dir ,
into the memory location referenced by
.IR regionp .
\}
.el\{\
method returns a \\$1 identified by the
.B directory
.IR dir .
\}
.PP
If the
.I dbenv
argument to
.I \\$2::open
was initialized using
.IR DbEnv::appinit ,
.I dir
is interpreted as described by
.IR DbEnv (3).
\}
.PP
Otherwise,
if
.I dir
is not NULL,
it is interpreted relative to the current working directory of the process.
If
.I dir
is NULL,
the following environment variables are checked in order:
``TMPDIR'', ``TEMP'', and ``TMP''.
If one of them is set,
\\$1 files are created relative to the directory it specifies.
If none of them are set, the first possible one of the following
directories is used:
.IR /var/tmp ,
.IR /usr/tmp ,
.IR /temp ,
.IR /tmp ,
.I C:/temp
and
.IR C:/tmp .
.PP
All files associated with the \\$1 are created in this directory.
This directory must already exist when
.ie '\*[TYPE]'C'\{
\\$1_open
\}
.el\{\
\\$2::open
\}
is called.
If the \\$1 already exists,
the process must have permission to read and write the existing files.
If the \\$1 does not already exist,
it is optionally created and initialized.
..
.\" The common close language macro, for discarding created regions
.\" This macro takes one argument:
.\"	+ the function prefix, e.g., txn (the class name for C++, e.g., DbTxn)
.de Cc
In addition, if the
.I dir
argument to
.ie '\*[TYPE]'C'\{\
.ds Va db_appinit
.ds Vo \\$1_open
.ds Vu \\$1_unlink
\}
.el\{\
.ds Va DbEnv::appinit
.ds Vo \\$1::open
.ds Vu \\$1::unlink
\}
.I \\*(Vo
was NULL
and
.I dbenv
was not initialized using
.IR \\*(Va ,
.if '\\$1'memp'\{\
or the DB_MPOOL_PRIVATE flag was set,
\}
all files created for this shared region will be removed,
as if
.I \\*(Vu
were called.
.rm Va
.rm Vo
.rm Vu
..
.\" The DB_ENV information macro.
.\" This macro takes two arguments:
.\"	+ the function called to open, e.g., "txn_open"
.\"	+ the function called to close, e.g., "txn_close"
.de En
.ie '\*[TYPE]'C'\{\
based on the
.I dbenv
argument to
.IR \\$1 ,
which is a pointer to a structure of type DB_ENV (typedef'd in <db.h>).
Applications will normally use the same DB_ENV structure (initialized
by
.IR db_appinit (3)),
as an argument to all of the subsystems in the DB package.
.PP
References to the DB_ENV structure are maintained by DB,
so it may not be discarded until the last close function,
corresponding to an open function for which it was an argument,
has returned.
In order to ensure compatibility with future releases of DB, all fields of
the DB_ENV structure that are not explicitly set should be initialized to 0
before the first time the structure is used.
Do this by declaring the structure external or static, or by calling the C
library routine
.IR bzero (3)
or
.IR memset (3).
.PP
The fields of the DB_ENV structure used by
.I \\$1
are described below.
.if '\*[TYPE]'CXX'\{\
As references to the DB_ENV structure may be maintained by
.IR \\$1 ,
it is necessary that the DB_ENV structure and memory it references be valid
until the
.I \\$2
function is called.
\}
.ie '\\$1'db_appinit'\{The
.I dbenv
argument may not be NULL.
If any of the fields of the
.I dbenv
are set to 0,
defaults appropriate for the system are used where possible.
\}
.el\{If
.I dbenv
is NULL
or any of its fields are set to 0,
defaults appropriate for the system are used where possible.
\}
.PP
The following fields in the DB_ENV structure may be initialized before calling
.IR \\$1 :
\}
.el\{\
based on which set methods have been used.
It is expected that applications will use a single DbEnv object as the
argument to all of the subsystems in the DB package.
The fields of the DbEnv object used by
.I \\$1
are described below.
As references to the DbEnv object may be maintained by
.IR \\$1 ,
it is necessary that the DbEnv object and memory it references be valid
until the object is destroyed.
.ie '\\$1'appinit'\{\
The
.I dbenv
argument may not be NULL.
If any of the fields of the
.I dbenv
are set to 0,
defaults appropriate for the system are used where possible.
\}
.el\{\
Any of the DbEnv fields that are not explicitly set will default to
appropriate values.
\}
.PP
The following fields in the DbEnv object may be initialized, using the
appropriate set method, before calling
.IR \\$1 :
\}
..
.\" The DB_ENV common fields macros.
.de Se
.if '\*[TYPE]'JAVA'\{\
.TP 5
DbErrcall db_errcall;
.ns
.TP 5
String db_errpfx;
.ns
.TP 5
int db_verbose;
The error fields of the DbEnv behave as described for
.IR DbEnv (3).
\}
.ie '\*[TYPE]'CXX'\{\
.TP 5
void *(*db_errcall)(char *db_errpfx, char *buffer);
.ns
.TP 5
FILE *db_errfile;
.ns
.TP 5
const char *db_errpfx;
.ns
.TP 5
class ostream *db_error_stream;
.ns
.TP 5
int db_verbose;
The error fields of the DbEnv behave as described for
.IR DbEnv (3).
\}
.el\{\
void *(*db_errcall)(char *db_errpfx, char *buffer);
.ns
.TP 5
FILE *db_errfile;
.ns
.TP 5
const char *db_errpfx;
.ns
.TP 5
int db_verbose;
The error fields of the DB_ENV behave as described for
.IR db_appinit (3).
.sp
\}
..
.\" The open flags.
.de Fm
The
.I flags
and
.I mode
arguments specify how files will be opened and/or created when they
don't already exist.
The flags value is specified by
.BR or 'ing
together one or more of the following values:
.Sj DB_CREATE
Create any underlying files, as necessary.
If the files do not already exist and the DB_CREATE flag is not specified,
the call will fail.
..
.\" DB_THREAD open flag macro.
.\" This macro takes two arguments:
.\"	+ the open function name
.\"	+ the object it returns.
.de Ft
.TP 5
.Sj DB_THREAD
Cause the \\$2 handle returned by the
.I \\$1
.Al function method
to be useable by multiple threads within a single address space,
i.e., to be ``free-threaded''.
.if '\*[TYPE]'JAVA'\{\
Threading is assumed in the Java API,
so no special flags are required,
and DB functions will always behave as if the DB_THREAD flag was specified.
\}
..
.\" The mode macro.
.\" This macro takes one argument:
.\"	+ the subsystem name.
.de Mo
All files created by the \\$1 are created with mode
.I mode
(as described in
.IR chmod (2))
and modified by the process' umask value at the time of creation (see
.IR umask (2)).
The group ownership of created files is based on the system and directory
defaults, and is not further specified by DB.
..
.\" The application exits macro.
.\" This macro takes one argument:
.\"	+ the application name.
.de Ex
The
.I \\$1
utility exits 0 on success, and >0 if an error occurs.
..
.\" The application -h section.
.\" This macro takes one argument:
.\"	+ the application name
.de Dh
DB_HOME
If the
.B \-h
option is not specified and the environment variable
.I DB_HOME
is set, it is used as the path of the database home, as described in
.IR db_appinit (3).
..
.\" The function DB_HOME ENVIRONMENT VARIABLES section.
.\" This macro takes one argument:
.\"	+ the open function name
.de Eh
DB_HOME
If the
.I dbenv
argument to
.I \\$1
was initialized using
.IR db_appinit ,
the environment variable DB_HOME may be used as the path of the database
home for the interpretation of the
.I dir
argument to
.IR \\$1 ,
as described in
.IR db_appinit (3).
.if \\n(.$>1 \{Specifically,
.I \\$1
is affected by the configuration string value of \\$2.\}
..
.\" The function TMPDIR ENVIRONMENT VARIABLES section.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix, e.g., "txn" (or the class name for C++, e.g., "DbTxn")
.de Ev
TMPDIR
If the
.I dbenv
argument to
.ie '\*[TYPE]'C'\{\
.ds Vo \\$2_open
\}
.el\{\
.ds Vo \\$2::open
\}
.I \\*(Vo
was NULL or not initialized using
.IR db_appinit ,
the environment variable TMPDIR may be used as the directory in which to
create the \\$1,
as described in the
.I \\*(Vo
section above.
.rm Vo
..
.\" The unused flags macro.
.de Fl
The
.I flags
parameter is currently unused, and must be set to 0.
..
.\" The no-space TP macro.
.de Nt
.br
.ns
.TP 5
..
.\" The return values of the functions macros.
.\" Rc is the standard two-value return with a suffix for more values.
.\" Ro is the standard two-value return but there were previous values.
.\" Rt is the standard two-value return, returning errno, 0, or < 0.
.\" These macros take one argument:
.\"	+ the routine name
.de Rc
The
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure,
0 on success,
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure,
0 on success,
\}
.el\{that encapsulates an
.I errno
on failure,
\}
\}
..
.de Ro
Otherwise, the
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure and 0 on success.
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure and 0 on success.
\}
.el\{that encapsulates an
.I errno
on failure,
\}
\}
..
.de Rt
The
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure and 0 on success.
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure and 0 on success.
\}
.el\{that encapsulates an
.I errno
on failure.
\}
\}
..
.\" The TXN id macro.
.de Tx
.IP
If the file is being accessed under transaction protection,
the
.I txnid
parameter is a transaction ID returned from
.IR txn_begin ,
otherwise, NULL.
..
.\" The XXX_unlink function text macro.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix (for C++, this is the class name)
.de Un
.ie '\*[TYPE]'C'\{\
.ds Va db_appinit
.ds Vc \\$2_close
.ds Vo \\$2_open
.ds Vu \\$2_unlink
\}
.el\{\
.ds Va DbEnv::appinit
.ds Vc \\$2::close
.ds Vo \\$2::open
.ds Vu \\$2::unlink
\}
.Fn \\*(Vu
The
.I \\*(Vu
.Al function method
destroys the \\$1 identified by the directory
.IR dir ,
removing all files used to implement the \\$1.
.ie '\\$2'log' \{(The log files themselves and the directory
.I dir
are not removed.)\}
.el \{(The directory
.I dir
is not removed.)\}
If there are processes that have called
.I \\*(Vo
without calling
.I \\*(Vc
(i.e., there are processes currently using the \\$1),
.I \\*(Vu
will fail without further action,
unless the force flag is set,
in which case
.I \\*(Vu
will attempt to remove the \\$1 files regardless of any processes
still using the \\$1.
.PP
The result of attempting to forcibly destroy the region when a process
has the region open is unspecified.
Processes using a shared memory region maintain an open file descriptor
for it.
On UNIX systems, the region removal should succeed
and processes that have already joined the region should continue to
run in the region without change,
however processes attempting to join the \\$1 will either fail or
attempt to create a new region.
On other systems, e.g., WNT, where the
.IR unlink (2)
system call will fail if any process has an open file descriptor
for the file,
the region removal will fail.
.PP
In the case of catastrophic or system failure,
database recovery must be performed (see
.IR db_recover (1)
or the DB_RECOVER and DB_RECOVER_FATAL flags to
.IR \\*(Va (3)).
Alternatively, if recovery is not required because no database state is
maintained across failures,
it is possible to clean up a \\$1 by removing all of the
files in the directory specified to the
.I \\*(Vo
.Al function, method,
as \\$1 files are never created in any directory other than the one
specified to
.IR \\*(Vo .
Note, however,
that this has the potential to remove files created by the other DB
subsystems in this database environment.
.PP
.Rt \\*(Vu
.rm Va
.rm Vo
.rm Vu
.rm Vc
..
.\" Signal paragraph for standard utilities.
.\" This macro takes one argument:
.\"	+ the utility name.
.de Si
The
.I \\$1
utility attaches to DB shared memory regions.
In order to avoid region corruption,
it should always be given the chance to detach and exit gracefully.
To cause
.I \\$1
to clean up after itself and exit,
send it an interrupt signal (SIGINT).
..
.\" Logging paragraph for standard utilities.
.\" This macro takes one argument:
.\"	+ the utility name.
.de Pi
.B \-L
Log the execution of the \\$1 utility to the specified file in the
following format, where ``###'' is the process ID, and the date is
the time the utility starting running.
.sp
\\$1: ### Wed Jun 15 01:23:45 EDT 1995
.sp
This file will be removed if the \\$1 utility exits gracefully.
..
.\" Malloc paragraph.
.\" This macro takes one argument:
.\"	+ the allocated object
.de Ma
.if !'\*[TYPE]'JAVA'\{\
\\$1 are created in allocated memory.
If
.I db_malloc
is non-NULL,
it is called to allocate the memory,
otherwise,
the library function
.IR malloc (3)
is used.
The function
.I db_malloc
must match the calling conventions of the
.IR malloc (3)
library routine.
Regardless,
the caller is responsible for deallocating the returned memory.
To deallocate the returned memory,
free each returned memory pointer;
pointers inside the memory do not need to be individually freed.
\}
..
.\" Underlying function paragraph.
.\" This macro takes two arguments:
.\"	+ the function name
.\"	+ the utility name
.de Uf
The
.I \\$1
.Al function method
is the underlying function used by the
.IR \\$2 (1)
utility.
See the source code for the
.I \\$2
utility for an example of using
.I \\$1
in a UNIX environment.
..
.\" Underlying function paragraph, for C++.
.\" This macro takes three arguments:
.\"	+ the C++ method name
.\"	+ the function name for C
.\"	+ the utility name
.de Ux
The
.I \\$1
method is based on the C
.I \\$2
function, which
is the underlying function used by the
.IR \\$3 (1)
utility.
See the source code for the
.I \\$3
utility for an example of using
.I \\$2
in a UNIX environment.
..
.TH Dbt 3 "April 10, 1998"
.UC 7
.SH NAME
Dbt \- Db key/data class
.SH SYNOPSIS
.nf
.ft B
.ie '\*[TYPE]'CXX'\{
void *Dbt::get_data() const;
void Dbt::set_data(void *);

u_int32_t Dbt::get_size() const;
void Dbt::set_size(u_int32_t);

u_int32_t Dbt::get_ulen() const;
void Dbt::set_ulen(u_int32_t);

u_int32_t Dbt::get_dlen() const;
void Dbt::set_dlen(u_int32_t);

u_int32_t Dbt::get_doff() const;
void Dbt::set_doff(u_int32_t);

u_int32_t Dbt::get_flags() const;
void Dbt::set_flags(u_int32_t);

Dbt::Dbt(void *data, size_t size);
Dbt::Dbt();
Dbt::~Dbt();
Dbt::Dbt(const Dbt &);
Dbt::Dbt &operator = (const Dbt &);
\}
.el\{\
import com.sleepycat.db.*;

public Dbt();
public Dbt(byte[] data);
public Dbt(byte[] data, int off, int len);

public void set_data(byte[] data);
public byte[] get_data();

public void set_offset(int off);
public int get_offset();

public int get_size();
public void set_size(int size);

public int get_ulen();
public void set_ulen(int ulen);

public int get_dlen();
public void set_dlen(int dlen);

public int get_doff();
public void set_doff(int doff);

public int get_flags();
public void set_flags(int flags);

public void set_recno_key_data(int recno);
public int get_recno_key_data();
\}
.ft R
.fi
.SH "DESCRIPTION
.Gn
This manual page describes the specific details of the
.I Dbt
class, used to encode keys and data items in a database.
.PP
.SH "KEY/DATA PAIRS
Storage and retrieval for the Db access methods are based on key/data pairs.
Both key and data items are represented by Dbt objects.
.PP
Key and data byte strings may reference strings of essentially unlimited
length,
although any two keys must fit into available memory at the same time so
that they may be compared,
and any one data item must fit into available memory so that it may be
returned.
.PP
The Dbt class provides simple access to an underlying data structure,
whose elements can be examined or changed using the
.I set_
or
.I get_
methods.  The remainder of the manual page sometimes
refers to these accesses using the underlying name, e.g., simply
.I ulen
instead of
.I get_ulen
and
.IR set_ulen .
The constructors set all elements of the underlying structure to zero.
The constructor with two arguments has the effect of setting all elements
to zero except for the specified
.I data
and
.I size
elements.
In the case where the
.I flags
structure element is 0,
when being provided a key or data item by the application,
the DB package expects the
.I data
object to
.ie '\*[TYPE]'CXX'\{\
point to a byte string of
\}
.el\{\
be set to a byte array of
\}
.I size
bytes.
When returning a key/data item to the application,
the DB package will store into the
.I data
object a
.ie '\*[TYPE]'CXX'\{\
pointer to a byte string
\}
.el\{\
a byte array
\}
of
.I size
bytes.
.if '\*[TYPE]'CXX'\{\
.ft B
By default,
the memory referenced by this stored pointer is only valid until the next
call to the DB package using the Db handle returned by
.IR Db::open .
.ft R
\}
.PP
.ft B
The access methods provide no guarantees about byte string alignment,
and applications are responsible for maintaining any necessary alignment.
.ft R
Use the DB_DBT_USERMEM flag to cause returned items to be placed in memory
of arbitrary alignment.
.if '\*[TYPE]'CXX'\{\
Although Java normally maintains proper alignment of byte arrays,
the set_offset method can be used to specify unaligned addresses.
Unaligned address accesses that are not supported by the underlying
hardware may be reported as an exception, or may stop the running
Java program.
\}
.PP
The elements of the structure underlying the Dbt class are defined as follows:
.ie '\*[TYPE]'CXX'\{\
.TP 5
void *data;
A pointer to a byte string.
\}
.el\{\
.TP 5
byte[] data;
A byte array containing the data.
\}
This element is accessed using
.I get_data
and
.IR set_data ,
and may be initialized using one of the constructors.
.if '\*[TYPE]'JAVA'\{\
Note that the array data is not copied immediately,
but only when the Dbt is used.
\}
.ns
.br
.TP 5
int offset;
The number of bytes offset into the
.I data
array to determine the portion of the array actually used.
This element is accessed using
.I get_offset
and
.IR set_offset .
.TP 5
.ie '\*[TYPE]'CXX'\{\
u_int32_t size;\}
.el\{\
int size;\}
The length of
.IR data ,
in bytes.
This element is accessed using
.I get_size
and
.IR set_size ,
and may be initialized
.ie '\*[TYPE]'CXX'\{\
using the constructor with two arguments.
\}
.el\{\
implicitly to the length of the data array
with the constructor having one argument.
\}
.TP 5
.ie '\*[TYPE]'CXX'\{\
u_int32_t ulen;\}
.el\{\
int ulen;\}
The size of the user's buffer (referenced by
.IR data ),
in bytes.
This location is not written by the Db functions.
See the DB_DBT_USERMEM flag for more information.
This element is accessed using
.I get_ulen
and
.IR set_ulen .
.TP 5
.ie '\*[TYPE]'CXX'\{\
u_int32_t dlen;\}
.el\{\
int dlen;\}
The length of the partial record being read or written by the application,
in bytes.
See the DB_DBT_PARTIAL flag for more information.
This element is accessed using
.I get_dlen
and
.IR set_dlen .
.TP 5
.ie '\*[TYPE]'CXX'\{\
u_int32_t doff;\}
.el\{\
int doff;\}
The offset of the partial record being read or written by the application,
in bytes.
See the DB_DBT_PARTIAL flag for more information.
This element is accessed using
.I get_doff
and
.IR set_doff .
.TP 5
.ie '\*[TYPE]'CXX'\{\
u_int32_t flags;\}
.el\{\
int flags;\}
This element is accessed using
.I get_flags
and
.IR set_flags .
The flags value is specified by
.BR or 'ing
together one or more of the following values:
.RS
.TP 5
.Sj DB_DBT_MALLOC
Ignored except when retrieving information from a database, e.g., a
.I Db::get
or
.I Dbc::get
call.
This flag causes Db to allocate memory for the returned key or data
item
.ie '\*[TYPE]'CXX'\{\
(using
.IR malloc (3),
or the user-specified malloc method)
and return a pointer to it in the
.I data
field of the key or data Dbt object.
The allocated memory becomes the responsibility of the calling application.
\}
.el\{\
and return a
byte array containing the data in the
.I data
field of the key or data Dbt object.
\}
It is an error to specify both DB_DBT_MALLOC and DB_DBT_USERMEM.
.TP 5
.Sj DB_DBT_USERMEM
Ignored except when retrieving information from a database, e.g., a
.I Db::get
or
.I Dbc::get
call.
The
.I data
field of the key or data object must reference memory that is at least
.I ulen
bytes in length.
If the length of the requested item is less than or equal to that number
of bytes,
the item is copied into the memory referenced by the
.I data
field.
Otherwise, an error is returned, the
.I size
field is set to the length needed for the requested item,
and the
.I errno
variable is set to ENOMEM.
It is an error to specify both DB_DBT_MALLOC and DB_DBT_USERMEM.
.TP 5
.Sj DB_DBT_PARTIAL
Ignored except when specified for a data parameter,
where this flag causes the partial retrieval or storage of an item.
If the calling application is doing a get, the
.I dlen
bytes starting
.I doff
bytes from the beginning of the retrieved data record are returned
as if they comprised the entire record.
If any or all of the specified bytes do not exist in the record,
the get is successful and the existing bytes or 0 bytes are returned.
.sp
For example, if the data portion of a retrieved record was 100 bytes,
and a partial retrieval was done using a Dbt having a
.I dlen
field of 20 and a
.I doff
field of 85,
the get call would succeed,
the
.I data
field would reference the last 15 bytes of the record,
and the
.I size
field would be set to 15.
.sp
If the calling application is doing a put,
the
.I dlen
bytes starting
.I doff
bytes from the beginning of the specified key's data record are replaced
by the data specified by the
.I data
and
.I size
objects.
If
.I dlen
is smaller than
.IR size ,
the record will grow, and if
.I dlen
is larger than
.IR size ,
the record will shrink.
If the specified bytes do not exist,
the record will be extended using nul bytes as necessary,
and the put call will succeed.
.sp
It is an error to attempt a partial put using the
.I Db::put
method in a database that supports duplicate records.
Partial puts in databases supporting duplicate records must be done
using a
.I Db::cursor
method.
It is an error to attempt a partial put with differing
.I dlen
and
.I size
values in a recno database with fixed-length records.
.sp
For example, if the data portion of a retrieved record was 100 bytes,
and a partial put was done using a Dbt having a
.I dlen
field of 20,
a
.I doff
field of 85,
and a
.I size
field of 30,
the resulting record would be 115 bytes in length, where the last 30
bytes would be those specified by the put call.
.RE
.PP
The default algorithm of associating returned key or data items with the
Db handle returned by
.IR Db::open (3)
will obviously not work when Db handles are being used concurrently by
multiple threads within a process, i.e, when DB_THREAD was specified to
.IR Db::open (3).
.ft B
When multiple threads are using the returned Db handle concurrently,
either the DB_DBT_MALLOC or DB_DBT_USERMEM flags must be specified
for any Dbt used for key or data retrieval.
.ft R
.if '\*[TYPE]'JAVA'\{
.PP
.ft B
For this reason,
when using the JAVA DB API, either the DB_DBT_MALLOC or DB_DBT_USERMEM
flags must be specified for any Dbt used for key or data retrieval.
.ft R
If DB_DBT_USERMEM is specified, the data field of the Dbt must be set
to an appropriately sized byte array.
.PP
If DB_DBT_MALLOC is specified, DB allocates a properly sized byte
array to contain the data.  This can be convenient if you know little
about the nature of the data, specifically the size of data in the
database.  However, if your application makes repeated calls to
retrieve keys or data, you may notice increased garbage collection due
to this allocation.  If you know the maximum size of data you are
retrieving, you might decrease the memory burden and speed your
application by allocating your own byte array and using DB_DBT_USERMEM.
Even if you don't know the maximum size, you can use this option
and reallocate your array whenever your retrieval API call returns
an ENOMEM error.
\}
.SH "LOGICAL RECORD NUMBERS
In all cases for the recno access method,
and when calling the
.I Db::get
and
.I Dbc::get
functions with the DB_GET_RECNO flag specified, the
.I data
.ie '\*[TYPE]'CXX'\{
field of the key must be a pointer to a memory location of type
.IR db_recno_t ,
as typedef'd in the <db_cxx.h> include file.
This type is a 32-bit unsigned type,
\}
.el\{\
field of the key must be a four byte array, large enough
to store an int.  The
.I set_recno_key_data
method can be used to set the value of the array.
An int is a 32-bit type,
\}
(which limits the number of logical records in a recno database,
and the maximum logical record which may be directly retrieved
from a btree database, to 4,294,967,296).
The
.I size
field of the key should be the size of that type, e.g.,
.ie '\*[TYPE]'CXX'\{
in the C programming language, ``sizeof(db_recno_t)''.
\}
.el\{\
4.
\}
.sp
Logical record numbers are 1-based, not 0-based, i.e., the first record
in the database is record number 1.
.SH BUGS
The Db access methods provide no guarantees about byte string alignment,
and applications are responsible for maintaining any necessary alignment.
.PP
The name Dbt is a mnemonic for ``data base thang'', and was used because
noone could think of a reasonable name that wasn't already in use somewhere
else.
.SH "SEE ALSO"
.Sa
