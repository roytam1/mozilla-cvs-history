.ds TYPE C
.\"
.\" See the file LICENSE for redistribution information.
.\"
.\" Copyright (c) 1996, 1997, 1998
.\"	Sleepycat Software.  All rights reserved.
.\"
.\" Copyright (c) 1990, 1993, 1994
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)db_open.so	10.55 (Sleepycat) 5/3/98
.\"
.\"
.\" See the file LICENSE for redistribution information.
.\"
.\" Copyright (c) 1997, 1998
.\"	Sleepycat Software.  All rights reserved.
.\"
.\"	@(#)macros.so	10.45 (Sleepycat) 5/4/98
.\"
.\" We don't want hyphenation for any HTML documents.
.ie '\*[HTML]'YES'\{\
.nh
\}
.el\{\
.ds Hy
.hy
..
.ds Nh
.nh
..
\}
.\" The alternative text macro
.\" This macro takes two arguments:
.\"	+ the text produced if this is a "C" manpage
.\"	+ the text produced if this is a "CXX" or "JAVA" manpage
.\"
.de Al
.ie '\*[TYPE]'C'\{\\$1
\}
.el\{\\$2
\}
..
.\" Scoped name macro.
.\" Produces a_b, a::b, a.b depending on language
.\" This macro takes two arguments:
.\"	+ the class or prefix (without underscore)
.\"	+ the name within the class or following the prefix
.de Sc
.ie '\*[TYPE]'C'\{\\$1_\\$2
\}
.el\{\
.ie '\*[TYPE]'CXX'\{\\$1::\\$2
\}
.el\{\\$1.\\$2
\}
\}
..
.\" Scoped name for Java.
.\" Produces Db.b, for Java, otherwise just b.  This macro is used for
.\" constants that must be scoped in Java, but are global otherwise.
.\" This macro takes two arguments:
.\"	+ the class
.\"	+ the name within the class or following the prefix
.de Sj
.ie '\*[TYPE]'JAVA'\{\
.TP 5
Db.\\$1\}
.el\{\
.TP 5
\\$1\}
..
.\" The general information text macro.
.de Gn
.ie '\*[TYPE]'C'\{The DB library is a family of groups of functions that provides a modular
programming interface to transactions and record-oriented file access.
The library includes support for transactions, locking, logging and file
page caching, as well as various indexed access methods.
Many of the functional groups (e.g., the file page caching functions)
are useful independent of the other DB functions,
although some functional groups are explicitly based on other functional
groups (e.g., transactions and logging).
\}
.el\{The DB library is a family of classes that provides a modular
programming interface to transactions and record-oriented file access.
The library includes support for transactions, locking, logging and file
page caching, as well as various indexed access methods.
Many of the classes (e.g., the file page caching class)
are useful independent of the other DB classes,
although some classes are explicitly based on other classes
(e.g., transactions and logging).
\}
For a general description of the DB package, see
.IR db_intro (3).
..
.\" The library error macro, the local error macro.
.\" These macros take one argument:
.\"	+ the function name.
.de Ee
The
.I \\$1
.ie '\*[TYPE]'C'\{function may fail and return
.I errno
\}
.el\{method may fail and throw a
.IR DbException (3)
.if '\*[TYPE]'CXX'\{
or return
.I errno
\}
\}
for any of the errors specified for the following DB and library functions:
..
.de Ec
In addition, the
.I \\$1
.ie '\*[TYPE]'C'\{function may fail and return
.I errno
\}
.el\{method may fail and throw a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or return
.I errno
\}
.el\{encapsulating an
.I errno
\}
\}
for the following conditions:
..
.de Ea
[EAGAIN]
A lock was unavailable.
..
.de Eb
[EBUSY]
The shared memory region was in use and the force flag was not set.
..
.de Em
[EAGAIN]
The shared memory region was locked and (repeatedly) unavailable.
..
.de Ei
[EINVAL]
An invalid flag value or parameter was specified.
..
.de Es
[EACCES]
An attempt was made to modify a read-only database.
..
.de Et
The DB_THREAD flag was specified and spinlocks are not implemented for
this architecture.
..
.de Ep
[EPERM]
Database corruption was detected.
All subsequent database calls (other than
.ie '\*[TYPE]'C'\{\
.IR DB->close )
\}
.el\{\
.IR Db::close )
\}
will return EPERM.
..
.de Ek
.if '\*[TYPE]'CXX'\{\
Methods marked as returning
.I errno
will, by default, throw an exception that encapsulates the error information.
The default error behavior can be changed, see
.IR DbException (3).
\}
..
.\" The SEE ALSO text macro
.de Sa
.\" make the line long for nroff.
.if n .ll 72
.nh
.na
.IR db_archive (1),
.IR db_checkpoint (1),
.IR db_deadlock (1),
.IR db_dump (1),
.IR db_load (1),
.IR db_recover (1),
.IR db_stat (1),
.IR db_intro (3),
.ie '\*[TYPE]'C'\{\
.IR db_appinit (3),
.IR db_cursor (3),
.IR db_dbm (3),
.IR db_internal (3),
.IR db_lock (3),
.IR db_log (3),
.IR db_mpool (3),
.IR db_open (3),
.IR db_thread (3),
.IR db_txn (3)
\}
.el\{\
.IR db_internal (3),
.IR db_thread (3),
.IR Db (3),
.IR Dbc (3),
.IR DbEnv (3),
.IR DbException (3),
.IR DbInfo (3),
.IR DbLock (3),
.IR DbLockTab (3),
.IR DbLog (3),
.IR DbLsn (3),
.IR DbMpool (3),
.if !'\*[TYPE]'JAVA'\{\
.IR DbMpoolFile (3),
\}
.IR Dbt (3),
.IR DbTxn (3),
.IR DbTxnMgr (3)
\}
.ad
.Hy
..
.\" The function header macro.
.\" This macro takes one argument:
.\"	+ the function name.
.de Fn
.in 2
.I \\$1
.in
..
.\" The XXX_open function text macro, for merged create/open calls.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix, e.g., "txn" (or the class name for C++, e.g., "DbTxn")
.de Co
.ie '\*[TYPE]'C'\{\
.Fn \\$2_open
The
.I \\$2_open
function copies a pointer, to the \\$1 identified by the
.B directory
.IR dir ,
into the memory location referenced by
.IR regionp .
.PP
If the
.I dbenv
argument to
.I \\$2_open
was initialized using
.IR db_appinit ,
.I dir
is interpreted as described by
.IR db_appinit (3).
\}
.el\{\
.Fn \\$2::open
The
.I \\$2::open
.ie '\*[TYPE]'CXX'\{\
method copies a pointer, to the \\$1 identified by the
.B directory
.IR dir ,
into the memory location referenced by
.IR regionp .
\}
.el\{\
method returns a \\$1 identified by the
.B directory
.IR dir .
\}
.PP
If the
.I dbenv
argument to
.I \\$2::open
was initialized using
.IR DbEnv::appinit ,
.I dir
is interpreted as described by
.IR DbEnv (3).
\}
.PP
Otherwise,
if
.I dir
is not NULL,
it is interpreted relative to the current working directory of the process.
If
.I dir
is NULL,
the following environment variables are checked in order:
``TMPDIR'', ``TEMP'', and ``TMP''.
If one of them is set,
\\$1 files are created relative to the directory it specifies.
If none of them are set, the first possible one of the following
directories is used:
.IR /var/tmp ,
.IR /usr/tmp ,
.IR /temp ,
.IR /tmp ,
.I C:/temp
and
.IR C:/tmp .
.PP
All files associated with the \\$1 are created in this directory.
This directory must already exist when
.ie '\*[TYPE]'C'\{
\\$1_open
\}
.el\{\
\\$2::open
\}
is called.
If the \\$1 already exists,
the process must have permission to read and write the existing files.
If the \\$1 does not already exist,
it is optionally created and initialized.
..
.\" The common close language macro, for discarding created regions
.\" This macro takes one argument:
.\"	+ the function prefix, e.g., txn (the class name for C++, e.g., DbTxn)
.de Cc
In addition, if the
.I dir
argument to
.ie '\*[TYPE]'C'\{\
.ds Va db_appinit
.ds Vo \\$1_open
.ds Vu \\$1_unlink
\}
.el\{\
.ds Va DbEnv::appinit
.ds Vo \\$1::open
.ds Vu \\$1::unlink
\}
.I \\*(Vo
was NULL
and
.I dbenv
was not initialized using
.IR \\*(Va ,
.if '\\$1'memp'\{\
or the DB_MPOOL_PRIVATE flag was set,
\}
all files created for this shared region will be removed,
as if
.I \\*(Vu
were called.
.rm Va
.rm Vo
.rm Vu
..
.\" The DB_ENV information macro.
.\" This macro takes two arguments:
.\"	+ the function called to open, e.g., "txn_open"
.\"	+ the function called to close, e.g., "txn_close"
.de En
.ie '\*[TYPE]'C'\{\
based on the
.I dbenv
argument to
.IR \\$1 ,
which is a pointer to a structure of type DB_ENV (typedef'd in <db.h>).
Applications will normally use the same DB_ENV structure (initialized
by
.IR db_appinit (3)),
as an argument to all of the subsystems in the DB package.
.PP
References to the DB_ENV structure are maintained by DB,
so it may not be discarded until the last close function,
corresponding to an open function for which it was an argument,
has returned.
In order to ensure compatibility with future releases of DB, all fields of
the DB_ENV structure that are not explicitly set should be initialized to 0
before the first time the structure is used.
Do this by declaring the structure external or static, or by calling the C
library routine
.IR bzero (3)
or
.IR memset (3).
.PP
The fields of the DB_ENV structure used by
.I \\$1
are described below.
.if '\*[TYPE]'CXX'\{\
As references to the DB_ENV structure may be maintained by
.IR \\$1 ,
it is necessary that the DB_ENV structure and memory it references be valid
until the
.I \\$2
function is called.
\}
.ie '\\$1'db_appinit'\{The
.I dbenv
argument may not be NULL.
If any of the fields of the
.I dbenv
are set to 0,
defaults appropriate for the system are used where possible.
\}
.el\{If
.I dbenv
is NULL
or any of its fields are set to 0,
defaults appropriate for the system are used where possible.
\}
.PP
The following fields in the DB_ENV structure may be initialized before calling
.IR \\$1 :
\}
.el\{\
based on which set methods have been used.
It is expected that applications will use a single DbEnv object as the
argument to all of the subsystems in the DB package.
The fields of the DbEnv object used by
.I \\$1
are described below.
As references to the DbEnv object may be maintained by
.IR \\$1 ,
it is necessary that the DbEnv object and memory it references be valid
until the object is destroyed.
.ie '\\$1'appinit'\{\
The
.I dbenv
argument may not be NULL.
If any of the fields of the
.I dbenv
are set to 0,
defaults appropriate for the system are used where possible.
\}
.el\{\
Any of the DbEnv fields that are not explicitly set will default to
appropriate values.
\}
.PP
The following fields in the DbEnv object may be initialized, using the
appropriate set method, before calling
.IR \\$1 :
\}
..
.\" The DB_ENV common fields macros.
.de Se
.if '\*[TYPE]'JAVA'\{\
.TP 5
DbErrcall db_errcall;
.ns
.TP 5
String db_errpfx;
.ns
.TP 5
int db_verbose;
The error fields of the DbEnv behave as described for
.IR DbEnv (3).
\}
.ie '\*[TYPE]'CXX'\{\
.TP 5
void *(*db_errcall)(char *db_errpfx, char *buffer);
.ns
.TP 5
FILE *db_errfile;
.ns
.TP 5
const char *db_errpfx;
.ns
.TP 5
class ostream *db_error_stream;
.ns
.TP 5
int db_verbose;
The error fields of the DbEnv behave as described for
.IR DbEnv (3).
\}
.el\{\
void *(*db_errcall)(char *db_errpfx, char *buffer);
.ns
.TP 5
FILE *db_errfile;
.ns
.TP 5
const char *db_errpfx;
.ns
.TP 5
int db_verbose;
The error fields of the DB_ENV behave as described for
.IR db_appinit (3).
.sp
\}
..
.\" The open flags.
.de Fm
The
.I flags
and
.I mode
arguments specify how files will be opened and/or created when they
don't already exist.
The flags value is specified by
.BR or 'ing
together one or more of the following values:
.Sj DB_CREATE
Create any underlying files, as necessary.
If the files do not already exist and the DB_CREATE flag is not specified,
the call will fail.
..
.\" DB_THREAD open flag macro.
.\" This macro takes two arguments:
.\"	+ the open function name
.\"	+ the object it returns.
.de Ft
.TP 5
.Sj DB_THREAD
Cause the \\$2 handle returned by the
.I \\$1
.Al function method
to be useable by multiple threads within a single address space,
i.e., to be ``free-threaded''.
.if '\*[TYPE]'JAVA'\{\
Threading is assumed in the Java API,
so no special flags are required,
and DB functions will always behave as if the DB_THREAD flag was specified.
\}
..
.\" The mode macro.
.\" This macro takes one argument:
.\"	+ the subsystem name.
.de Mo
All files created by the \\$1 are created with mode
.I mode
(as described in
.IR chmod (2))
and modified by the process' umask value at the time of creation (see
.IR umask (2)).
The group ownership of created files is based on the system and directory
defaults, and is not further specified by DB.
..
.\" The application exits macro.
.\" This macro takes one argument:
.\"	+ the application name.
.de Ex
The
.I \\$1
utility exits 0 on success, and >0 if an error occurs.
..
.\" The application -h section.
.\" This macro takes one argument:
.\"	+ the application name
.de Dh
DB_HOME
If the
.B \-h
option is not specified and the environment variable
.I DB_HOME
is set, it is used as the path of the database home, as described in
.IR db_appinit (3).
..
.\" The function DB_HOME ENVIRONMENT VARIABLES section.
.\" This macro takes one argument:
.\"	+ the open function name
.de Eh
DB_HOME
If the
.I dbenv
argument to
.I \\$1
was initialized using
.IR db_appinit ,
the environment variable DB_HOME may be used as the path of the database
home for the interpretation of the
.I dir
argument to
.IR \\$1 ,
as described in
.IR db_appinit (3).
.if \\n(.$>1 \{Specifically,
.I \\$1
is affected by the configuration string value of \\$2.\}
..
.\" The function TMPDIR ENVIRONMENT VARIABLES section.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix, e.g., "txn" (or the class name for C++, e.g., "DbTxn")
.de Ev
TMPDIR
If the
.I dbenv
argument to
.ie '\*[TYPE]'C'\{\
.ds Vo \\$2_open
\}
.el\{\
.ds Vo \\$2::open
\}
.I \\*(Vo
was NULL or not initialized using
.IR db_appinit ,
the environment variable TMPDIR may be used as the directory in which to
create the \\$1,
as described in the
.I \\*(Vo
section above.
.rm Vo
..
.\" The unused flags macro.
.de Fl
The
.I flags
parameter is currently unused, and must be set to 0.
..
.\" The no-space TP macro.
.de Nt
.br
.ns
.TP 5
..
.\" The return values of the functions macros.
.\" Rc is the standard two-value return with a suffix for more values.
.\" Ro is the standard two-value return but there were previous values.
.\" Rt is the standard two-value return, returning errno, 0, or < 0.
.\" These macros take one argument:
.\"	+ the routine name
.de Rc
The
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure,
0 on success,
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure,
0 on success,
\}
.el\{that encapsulates an
.I errno
on failure,
\}
\}
..
.de Ro
Otherwise, the
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure and 0 on success.
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure and 0 on success.
\}
.el\{that encapsulates an
.I errno
on failure,
\}
\}
..
.de Rt
The
.I \\$1
.ie '\*[TYPE]'C'\{function returns the value of
.I errno
on failure and 0 on success.
\}
.el\{method throws a
.IR DbException (3)
.ie '\*[TYPE]'CXX'\{or returns the value of
.I errno
on failure and 0 on success.
\}
.el\{that encapsulates an
.I errno
on failure.
\}
\}
..
.\" The TXN id macro.
.de Tx
.IP
If the file is being accessed under transaction protection,
the
.I txnid
parameter is a transaction ID returned from
.IR txn_begin ,
otherwise, NULL.
..
.\" The XXX_unlink function text macro.
.\" This macro takes two arguments:
.\"	+ the interface, e.g., "transaction region"
.\"	+ the prefix (for C++, this is the class name)
.de Un
.ie '\*[TYPE]'C'\{\
.ds Va db_appinit
.ds Vc \\$2_close
.ds Vo \\$2_open
.ds Vu \\$2_unlink
\}
.el\{\
.ds Va DbEnv::appinit
.ds Vc \\$2::close
.ds Vo \\$2::open
.ds Vu \\$2::unlink
\}
.Fn \\*(Vu
The
.I \\*(Vu
.Al function method
destroys the \\$1 identified by the directory
.IR dir ,
removing all files used to implement the \\$1.
.ie '\\$2'log' \{(The log files themselves and the directory
.I dir
are not removed.)\}
.el \{(The directory
.I dir
is not removed.)\}
If there are processes that have called
.I \\*(Vo
without calling
.I \\*(Vc
(i.e., there are processes currently using the \\$1),
.I \\*(Vu
will fail without further action,
unless the force flag is set,
in which case
.I \\*(Vu
will attempt to remove the \\$1 files regardless of any processes
still using the \\$1.
.PP
The result of attempting to forcibly destroy the region when a process
has the region open is unspecified.
Processes using a shared memory region maintain an open file descriptor
for it.
On UNIX systems, the region removal should succeed
and processes that have already joined the region should continue to
run in the region without change,
however processes attempting to join the \\$1 will either fail or
attempt to create a new region.
On other systems, e.g., WNT, where the
.IR unlink (2)
system call will fail if any process has an open file descriptor
for the file,
the region removal will fail.
.PP
In the case of catastrophic or system failure,
database recovery must be performed (see
.IR db_recover (1)
or the DB_RECOVER and DB_RECOVER_FATAL flags to
.IR \\*(Va (3)).
Alternatively, if recovery is not required because no database state is
maintained across failures,
it is possible to clean up a \\$1 by removing all of the
files in the directory specified to the
.I \\*(Vo
.Al function, method,
as \\$1 files are never created in any directory other than the one
specified to
.IR \\*(Vo .
Note, however,
that this has the potential to remove files created by the other DB
subsystems in this database environment.
.PP
.Rt \\*(Vu
.rm Va
.rm Vo
.rm Vu
.rm Vc
..
.\" Signal paragraph for standard utilities.
.\" This macro takes one argument:
.\"	+ the utility name.
.de Si
The
.I \\$1
utility attaches to DB shared memory regions.
In order to avoid region corruption,
it should always be given the chance to detach and exit gracefully.
To cause
.I \\$1
to clean up after itself and exit,
send it an interrupt signal (SIGINT).
..
.\" Logging paragraph for standard utilities.
.\" This macro takes one argument:
.\"	+ the utility name.
.de Pi
.B \-L
Log the execution of the \\$1 utility to the specified file in the
following format, where ``###'' is the process ID, and the date is
the time the utility starting running.
.sp
\\$1: ### Wed Jun 15 01:23:45 EDT 1995
.sp
This file will be removed if the \\$1 utility exits gracefully.
..
.\" Malloc paragraph.
.\" This macro takes one argument:
.\"	+ the allocated object
.de Ma
.if !'\*[TYPE]'JAVA'\{\
\\$1 are created in allocated memory.
If
.I db_malloc
is non-NULL,
it is called to allocate the memory,
otherwise,
the library function
.IR malloc (3)
is used.
The function
.I db_malloc
must match the calling conventions of the
.IR malloc (3)
library routine.
Regardless,
the caller is responsible for deallocating the returned memory.
To deallocate the returned memory,
free each returned memory pointer;
pointers inside the memory do not need to be individually freed.
\}
..
.\" Underlying function paragraph.
.\" This macro takes two arguments:
.\"	+ the function name
.\"	+ the utility name
.de Uf
The
.I \\$1
.Al function method
is the underlying function used by the
.IR \\$2 (1)
utility.
See the source code for the
.I \\$2
utility for an example of using
.I \\$1
in a UNIX environment.
..
.\" Underlying function paragraph, for C++.
.\" This macro takes three arguments:
.\"	+ the C++ method name
.\"	+ the function name for C
.\"	+ the utility name
.de Ux
The
.I \\$1
method is based on the C
.I \\$2
function, which
is the underlying function used by the
.IR \\$3 (1)
utility.
See the source code for the
.I \\$3
utility for an example of using
.I \\$2
in a UNIX environment.
..
.TH DB_OPEN 3 "May 3, 1998"
.UC 7
.SH NAME
db_open \- database access methods
.SH SYNOPSIS
.nf
.ft B
#include <db.h>

int
db_open(const char *file, DBTYPE type, u_int32_t flags,
.ti +5
int mode, DB_ENV *dbenv, DB_INFO *dbinfo, DB **dbpp);

int
DB->close(DB *db, u_int32_t flags);

int
DB->cursor(DB *db, DB_TXN *txnid, DBC **cursorp);

int
DB->del(DB *db, DB_TXN *txnid, DBT *key, u_int32_t flags);

int
DB->fd(DB *db, int *fdp);

int
DB->get(DB *db, DB_TXN *txnid, DBT *key, DBT *data, u_int32_t flags);

int
DB->put(DB *db, DB_TXN *txnid, DBT *key, DBT *data, u_int32_t flags);

int
DB->sync(DB *db, u_int32_t flags);

int
DB->stat(DB *db, void *sp, void *(*db_malloc)(size_t), u_int32_t flags);
.ft R
.fi
.SH DESCRIPTION
.Gn
.PP
This manual page describes the overall structure of the DB library access
methods.
.PP
The currently supported file formats are btree, hashed and recno.
The btree format is a representation of a sorted, balanced tree structure.
The hashed format is an extensible, dynamic hashing scheme.
The recno format supports fixed or variable length records (optionally
retrieved from a flat text file).
.PP
Storage and retrieval for the DB access methods are based on key/data pairs,
or DBT structures as they are typedef'd in the <db.h> include file.
See
.IR db_dbt (3)
for specific information on the structure and capabilities of a DBT.
.PP
The
.I db_open
function opens the database represented by
.I file
for both reading and writing.
Files never intended to be shared or preserved on disk may be created by
setting the file parameter to NULL.
.PP
The
.I db_open
function copies a pointer to a DB structure (as typedef'd in the <db.h>
include file), into the memory location referenced by
.IR dbpp .
This structure includes a set of functions to perform various database
actions,
as described below.
.Rt db_open
.PP
Note, while most of the access methods use
.I file
as the name of an underlying file on disk,
this is not guaranteed.
Also,
calling
.I db_open
is a reasonably expensive operation.
(This is based on a model where the DBMS keeps a set of files open for a
long time rather than opening and closing them on each query.)
.PP
The
.I type
argument is of type DBTYPE (as defined in the <db.h> include file)
and must be set to one of DB_BTREE, DB_HASH, DB_RECNO or DB_UNKNOWN.
If
.I type
is DB_UNKNOWN,
the database must already exist and
.I db_open
will then determine if it is of type DB_BTREE, DB_HASH or DB_RECNO.
.PP
.Fm
.TP 5
DB_NOMMAP
Do not map this file (see
.IR db_mpool (3)
for further information).
.TP 5
DB_RDONLY
Open the database for reading only.
Any attempt to write the database using the access methods will fail
regardless of the actual permissions of any underlying files.
.Ft db_open DB
.TP 5
DB_TRUNCATE
``Truncate'' the database if it exists, i.e.,
behave as if the database were just created,
discarding any previous contents.
.PP
.Mo "access methods"
.SH DB_ENV
The access methods make calls to the other subsystems in the DB library
.En "db_open" "close"
.TP 5
DB_LOG *lg_info;
If modifications to the file being opened should be logged, the
.I lg_info
field contains a return value from the function
.IR log_open .
If
.I lg_info
is NULL, no logging is done by the DB access methods.
.TP 5
DB_LOCKTAB *lk_info;
If locking is required for the file being opened (as is the case
when multiple processes or threads are accessing the same file),
the
.I lk_info
field contains a return value from the function
.IR lock_open .
If
.I lk_info
is NULL, no locking is done by the DB access methods.
.sp
If both locking and transactions are being performed (i.e., both
.I lk_info
and
.I tx_info
are non-NULL),
the transaction ID will be used as the locker ID.
If only locking is being performed,
.I db_open
will acquire a locker ID from
.IR lock_id (3),
and will use it for all locks required for this instance of
.IR db_open .
.TP 5
DB_MPOOL *mp_info;
If the cache for the file being opened should be maintained in a shared
buffer pool, the
.I mp_info
field contains a return value from the function
.IR memp_open .
If
.I mp_info
is NULL, a memory pool may still be created by DB,
but it will be private to the application and managed by DB.
.TP 5
DB_TXNMGR *tx_info;
If the accesses to the file being opened should take place in the context
of transactions (providing atomicity and error recovery), the
.I tx_info
field contains a return value from the function
.I txn_open
(see
.IR db_txn (3)).
If transactions are specified,
the application is responsible for making suitable calls to
.IR txn_begin ,
.IR txn_abort ,
and
.IR txn_commit .
If
.I tx_info
is NULL,
no transaction support is done by the DB access methods.
.sp
When the access methods are used in conjunction with transactions,
the application must abort the transaction (using
.IR txn_abort )
if any of the transaction protected access method calls (i.e.,
any calls other than open, close and sync) returns a system error
(e.g., deadlock, which returns EAGAIN).
As described by
.IR db_intro (3),
a system error is any value greater than 0.
.SH DB_INFO
The access methods are configured using the DB_INFO data structure
argument to
.IR db_open .
The DB_INFO structure is typedef'd in <db.h> and has a large number
of fields,
most specific to a single access method,
although a few are shared.
The fields that are common to all access methods are listed here;
those specific to an individual access method are described below.
No reference to the DB_INFO structure is maintained by DB,
so it is possible to discard it as soon as the
.I db_open
call returns.
.PP
In order to ensure compatibility with future releases of DB,
all fields of the DB_INFO structure should be initialized to 0 before
the structure is used.
Do this by declaring the structure external or static,
or by calling the C library function
.IR bzero (3)
or
.IR memset (3).
.PP
If possible,
defaults appropriate for the system are used for the DB_INFO fields if
.I dbinfo
is NULL or any fields of the DB_INFO structure are set to 0.
The following DB_INFO fields may be initialized before calling
.IR db_open :
.TP 5
size_t db_cachesize;
A suggested maximum size of the memory pool cache, in bytes.
If
.I db_cachesize
is 0, an appropriate default is used.
It is an error to specify both the
.I mp_info
field and a non-zero
.IR db_cachesize .
.sp
.ft B
Note,
the minimum number of pages in the cache should be no less than 10,
and the access methods will fail if an insufficiently large cache is specified.
.ft R
In addition,
for applications that exhibit strong locality in their data access
patterns,
increasing the size of the cache can significantly improve application
performance.
.TP 5
int db_lorder;
The byte order for integers in the stored database metadata.
The number should represent the order as an integer, for example,
big endian order is the number 4,321, and little endian order is
the number 1,234.
If
.I db_lorder
is 0, the host order of the machine where the DB library was compiled
is used.
.sp
The value of
.I db_lorder
is ignored except when databases are being created.
If a database already exists,
the byte order it uses is determined when the file is read.
.sp
.ft B
The access methods provide no guarantees about the byte ordering of the
application data stored in the database,
and applications are responsible for maintaining any necessary ordering.
.ft R
.TP 5
size_t db_pagesize;
The size of the pages used to hold items in the database, in bytes.
The minimum page size is 512 bytes and the maximum page size is 64K bytes.
If
.I db_pagesize
is 0,
a page size is selected based on the underlying filesystem I/O block
size.
The selected size has a lower limit of 512 bytes and an upper limit
of 16K bytes.
.TP 5
void *(*db_malloc)(size_t);
The flag DB_DBT_MALLOC, when specified in the DBT structure, will cause
the DB library to allocate memory which then becomes the responsibility
of the calling application.
See
.IR db_dbt (3)
for more information.
.sp
On systems where there may be multiple library versions of malloc
(notably Windows NT), specifying the DB_DBT_MALLOC flag will fail
because the DB library will allocate memory from a different heap
than the application will use to free it.
To avoid this problem, the
.I db_malloc
field should be set to point to the application's allocation routine.
If
.I db_malloc
is non-NULL,
it will be used to allocate the memory returned when the DB_DBT_MALLOC flag
is set.
The
.I db_malloc
function must match the calling conventions of the
.IR malloc (3)
library routine.
.SH BTREE
The btree data structure is a sorted, balanced tree structure storing
associated key/data pairs.
Searches, insertions,
and deletions in the btree will all complete in O (lg base N) where base
is the average number of keys per page.
Often,
inserting ordered data into btrees results in pages that are half-full.
This implementation has been modified to make ordered (or inverse ordered)
insertion the best case,
resulting in nearly perfect page space utilization.
.PP
Space freed by deleting key/data pairs from the database is never reclaimed
from the filesystem,
although it is reused where possible.
This means that the btree storage structure is grow-only.
If sufficiently many keys are deleted from a tree that shrinking the
underlying database file is desirable,
this can be accomplished by creating a new tree from a scan of the existing
one.
.PP
The following additional fields and flags may be initialized in the DB_INFO
structure before calling
.IR db_open ,
when using the btree access method:
.TP 5
int (*bt_compare)(const DBT *, const DBT *);
The
.I bt_compare
function is the key comparison function.
It must return an integer less than, equal to, or greater than zero if the
first key argument is considered to be respectively less than, equal to,
or greater than the second key argument.
The same comparison function must be used on a given tree every time it
is opened.
.sp
The
.I data
and
.I size
fields of the DBT are the only fields that may be used for the purposes
of this comparison.
.sp
If
.I bt_compare
is NULL,
the keys are compared lexically,
with shorter keys collating before longer keys.
.TP 5
u_int32_t bt_minkey;
The minimum number of keys that will be stored on any single page.
This value is used to determine which keys will be stored on overflow
pages, i.e. if a key or data item is larger than the pagesize divided
by the
.I bt_minkey
value,
it will be stored on overflow pages instead of in the page itself.
The
.I bt_minkey
value specified must be at least 2; if
.I bt_minkey
is 0, a value of 2 is used.
.TP 5
size_t (*bt_prefix)(const DBT *, const DBT *);
The
.I bt_prefix
function is the prefix comparison function.
If specified, this function must return the number of bytes of the second key
argument that are necessary to determine that it is greater than the first
key argument.
If the keys are equal, the key length should be returned.
.sp
The
.I data
and
.I size
fields of the DBT are the only fields that may be used for the purposes
of this comparison.
.sp
This is used to compress the keys stored on the btree internal pages.
The usefulness of this is data dependent,
but in some data sets can produce significantly reduced tree sizes and
search times.
If
.I bt_prefix
is NULL, and no comparison function is specified,
a default lexical comparison function is used.
If
.I bt_prefix
is NULL and a comparison function is specified, no prefix comparison is
done.
.TP 5
u_int32_t flags;
The following additional flags may be specified by
.BR or 'ing
together one or more of the following values:
.RS
.TP 5
.de DU
DB_DUP
Permit duplicate keys in the tree,
i.e. insertion when the key of the key/data pair being inserted already
exists in the tree will be successful.
The ordering of duplicates in the tree is determined by the order of
insertion,
unless the ordering is otherwise specified by use of a cursor (see
.IR db_cursor (3)
for more information.)
..
.DU
It is an error to specify both DB_DUP and DB_RECNUM.
.TP 5
DB_RECNUM
Support retrieval from btrees using record numbers.
For more information, see the DB_SET_RECNO flag to the
.I DB->get
function (below),
and the cursor
.I c_get
function (in
.IR db_cursor (3)).
.sp
Logical record numbers in btrees are mutable in the face of record
insertion or deletion.
See the DB_RENUMBER flag in the RECNO section below for further discussion.
.sp
Maintaining record counts within a btree introduces a serious point of
contention,
namely the page locations where the record counts are stored.
In addition,
the entire tree must be locked during both insertions and deletions,
effectively single-threading the tree for those operations.
Specifying DB_RECNUM can result in serious performance degradation for
some applications and data sets.
.sp
It is an error to specify both DB_DUP and DB_RECNUM.
.RE
.SH HASH
The hash data structure is an extensible, dynamic hashing scheme.
Backward compatible interfaces to the functions described in
.IR dbm (3),
.IR ndbm (3)
and
.IR hsearch (3)
are provided, however these interfaces are not compatible with
previous file formats.
.PP
The following additional fields and flags may be initialized in the DB_INFO
structure before calling
.IR db_open ,
when using the hash access method:
.TP 5
u_int32_t h_ffactor;
The desired density within the hash table.
It is an approximation of the number of keys allowed to accumulate in any
one bucket, determining when the hash table grows or shrinks.
The default value is 0, indicating that the fill factor will be selected
dynamically as pages are filled.
.TP 5
u_int32_t (*h_hash)(const void *, u_int32_t);
The
.I h_hash
field is a user defined hash function;
if
.I h_hash
is NULL,
a default hash function is used.
Since no hash function performs equally well on all possible data,
the user may find that the built-in hash function performs poorly with
a particular data set.
User specified hash functions must take a pointer to a byte string and
a length as arguments and return a u_int32_t value.
.IP
If a hash function is specified,
.I hash_open
will attempt to determine if the hash function specified is the same as
the one with which the database was created, and will fail if it detects
that it is not.
.TP 5
u_int32_t h_nelem;
An estimate of the final size of the hash table.
If not set or set too low,
hash tables will expand gracefully as keys are entered,
although a slight performance degradation may be noticed.
The default value is 1.
.TP 5
u_int32_t flags;
The following additional flags may be specified by
.BR or 'ing
together one or more of the following values:
.RS
.TP 5
.DU
.SH RECNO
The recno access method provides support for fixed and variable length
records,
optionally backed by a flat text (byte stream) file.
Both fixed and variable length records are accessed by their logical
record number.
.PP
It is valid to create a record whose record number is more than one
greater than the last record currently in the database.
For example, the creation of record number 8, when records 6 and 7
do not yet exist, is not an error.
However, any attempt to retrieve such records (e.g., records 6 and 7)
will return DB_KEYEMPTY.
.PP
Deleting a record will not, by default, renumber records following
the deleted record (see DB_RENUMBER below for more information).
Any attempt to retrieve deleted records will return DB_KEYEMPTY.
.PP
The following additional fields and flags may be initialized in the DB_INFO
structure before calling
.IR db_open ,
when using the recno access method:
.TP 5
int re_delim;
For variable length records,
if the
.I re_source
file is specified and the DB_DELIMITER flag is set,
the delimiting byte used to mark the end of a record in the source file.
If the
.I re_source
file is specified and the DB_DELIMITER flag is not set,
<newline> characters (i.e. ``\en'', 0x0a) are interpreted as
end-of-record markers.
.TP 5
u_int32_t re_len;
The length of a fixed-length record.
.TP 5
int re_pad;
For fixed length records,
if the DB_PAD flag is set,
the pad character for short records.
If the DB_PAD flag is not set,
<space> characters (i.e., 0x20) are used for padding.
.TP 5
char *re_source;
The purpose of the
.I re_source
field is to provide fast access and modification to databases that are
normally stored as flat text files.
.sp
If the
.I re_source
field is non-NULL,
it specifies an underlying flat text database file that is read to initialize
a transient record number index.
In the case of variable length records,
the records are separated by the byte value
.IR re_delim .
For example,
standard UNIX byte stream files can be interpreted as a sequence of variable
length records separated by <newline> characters.
.sp
In addition,
when cached data would normally be written back to the underlying database
file (e.g., the
.I close
or
.I sync
functions are called),
the in-memory copy of the database will be written back to the
.I re_source
file.
.sp
By default, the backing source file is read lazily,
i.e., records are not read from the file until they are requested by the
application.
.ft B
If multiple processes (not threads) are accessing a recno database
concurrently and either inserting or deleting records,
the backing source file must be read in its entirety before more than
a single process accesses the database,
and only that process should specify the backing source file as part
of the db_open call.
.ft R
See the DB_SNAPSHOT flag below for more information.
.sp
.ft B
Reading and writing the backing source file specified by re_source
cannot be transactionally protected because it involves filesystem
operations that are not part of the DB transaction methodology.
.ft R
For this reason,
if a temporary database is used to hold the records, i.e., a NULL was
specified as the
.I file
argument to
.IR db_open ,
it is possible to lose the contents of the
.I re_source
file, e.g., if the system crashes at the right instant.
If a file is used to hold the database, i.e., a file name was specified
as the
.I file
argument to
.IR db_open ,
normal database recovery on that file can be used to prevent information
loss,
although it is still possible that the contents of
.I re_source
will be lost if the system crashes.
.sp
The
.I re_source
file must already exist (but may be zero-length) when
.I db_open
is called.
.sp
For all of the above reasons, the
.I re_source
field is generally used to specify databases that are read-only for DB
applications,
and that are either generated on the fly by software tools,
or modified using a different mechanism, e.g., a text editor.
.TP 5
u_int32_t flags;
The following additional flags may be specified by
.BR or 'ing
together one or more of the following values:
.RS
.TP 5
DB_DELIMITER
The
.I re_delim
field is set.
.TP 5
DB_FIXEDLEN
The records are fixed-length, not byte delimited.
The structure element
.I re_len
specifies the length of the record,
and the structure element
.I re_pad
is used as the pad character.
.sp
Any records added to the database that are less than
.I re_len
bytes long are automatically padded.
Any attempt to insert records into the database that are greater than
.I re_len
bytes long will cause the call to fail immediately and return an error.
.TP 5
DB_PAD
The
.I re_pad
field is set.
.TP 5
DB_RENUMBER
Specifying the DB_RENUMBER flag causes the logical record numbers to be
mutable,
and change as records are added to and deleted from the database.
For example,
the deletion of record number 4 causes records numbered 5 and greater
to be renumbered downward by 1.
If a cursor was positioned to record number 4 before the deletion,
it will reference the new record number 4, if any such record exists,
after the deletion.
If a cursor was positioned after record number 4 before the deletion,
it will be shifted downward 1 logical record,
continuing to reference the same record as it did before.
.sp
Using the
.I c_put
or
.I put
interfaces to create new records will cause the creation of multiple
records if the record number is more than one greater than the largest
record currently in the database.
For example, creating record 28,
when record 25 was previously the last record in the database,
will create records 26 and 27 as well as 28.
Attempts to retrieve records that were created in this manner
will result in an error return of DB_KEYEMPTY.
.sp
If a created record is not at the end of the database,
all records following the new record will be automatically renumbered
upward by 1.
For example,
the creation of a new record numbered 8 causes records numbered 8 and
greater to be renumbered upward by 1.
If a cursor was positioned to record number 8 or greater before the insertion,
it will be shifted upward 1 logical record,
continuing to reference the same record as it did before.
.sp
For these reasons,
concurrent access to a recno database with the DB_RENUMBER flag specified
may be largely meaningless, although it is supported.
.TP 5
DB_SNAPSHOT
This flag specifies that any specified
.I re_source
file be read in its entirety when
.I db_open
is called.
If this flag is not specified,
the
.I re_source
file may be read lazily.
.RE
.PP
.SH "DB OPERATIONS"
The DB structure returned by
.I db_open
describes a database type,
and includes a set of functions to perform various actions,
as described below.
Each of these functions takes a pointer to a DB structure, and may take
one or more DBT *'s and a flag value as well.
The fields of the DB structure are as follows:
.TP 5
DBTYPE type;
The type of the underlying access method (and file format).
Set to one of DB_BTREE, DB_HASH or DB_RECNO.
This field may be used to determine the type of the database after a
return from
.I db_open
with the
.I type
argument set to DB_UNKNOWN.
.TP 5
int (*close)(DB *db, u_int32_t flags);
A pointer to a function to flush any cached information to disk,
close any open cursors (see
.IR db_cursor (3)),
free any allocated resources, and close any underlying files.
Since key/data pairs are cached in memory, failing to sync the
file with the
.I close
or
.I sync
function may result in inconsistent or lost information.
.IP
The
.I flags
parameter must be set to 0 or the following value:
.RS
.TP 5
DB_NOSYNC
Do not flush cached information to disk.
.RE
.IP
The DB_NOSYNC flag is a dangerous option.
It should only be set if the application is doing logging (with
transactions) so that the database is recoverable after a
system or application crash,
or if the database is always generated from scratch after any system or
application crash.
.IP
.ft B
It is important to understand that flushing cached information to disk
only minimizes the window of opportunity for corrupted data.
.ft R
While unlikely,
it is possible for database corruption to happen if a system or application
crash occurs while writing data to the database.
To ensure that database corruption never occurs, applications must either:
use transactions and logging with automatic recovery,
use logging and application-specific recovery,
or edit a copy of the database,
and, once all applications using the database have successfully called
.IR close ,
replace the original database with the updated copy.
.IP
When multiple threads are using the DB handle concurrently,
only a single thread may call the DB handle close function.
.IP
.Rt close
.TP 5
int (*cursor)(DB *db, DB_TXN *txnid, DBC **cursorp);
A pointer to a function to create a cursor and copy a pointer to it into
the memory referenced by
.IR cursorp .
.IP
A cursor is a structure used to provide sequential access through a database.
This interface and its associated functions replaces the functionality
provided by the
.I seq
function in previous releases of the DB library.
.IP
.Tx
If transaction protection is enabled,
cursors must be opened and closed within the context of a transaction,
and the
.I txnid
parameter specifies the transaction context in which the cursor may be used.
See
.IR db_cursor (3)
for more information.
.IP
.Rt cursor
.TP 5
int (*del)(DB *db, DB_TXN *txnid, DBT *key, u_int32_t flags);
.br
A pointer to a function to remove key/data pairs from the database.
The key/data pair associated with the specified
.I key
is discarded from the database.
In the presence of duplicate key values,
all records associated with the designated key will be discarded.
.Tx
.IP
.Fl
.IP
.Rc del
and DB_NOTFOUND if the specified
.I key
did not exist in the file.
.TP 5
int (*fd)(DB *db, int *fdp);
A pointer to a function that copies a file descriptor representative
of the underlying database into the memory referenced by
.IR fdp .
A file descriptor referencing the same file will be returned to all
processes that call
.I db_open
with the same
.I file
argument.
This file descriptor may be safely used as an argument to the
.IR fcntl (2)
and
.IR flock (2)
locking functions.
The file descriptor is not necessarily associated with any of the
underlying files used by the access method.
.IP
The
.I fd
function only supports a coarse-grained form of locking.
Applications should use the lock manager where possible.
.IP
.Rt fd
.TP 5
int (*get)(DB *db, DB_TXN *txnid,
.ti +5
DBT *key, DBT *data, u_int32_t flags);
.br
A pointer to a function that is an interface for keyed retrieval from
the database.
The address and length of the data associated with the specified
.I key
are returned in the structure referenced by
.IR data .
.sp
In the presence of duplicate key values,
.I get
will return the first data item for the designated key.
Duplicates are sorted by insert order except where this order has been
overridden by cursor operations.
.ft B
Retrieval of duplicates requires the use of cursor operations.
.ft R
See
.IR db_cursor (3)
for details.
.Tx
.IP
The
.I flags
parameter must be set to 0 or the following value:
.RS
.TP 5
DB_SET_RECNO
Retrieve the specified numbered key/data pair from a database.
Upon return,
both the
.I key
and
.I data
items will have been filled in,
not just the data item as is done for all other uses of the
.I get
function.
.sp
The
.I data
field of the specified
.I key
must be a pointer to a memory location from which a
.I db_recno_t
may be read, as described in
.IR db_dbt (3).
This memory location will be read to determine the record to be retrieved.
.sp
For DB_SET_RECNO to be specified,
the underlying database must be of type btree
and it must have been created with the DB_RECNUM flag (see
.IR db_open (3)).
.RE
.IP
If the database is a recno database and the requested key exists,
but was never explicitly created by the application or was later
deleted, the
.I get
function returns DB_KEYEMPTY.
Otherwise, if the requested key isn't in the database, the
.I get
function returns DB_NOTFOUND.
.Ro get
.TP 5
int (*put)(DB *db, DB_TXN *txnid,
.ti +5
DBT *key, DBT *data, u_int32_t flags);
.br
A pointer to a function to store key/data pairs in the database.
If the database supports duplicates,
the
.I put
function adds the new data value at the end of the duplicate set.
.Tx
.IP
The flags value is specified by
.BR or 'ing
together one or more of the following values:
.RS
.TP 5
DB_APPEND
Append the key/data pair to the end of the database.
For DB_APPEND to be specified,
the underlying database must be of type recno.
The record number allocated to the record is returned in the specified
.IR key .
.TP 5
DB_NOOVERWRITE
Enter the new key/data pair only if the key does not already appear
in the database.
.RE
.IP
The default behavior of the
.I put
function is to enter the new key/data pair,
replacing any previously existing key if duplicates are
disallowed, or to add a duplicate entry if duplicates are
allowed.
Even if the designated database allows duplicates,
a call to
.I put
with the DB_NOOVERWRITE flag set will fail if the key already exists in
the database.
.IP
.Rc put
and DB_KEYEXIST if the DB_NOOVERWRITE
.I flag
was set and the key already exists in the file.
.TP 5
int (*sync)(DB *db, u_int32_t flags);
A pointer to a function to flush any cached information to disk.
If the database is in memory only, the
.I sync
function has no effect and will always succeed.
.IP
.Fl
.IP
See the
.I close
function description above for a discussion of DB and cached data.
.IP
.Rt sync
.TP 5
int (*stat)(DB *db, void *sp,
.ti +5
void *(*db_malloc)(size_t), u_int32_t flags);
.br
A pointer to a function to create a statistical structure and copy a pointer
to it into user-specified memory locations.
Specifically, if
.I sp
is non-NULL,
a pointer to the statistics for the database are copied into the memory
location it references.
.sp
.Ma "Statistical structures"
.sp
.ft B
In the presence of multiple threads or processes accessing an active
database,
the returned information may be out-of-date.
.ft R
.sp
.ft B
This function may access all of the pages in the database,
and therefore may incur a severe performance penalty and have obvious
negative effects on the underlying buffer pool.
.ft R
.sp
.IP
The
.I flags
parameter must be set to 0 or the following value:
.IP
.RS
.TP 5
DB_RECORDCOUNT
Fill in the
.I bt_nrecs
field of the statistics structure,
but do not collect any other information.
This flag makes it reasonable for applications to request a record count from
a database without incurring a performance penalty.
It is only available for recno databases,
or btree databases where the underlying database was created with the
DB_RECNUM flag.
.RE
.IP
.Rt stat
.IP
In the case of a btree or recno database,
the statistics are stored in a structure of type DB_BTREE_STAT
(typedef'd in <db.h>).
The following fields will be filled in:
.RS
.TP 5
u_int32_t bt_magic;
Magic number that identifies the file as a btree file.
.Nt
u_int32_t bt_version;
The version of the btree file type.
.Nt
u_int32_t bt_flags;
Permanent database flags,
including DB_DUP, DB_FIXEDLEN, DB_RECNUM and DB_RENUMBER.
.\".Nt
.\"u_int32_t bt_maxkey;
.\"The
.\".I bt_maxkey
.\"value specified to
.\".IR db_open (3),
.\"if any.
.Nt
u_int32_t bt_minkey;
The
.I bt_minkey
value specified to
.IR db_open (3),
if any.
.Nt
u_int32_t bt_re_len;
The
.I re_len
value specified to
.IR db_open (3),
if any.
.Nt
u_int32_t bt_re_pad;
The
.I re_pad
value specified to
.IR db_open (3),
if any.
.Nt
u_int32_t bt_pagesize;
Underlying tree page size.
.Nt
u_int32_t bt_levels;
Number of levels in the tree.
.Nt
u_int32_t bt_nrecs;
Number of data items in the tree (since there may be multiple data items
per key, this number may not be the same as the number of keys).
.Nt
u_int32_t bt_int_pg;
Number of tree internal pages.
.Nt
u_int32_t bt_leaf_pg;
Number of tree leaf pages.
.Nt
u_int32_t bt_dup_pg;
Number of tree duplicate pages.
.Nt
u_int32_t bt_over_pg;
Number of tree overflow pages.
.Nt
u_int32_t bt_free;
Number of pages on the free list.
.Nt
u_int32_t bt_freed;
Number of pages made available for reuse because they were emptied.
.Nt
u_int32_t bt_int_pgfree;
Number of bytes free in tree internal pages.
.Nt
u_int32_t bt_leaf_pgfree;
Number of bytes free in tree leaf pages.
.Nt
u_int32_t bt_dup_pgfree;
Number of bytes free in tree duplicate pages.
.Nt
u_int32_t bt_over_pgfree;
Number of bytes free in tree overflow pages.
.Nt
u_int32_t bt_pfxsaved;
Number of bytes saved by prefix compression.
.Nt
u_int32_t bt_split;
Total number of tree page splits (includes fast and root splits).
.Nt
u_int32_t bt_rootsplit;
Number of root page splits.
.Nt
u_int32_t bt_fastsplit;
Number of fast splits.
When sorted keys are added to the database,
the DB btree implementation will split left or right to increase the
page-fill factor.
This number is a measure of how often it was possible to make such a
split.
.Nt
u_int32_t bt_added;
Number of keys added.
.Nt
u_int32_t bt_deleted;
Number of keys deleted.
.Nt
u_int32_t bt_get;
Number of keys retrieved.
(Note, this value will not reflect any keys retrieved when the database was
open for read-only access, as there is no permanent location to store the
information in this case.)
.Nt
u_int32_t bt_cache_hit;
Number of hits in tree fast-insert code.
When sorted keys are added to the database,
the DB btree implementation will check the last page where an insert
occurred before doing a full lookup.
This number is a measure of how often the lookup was successful.
.Nt
u_int32_t bt_cache_miss;
Number of misses in tree fast-insert code.
See the description of bt_cache_hit;
this number is a measure of how often the lookup failed.
.RE
.SH "ENVIRONMENT VARIABLES"
The following environment variables affect the execution of
.IR db_open :
.TP 5
.Eh db_open DB_DATA_DIR
.SH EXAMPLES
Applications that create short-lived databases that are discarded or
recreated when the system fails and are unconcerned with concurrent
access and loss of data due to catastrophic failure,
may wish to use the
.I db_open
functionality without other parts of the DB library.
Such applications will only be concerned with the DB access methods.
The DB access methods will use the memory pool subsystem,
but the application is unlikely to be aware of this.
See the files
.I example/ex_access.c
and
.I example/ex_btrec.c
in the DB source distribution for C language code examples of how such
applications might use the DB library.
.SH ERRORS
.Ee db_open
.na
.Nh
DB->sync(3), 
calloc(3), 
close(2), 
fcntl(2), 
fflush(3), 
lock_get(3), 
lock_id(3), 
lock_put(3), 
lock_vec(3), 
log_put(3), 
log_register(3), 
log_unregister(3), 
malloc(3), 
memcpy(3), 
memmove(3), 
memp_close(3), 
memp_fclose(3), 
memp_fget(3), 
memp_fopen(3), 
memp_fput(3), 
memp_fset(3), 
memp_fsync(3), 
memp_open(3), 
memp_register(3), 
memset(3), 
mmap(2), 
munmap(2), 
open(2), 
read(2), 
realloc(3), 
sigfillset(3), 
sigprocmask(2), 
stat(2), 
strcpy(3), 
strdup(3), 
strerror(3), 
strlen(3), 
time(3), 
and
unlink(2). 
.Hy
.ad
.PP
.Ec db_open
.TP 5
.Ea
.TP 5
[EINVAL]
An invalid flag value or parameter was specified (e.g., unknown database
type, page size, hash function, recno pad byte, byte order) or a flag
value or parameter that is incompatible with the current
.I file
specification.
.sp
.Et
.sp
There is a mismatch between the version number of
.I file
and the software.
.sp
A
.I re_source
file was specified with either the DB_THREAD flag or a non-NULL
.I tx_info
field in the DB_ENV argument to db_open.
.TP 5
[ENOENT]
A non-existent
.I re_source
file was specified.
.TP 5
.Ep
.PP
.Ee DB->close
.na
.Nh
DB->sync(3), 
calloc(3), 
close(2), 
fflush(3), 
lock_get(3), 
lock_put(3), 
lock_vec(3), 
log_put(3), 
log_unregister(3), 
malloc(3), 
memcpy(3), 
memmove(3), 
memp_close(3), 
memp_fclose(3), 
memp_fget(3), 
memp_fput(3), 
memp_fset(3), 
memp_fsync(3), 
memset(3), 
munmap(2), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ee DB->cursor
.na
.Nh
calloc(3). 
.Hy
.ad
.PP
.Ec DB->cursor
.TP 5
.Ei
.TP 5
.Ep
.PP
.Ee DB->del
.na
.Nh
calloc(3), 
fcntl(2), 
fflush(3), 
lock_get(3), 
lock_id(3), 
lock_put(3), 
lock_vec(3), 
log_put(3), 
malloc(3), 
memcmp(3), 
memcpy(3), 
memmove(3), 
memp_fget(3), 
memp_fput(3), 
memp_fset(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec DB->del
.TP 5
.Ea
.TP 5
.Ei
.TP 5
.Ep
.PP
.Ec DB->fd
.TP 5
[ENOENT]
The
.I DB->fd
function was called for an in-memory database,
or no underlying file has yet been created.
.TP 5
.Ep
.PP
.Ee DB->get
.na
.Nh
DBcursor->c_get(3), 
calloc(3), 
fcntl(2), 
fflush(3), 
lock_get(3), 
lock_id(3), 
lock_put(3), 
lock_vec(3), 
log_put(3), 
malloc(3), 
memcmp(3), 
memcpy(3), 
memmove(3), 
memp_fget(3), 
memp_fput(3), 
memp_fset(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec DB->get
.TP 5
.Ea
.TP 5
.Ei
.sp
The DB_THREAD flag was specified to the
.IR db_open (3)
function and neither the DB_DBT_MALLOC or DB_DBT_USERMEM flags were set
in the DBT.
.sp
A record number of 0 was specified.
.TP 5
.Ep
.PP
.Ee DB->put
.na
.Nh
calloc(3), 
fcntl(2), 
fflush(3), 
lock_get(3), 
lock_id(3), 
lock_put(3), 
lock_vec(3), 
log_put(3), 
malloc(3), 
memcmp(3), 
memcpy(3), 
memmove(3), 
memp_fget(3), 
memp_fput(3), 
memp_fset(3), 
memset(3), 
realloc(3), 
and
strerror(3). 
.Hy
.ad
.PP
.Ec DB->put
.TP 5
.Es
.TP 5
.Ea
.TP 5
.Ei
.sp
A record number of 0 was specified.
.sp
An attempt was made to add a record to a fixed-length database that
was too large to fit.
.sp
An attempt was made to do a partial put.
.TP 5
.Ep
.TP 5
[ENOSPC]
A btree exceeded the maximum btree depth (255).
.PP
.Ee DB->stat
.na
.Nh
calloc(3), 
fcntl(2), 
fflush(3), 
lock_get(3), 
lock_id(3), 
lock_put(3), 
lock_vec(3), 
malloc(3), 
memcpy(3), 
memp_fget(3), 
memp_fput(3), 
and
memset(3). 
.Hy
.ad
.PP
.Ee DB->sync
.na
.Nh
DB->get(3), 
DB->sync(3), 
calloc(3), 
close(2), 
fcntl(2), 
fflush(3), 
lock_get(3), 
lock_id(3), 
lock_put(3), 
lock_vec(3), 
log_put(3), 
malloc(3), 
memcpy(3), 
memmove(3), 
memp_fget(3), 
memp_fput(3), 
memp_fset(3), 
memp_fsync(3), 
memset(3), 
munmap(2), 
open(2), 
realloc(3), 
strerror(3), 
unlink(2), 
and
write(2). 
.Hy
.ad
.PP
.Ec DB->sync
.TP 5
.Ei
.TP 5
.Ep
.SH "SEE ALSO"
.IR "The Ubiquitous B-tree" ,
Douglas Comer, ACM Comput. Surv. 11, 2 (June 1979), 121-138.
.sp
.IR "Prefix B-trees" ,
Bayer and Unterauer, ACM Transactions on Database Systems, Vol. 2, 1
(March 1977), 11-26.
.sp
.IR "The Art of Computer Programming Vol. 3: Sorting and Searching" ,
D.E. Knuth, 1968, pp 471-480.
.sp
.IR "Dynamic Hash Tables" ,
Per-Ake Larson, Communications of the ACM, April 1988.
.sp
.IR "A New Hash Package for UNIX" ,
Margo Seltzer, USENIX Proceedings, Winter 1991.
.sp
.IR "Document Processing in a Relational Database System" ,
Michael Stonebraker, Heidi Stettner, Joseph Kalash, Antonin Guttman,
Nadene Lynn, Memorandum No. UCB/ERL M82/32, May 1982.
.sp
.Sa
