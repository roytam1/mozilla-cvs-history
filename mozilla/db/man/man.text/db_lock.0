

NNAAMMEE
       db_lock - lock manager

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb..hh>>

       iinntt
       lloocckk__ooppeenn((ccoonnsstt cchhaarr **ddiirr,,
            uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,, DDBB__EENNVV **ddbbeennvv,, DDBB__LLOOCCKKTTAABB ****rreeggiioonnpp));;

       iinntt
       lloocckk__iidd((DDBB__LLOOCCKKTTAABB **lltt,, uu__iinntt3322__tt **iiddpp));;

       iinntt
       lloocckk__vveecc((DDBB__LLOOCCKKTTAABB **lltt,, uu__iinntt3322__tt lloocckkeerr,, uu__iinntt3322__tt ffllaaggss,,
            DDBB__LLOOCCKKRREEQQ lliisstt[[]],, iinntt nnlliisstt,, DDBB__LLOOCCKKRREEQQ ****eelliissttpp));;

       iinntt
       lloocckk__ggeett((DDBB__LLOOCCKKTTAABB **lltt,, uu__iinntt3322__tt lloocckkeerr,, uu__iinntt3322__tt ffllaaggss,,
            ccoonnsstt DDBBTT **oobbjj,, ccoonnsstt ddbb__lloocckkmmooddee__tt lloocckk__mmooddee,, DDBB__LLOOCCKK **lloocckk));;

       iinntt
       lloocckk__ppuutt((DDBB__LLOOCCKKTTAABB **lltt,, DDBB__LLOOCCKK lloocckk));;

       iinntt
       lloocckk__cclloossee((DDBB__LLOOCCKKTTAABB **lltt));;

       iinntt
       lloocckk__uunnlliinnkk((ccoonnsstt cchhaarr **ddiirr,, iinntt ffoorrccee,, DDBB__EENNVV **ddbbeennvv));;

       iinntt
       lloocckk__ddeetteecctt((DDBB__LLOOCCKKTTAABB **lltt,, uu__iinntt3322__tt ffllaaggss,, uu__iinntt3322__tt aattyyppee));;

       iinntt
       lloocckk__ssttaatt((DDBB__LLOOCCKKTTAABB **lltt,,
            DDBB__LLOOCCKK__SSTTAATT ****sspppp,, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt))));;

DDEESSCCRRIIPPTTIIOONN
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see _d_b___i_n_t_r_o(3).

       This  manual  page  describes  the specific details of the
       locking interface.

       The _d_b___l_o_c_k functions are the library  interface  intended
       to  provide  general-purpose  locking.   While designed to
       work with the other DB functions, these functions are also
       useful  for  more  general locking purposes.  Locks can be
       shared between processes.  In most  cases,  when  multiple
       threads  or  processes  are  using  locking,  the deadlock
       detector, _d_b___d_e_a_d_l_o_c_k(1), should be run.

  _l_o_c_k___o_p_e_n
       The _l_o_c_k___o_p_e_n function copies a pointer, to the lock table
       identified  by the ddiirreeccttoorryy _d_i_r, into the memory location
       referenced by _r_e_g_i_o_n_p.

       If the _d_b_e_n_v argument to _l_o_c_k___o_p_e_n was  initialized  using
       _d_b___a_p_p_i_n_i_t,   _d_i_r   is   interpreted   as   described   by
       _d_b___a_p_p_i_n_i_t(3).

       Otherwise, if _d_i_r is not NULL, it is interpreted  relative
       to  the  current working directory of the process.  If _d_i_r
       is NULL, the following environment variables  are  checked
       in  order:  ``TMPDIR'',  ``TEMP'', and ``TMP''.  If one of
       them is set, lock table files are created relative to  the
       directory  it  specifies.   If  none  of them are set, the
       first possible one of the following directories  is  used:
       _/_v_a_r_/_t_m_p, _/_u_s_r_/_t_m_p, _/_t_e_m_p, _/_t_m_p, _C_:_/_t_e_m_p and _C_:_/_t_m_p.

       All  files  associated  with the lock table are created in
       this directory.  This directory must already exist when

       lock table_open is called.   If  the  lock  table  already
       exists, the process must have permission to read and write
       the existing files.  If the lock table  does  not  already
       exist, it is optionally created and initialized.

       The  _f_l_a_g_s  and  _m_o_d_e  arguments specify how files will be
       opened and/or created when they don't already exist.   The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create any underlying files, as  necessary.   If  the
            files  do not already exist and the DB_CREATE flag is
            not specified, the call will fail.


       DB_THREAD
            Cause the DB_LOCKTAB handle returned by the _l_o_c_k___o_p_e_n
            function  to  be useable by multiple threads within a
            single address space, i.e., to be  ``free-threaded''.

       All  files  created by the lock subsystem are created with
       mode _m_o_d_e (as described in _c_h_m_o_d(2)) and modified  by  the
       process'   umask  value  at  the  time  of  creation  (see
       _u_m_a_s_k(2)).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

       The locking subsystem is configured  based  on  the  _d_b_e_n_v
       argument  to  _l_o_c_k___o_p_e_n, which is a pointer to a structure
       of type DB_ENV (typedef'd in <db.h>).   Applications  will
       normally  use  the  same  DB_ENV structure (initialized by
       _d_b___a_p_p_i_n_i_t(3)), as an argument to all of the subsystems in
       the DB package.

       References  to  the DB_ENV structure are maintained by DB,
       so it may not be discarded until the last close  function,
       corresponding  to  an  open  function  for which it was an
       argument, has returned.  In order to ensure  compatibility
       with  future  releases  of  DB,  all  fields of the DB_ENV
       structure that are not explicitly set should  be  initial-
       ized to 0 before the first time the structure is used.  Do
       this by declaring the structure external or static, or  by
       calling the C library routine _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       The  fields  of the DB_ENV structure used by _l_o_c_k___o_p_e_n are
       described below.  If _d_b_e_n_v is NULL or any  of  its  fields
       are set to 0, defaults appropriate for the system are used
       where possible.

       The following fields in the DB_ENV structure may  be  ini-
       tialized before calling _l_o_c_k___o_p_e_n:

       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       int db_verbose;
            The  error  fields  of the DB_ENV behave as described
            for _d_b___a_p_p_i_n_i_t(3).



       const u_int8_t lk_conflicts[][];
            A _l_k___m_o_d_e_s by _l_k___m_o_d_e_s array.  A non-0 value for  the
            array element:

                 lk_conflicts[requested_mode][held_mode]

            indicates that requested_mode and held_mode conflict.
            The ``not-granted'' mode must be  represented  by  0.
            If   _l_k___c_o_n_f_l_i_c_t_s   is   NULL,  the  conflicts  array
            _d_b___r_w___c_o_n_f_l_i_c_t_s is used; see the section below  enti-
            tled  ``STANDARD  LOCK  MODES''  for a description of
            that array.

       db_detect_t lk_detect;
            If non-0, specifies that the deadlock detector be run
            whenever  a lock conflict occurs, and specifies which
            transaction should be aborted in the case of a  dead-
            lock.   The _l_k___d_e_t_e_c_t field must be set to one of the
            following values.

            DB_LOCK_DEFAULT
                 Use the  default  policy  as  specified  in  the
                 _d_b___d_e_a_d_l_o_c_k(1) man page.

            DB_LOCK_OLDEST
                 Abort the oldest transaction.

            DB_LOCK_RANDOM
                 Abort a random transaction involved in the dead-
                 lock.

            DB_LOCK_YOUNGEST
                 Abort the youngest transaction.

       u_int32_t lk_max;
            The maximum number of locks to be held  or  requested
            in  the  table.   This  value is used by _l_o_c_k___o_p_e_n to
            estimate how much space to allocate for various lock-
            table  data  structures.   If  _l_k___m_a_x is 0, a default
            value is used.

       u_int32_t lk_modes;
            The number of lock modes to be recognized by the lock
            table   (including  the  ``not-granted''  mode).   If
            _l_k___m_o_d_e_s is 0, the value DB_LOCK_RW_N  is  used;  see
            below for a description of that value.

       The _l_o_c_k___o_p_e_n function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _l_o_c_k___i_d
       The _l_o_c_k___i_d function copies a locker ID, which is  guaran-
       teed  to  be  unique in the specified lock table, into the
       memory location referenced by _i_d_p.

       The access methods (see  _d_b___o_p_e_n(3)),  generate  a  unique
       locker ID for each file that is opened with locking.  Dur-
       ing DB access method operation, this  locker  ID  will  be
       used  for  all  lock calls unless a transaction identifier
       was specified for the call, in which case the  transaction
       ID specified is used for locking.

       The _l_o_c_k___i_d function returns the value of _e_r_r_n_o on failure
       and 0 on success.

  _l_o_c_k___v_e_c
       The _l_o_c_k___v_e_c function atomically obtains and releases  one
       or  more locks from the specified table, _l_t.  The _l_o_c_k___v_e_c
       function is intended to support acquisition or trading  of
       multiple  locks  under  one  lock  table  semaphore, as is
       needed for lock coupling or  in  multigranularity  locking
       for lock escalation.

       The  _l_o_c_k_e_r  argument specified to _l_o_c_k___v_e_c is an unsigned
       32-bit  integer  quantity.   It  represents   the   entity
       requesting or releasing the lock.

       The _f_l_a_g_s value must be set to 0 or the following value:

       DB_LOCK_NOWAIT
            If  a  lock  cannot  be granted because the requested
            lock conflicts with an existing lock, return  immedi-
            ately  instead  of  waiting  for  the  lock to become
            available.

       The _l_i_s_t array provided to _l_o_c_k___v_e_c is typedef'd in <db.h>
       as  DB_LOCKREQ.   A  DB_LOCKREQ structure has at least the
       following fields, which must be initialized before calling
       _l_o_c_k___v_e_c:

       lockop_t op;
            The  operation  to be performed, which must be set to
            one of the following values:

            DB_LOCK_GET
                 Get a lock, as defined by the values of  _l_o_c_k_e_r,
                 _o_b_j and _m_o_d_e.  Upon return from _l_o_c_k___v_e_c, if the
                 _l_o_c_k field  is  non-NULL,  a  reference  to  the
                 acquired  lock is stored there.  (This reference
                 is  invalidated  by  any  call  to  _l_o_c_k___v_e_c  or
                 _l_o_c_k___p_u_t that releases the lock.)

            DB_LOCK_PUT
                 The  lock referenced by the contents of the _l_o_c_k
                 field is released.

            DB_LOCK_PUT_ALL
                 All locks held by the _l_o_c_k_e_r are released.  (Any
                 locks  acquired as a part of the current call to
                 _l_o_c_k___v_e_c that appear after  the  DB_LOCK_PUT_ALL
                 entry are not considered for this operation).

            DB_LOCK_PUT_OBJ
                 All locks held by the _l_o_c_k_e_r, on the object _o_b_j,
                 with  the  mode  specified  by  _l_o_c_k___m_o_d_e,   are
                 released.   A  _l_o_c_k___m_o_d_e of DB_LOCK_NG indicates
                 that all locks on the object should be released.
                 Note  that  any  locks acquired as a part of the
                 current call to _l_o_c_k___v_e_c that occur  before  the
                 DB_LOCK_PUT_OBJ  will  also  be  released; those
                 acquired afterwards will not be released.

       const DBT obj;
            An untyped byte string that specifies the  object  to
            be locked or released.

       const lockmode_t mode;
            The  lock  mode,  used as an index into _l_t's conflict
            array.


       DB_LOCK lock;
            A lock reference.

       The _n_l_i_s_t argument specifies the number of elements in the
       _l_i_s_t array.

       If  any  of the requested locks cannot be acquired, or any
       of the locks to be released cannot be released, the opera-
       tions  before the failing operation are guaranteed to have
       completed successfully, and _l_o_c_k___v_e_c  returns  a  non-zero
       value.   In  addition, if _e_l_i_s_t_p is not NULL, it is set to
       point to the DB_LOCKREQ entry  that  was  being  processed
       when the error occurred.

       In  the  case  of an error, _l_o_c_k___v_e_c may return one of the
       following values:

       DB_LOCK_DEADLOCK
            The specified _l_o_c_k_e_r was  selected  as  a  victim  in
            order to resolve a deadlock.

       DB_LOCK_NOTHELD
            The  lock  cannot  be released, as it was not held by
            the _l_o_c_k_e_r.

       DB_LOCK_NOTGRANTED
            A lock was requested that could not  be  granted  and
            the  _f_l_a_g  parameter  was  set to DB_LOCK_NOWAIT.  In
            this case, if non-NULL, _e_l_i_s_t_p identifies the request
            that was granted.

       Otherwise,  the  _l_o_c_k___v_e_c  function  returns  the value of
       _e_r_r_n_o on failure and 0 on success.

  _l_o_c_k___g_e_t
       The  _l_o_c_k___g_e_t  function  is  a  simple  interface  to  the
       _l_o_c_k___v_e_c  functionality,  and is equivalent to calling the
       _l_o_c_k___v_e_c function with the _l_t and _l_o_c_k_e_r arguments, _e_l_i_s_t_p
       and  _c_o_n_f_l_i_c_t  arguments, and a single element _l_i_s_t array,
       for which the  _o_p  field  is  DB_LOCK_GET,  and  the  _o_b_j,
       _l_o_c_k___m_o_d_e and _l_o_c_k fields are represented by the arguments
       of the same name.  Note that the type of the _o_b_j  argument
       to _l_o_c_k___g_e_t is different from the _o_b_j element found in the
       DB_LOCKREQ structure.  The _l_o_c_k___g_e_t function returns  suc-
       cess and failure as described for the _l_o_c_k___v_e_c function.

  _l_o_c_k___p_u_t
       The  _l_o_c_k___p_u_t  function  is  a  simple  interface  to  the
       _l_o_c_k___v_e_c functionality, and is equivalent to  calling  the
       _l_o_c_k___v_e_c  function  with  a single element _l_i_s_t array, for
       which the _o_p field is DB_LOCK_PUT and the  _l_o_c_k  field  is
       represented  by  the  argument  of  the  same  name.   The
       _l_o_c_k___p_u_t function returns success and failure as described
       for the _l_o_c_k___v_e_c function.
  _l_o_c_k___c_l_o_s_e
       The  _l_o_c_k___c_l_o_s_e function disassociates the calling process
       from the lock table _l_t.  Note  that  _l_o_c_k___c_l_o_s_e  does  not
       release  any  locks  still  held  by  the closing process.
       (This provides functionality for long-lived locks.)   Pro-
       cesses  that  wish to have all their locks released can do
       so by issuing the appropriate _l_o_c_k___v_e_c call.

       In addition, if the _d_i_r argument to _l_o_c_k___o_p_e_n was NULL and
       _d_b_e_n_v was not initialized using _d_b___a_p_p_i_n_i_t, all files cre-
       ated for  this  shared  region  will  be  removed,  as  if
       _l_o_c_k___u_n_l_i_n_k were called.

       When multiple threads are using the DB_LOCKTAB handle con-
       currently, only a single thread may  call  the  _l_o_c_k___c_l_o_s_e
       function.

       The  _l_o_c_k___c_l_o_s_e  function  returns  the  value of _e_r_r_n_o on
       failure and 0 on success.


  _l_o_c_k___u_n_l_i_n_k
       The _l_o_c_k___u_n_l_i_n_k function destroys the lock  table  identi-
       fied  by  the  directory  _d_i_r,  removing all files used to
       implement the lock  table.   (The  directory  _d_i_r  is  not
       removed.)    If  there  are  processes  that  have  called
       _l_o_c_k___o_p_e_n without calling _l_o_c_k___c_l_o_s_e (i.e., there are pro-
       cesses  currently  using the lock table), _l_o_c_k___u_n_l_i_n_k will
       fail without further action, unless the force flag is set,
       in  which case _l_o_c_k___u_n_l_i_n_k will attempt to remove the lock
       table files regardless of any processes  still  using  the
       lock table.

       The  result  of  attempting to forcibly destroy the region
       when a process has the region open is  unspecified.   Pro-
       cesses  using a shared memory region maintain an open file
       descriptor for it.  On UNIX systems,  the  region  removal
       should  succeed and processes that have already joined the
       region should  continue  to  run  in  the  region  without
       change,  however  processes  attempting  to  join the lock
       table will either fail or attempt to create a new  region.
       On  other  systems,  e.g., WNT, where the _u_n_l_i_n_k(2) system
       call will fail if any process has an open file  descriptor
       for the file, the region removal will fail.

       In  the  case  of catastrophic or system failure, database
       recovery must  be  performed  (see  _d_b___r_e_c_o_v_e_r(1)  or  the
       DB_RECOVER  and  DB_RECOVER_FATAL flags to _d_b___a_p_p_i_n_i_t(3)).
       Alternatively, if recovery  is  not  required  because  no
       database state is maintained across failures, it is possi-
       ble to clean up a lock table by removing all of the  files
       in  the  directory specified to the _l_o_c_k___o_p_e_n function, as
       lock table files are never created in any directory  other
       than  the one specified to _l_o_c_k___o_p_e_n.  Note, however, that
       this has the potential to  remove  files  created  by  the
       other DB subsystems in this database environment.

       The  _l_o_c_k___u_n_l_i_n_k  function  returns  the value of _e_r_r_n_o on
       failure and 0 on success.

  _l_o_c_k___d_e_t_e_c_t
       The _l_o_c_k___d_e_t_e_c_t function runs one iteration of  the  dead-
       lock  detector  on  the specified table, _l_t.  The deadlock
       detector traverses the lock table, detects deadlocks,  and
       if  it  finds one, marks one of the participating transac-
       tions for abort and then returns.

       The flags value is specified by  oorr'ing  together  one  or
       more of the following values:


       DB_LOCK_CONFLICT
            Only run the deadlock detector if a lock conflict has
            occurred since the last time that the deadlock detec-
            tor was run.

       The  _a_t_y_p_e  parameter specifies which transaction to abort
       in the case of deadlock.  It must be set to one of  values
       described  above  for  the  _l_k___d_e_t_e_c_t  field of the _D_B___E_N_V
       structure.

       The _l_o_c_k___d_e_t_e_c_t function returns the  value  of  _e_r_r_n_o  on
       failure and 0 on success.

       The  _l_o_c_k___d_e_t_e_c_t  function is the underlying function used
       by the _d_b___d_e_a_d_l_o_c_k(1) utility.  See the  source  code  for
       the   _d_b___d_e_a_d_l_o_c_k   utility   for   an  example  of  using
       _l_o_c_k___d_e_t_e_c_t in a UNIX environment.

  _l_o_c_k___s_t_a_t
       The _l_o_c_k___s_t_a_t function creates a statistical structure and
       copies  a  pointer  to  it  into the user-specified memory
       location.

       Statistical structure are created in allocated memory.  If
       _d_b___m_a_l_l_o_c  is  non-NULL, it is called to allocate the mem-
       ory, otherwise, the library function  _m_a_l_l_o_c(3)  is  used.
       The  function _d_b___m_a_l_l_o_c must match the calling conventions
       of the _m_a_l_l_o_c(3) library routine.  Regardless, the  caller
       is  responsible  for deallocating the returned memory.  To
       deallocate the returned memory, free each returned  memory
       pointer;  pointers  inside  the  memory  do not need to be
       individually freed.

       The lock region statistics are stored in  a  structure  of
       type  DB_LOCK_STAT  (typedef'd  in <db.h>).  The following
       DB_LOCK_STAT fields will be filled in:

       u_int32_t st_magic;
            The magic number that identifies a  file  as  a  lock
            file.
       u_int32_t st_version;
            The version of the lock file type.
       u_int32_t st_refcnt;
            The number of references to the region.
       u_int32_t st_regsize;
            The size of the region.
       u_int32_t st_maxlocks;
            The maximum number of locks possible.
       u_int32_t st_nmodes;
            The number of lock modes.
       u_int32_t st_numobjs;
            The number of unique objects locked.
       u_int32_t st_nlockers;
            The number of unique lockers.
       u_int32_t st_nconflicts;
            The  total  number of locks not immediately available
            due to conflicts.
       u_int32_t st_nrequests;
            The total number of locks requested.
       u_int32_t st_nreleases;
            The total number of locks released.
       u_int32_t st_ndeadlocks
            The number of deadlocks detected.
       u_int32_t st_region_wait;
            The number of times that  a  thread  of  control  was
            forced to wait before obtaining the region lock.
       u_int32_t st_region_nowait;
            The number of times that a thread of control was able
            to obtain the region lock without waiting.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The following environment variables affect  the  execution
       of _d_b___l_o_c_k:

       DB_HOME
            If  the  _d_b_e_n_v  argument to _l_o_c_k___o_p_e_n was initialized
            using _d_b___a_p_p_i_n_i_t, the  environment  variable  DB_HOME
            may  be used as the path of the database home for the
            interpretation of the _d_i_r argument to  _l_o_c_k___o_p_e_n,  as
            described in _d_b___a_p_p_i_n_i_t(3).

       TMPDIR
            If  the  _d_b_e_n_v  argument to _l_o_c_k___o_p_e_n was NULL or not
            initialized using _d_b___a_p_p_i_n_i_t, the  environment  vari-
            able  TMPDIR may be used as the directory in which to
            create the lock table, as described in the  _l_o_c_k___o_p_e_n
            section above.

SSTTAANNDDAARRDD LLOOCCKK MMOODDEESS
       The  include  file  <db.h> declares two commonly used con-
       flict arrays:
       const u_int8_t db_lock_rw_conflicts[];
            This is a conflict array for a  simple  scheme  using
            shared and exclusive lock modes.

       const u_int8_t db_lock_riw_conflicts[];
            This is a conflict array that involves various intent
            lock modes (e.g., intent shared) that  are  used  for
            multigranularity locking.

       Their associated sizes are DB_LOCK_RW_N and DB_LOCK_RIW_N.

       In addition, the include  file  <db.h>  defines  the  type
       _d_b___l_o_c_k_m_o_d_e___t,  which  is  the type of the lock modes used
       with the standard tables above:

              DB_LOCK_NG
                   not granted (always 0)

              DB_LOCK_READ
                   read (shared)

              DB_LOCK_WRITE
                   write (exclusive)

EERRRROORRSS
       The _l_o_c_k___o_p_e_n function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: close(2), db_version(3), fcntl(2), fflush(3),
       lock_unlink(3), lseek(2), malloc(3), memcpy(3), memset(3),
       mmap(2), munmap(2), open(2), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), unlink(2), and write(2).

       In addition, the _l_o_c_k___o_p_e_n function may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            The  shared memory region was locked and (repeatedly)
            unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_THREAD flag was specified  and  spinlocks  are
            not implemented for this architecture.

       The _l_o_c_k___v_e_c function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: fcntl(2), fflush(3), lock_detect(3), lseek(2),
       memcpy(3), memset(3), mmap(2), munmap(2), strerror(3), and
       write(2).

       In  addition,  the  _l_o_c_k___v_e_c  function may fail and return
       _e_r_r_n_o for the following conditions:
       [EACCES]
            An attempt was made to release lock held  by  another
            locker.

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _l_o_c_k___g_e_t function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: fcntl(2), fflush(3), lock_detect(3), lseek(2),
       memcpy(3), memset(3), mmap(2), munmap(2), strerror(3), and
       write(2).

       In  addition,  the  _l_o_c_k___g_e_t  function may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _l_o_c_k___p_u_t function may fail and return _e_r_r_n_o for any of
       the  errors  specified  for  the  following DB and library
       functions: fcntl(2), fflush(3), lock_detect(3), lseek(2),
       memcpy(3), memset(3), mmap(2), munmap(2), strerror(3), and
       write(2).

       In addition, the _l_o_c_k___p_u_t function  may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EACCES]
            An  attempt  was made to release lock held by another
            locker.

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _l_o_c_k___c_l_o_s_e function may fail and return _e_r_r_n_o for  any
       of  the  errors specified for the following DB and library
       functions: close(2), fcntl(2), fflush(3), munmap(2), and
       strerror(3).

       The _l_o_c_k___u_n_l_i_n_k function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: close(2), fcntl(2), fflush(3), malloc(3), mem-
       cpy(3), memset(3), mmap(2), munmap(2), open(2), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3), strlen(3), and unlink(2).

       In addition, the _l_o_c_k___u_n_l_i_n_k function may fail and  return
       _e_r_r_n_o for the following conditions:

       [EBUSY]
            The  shared  memory  region  was in use and the force
            flag was not set.


       The _l_o_c_k___d_e_t_e_c_t function may fail and return _e_r_r_n_o for any
       of  the  errors specified for the following DB and library
       functions: calloc(3), fcntl(2), fflush(3), lseek(2), mal-
       loc(3), memcpy(3), memset(3), mmap(2), munmap(2), str-
       error(3), and write(2).

BBUUGGSS
       If a process dies while holding locks, those locks  remain
       held  and are nneevveerr released.  In this case, all processes
       should exit as quickly as possible, so that _d_b___r_e_c_o_v_e_r can
       be run.

SSEEEE AALLSSOO
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___i_n_t_e_r_n_a_l(3),
       _d_b___l_o_c_k(3), _d_b___l_o_g(3), _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_h_r_e_a_d(3),
       _d_b___t_x_n(3)
