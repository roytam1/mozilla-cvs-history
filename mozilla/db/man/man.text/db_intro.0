

NNAAMMEE
       db - the DB library overview and introduction

DDEESSCCRRIIPPTTIIOONN
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see _d_b___i_n_t_r_o(3).

       The  DB  library  does  not  provide user interfaces, data
       entry GUI's, SQL support or  any  of  the  other  standard
       user-level  database interfaces.  What it does provide are
       the programmatic building blocks that allow you to  easily
       embed  database-style functionality and support into other
       objects or interfaces.

AARRCCHHIITTEECCTTUURREE
       The DB library supports two different models  of  applica-
       tions: client-server and embedded.

       In  the  client-server model, a database server is created
       by writing an application that accepts requests  via  some
       form  of IPC and issues calls to the DB functions based on
       those queries.  In this  model,  applications  are  client
       programs that attach to the server and issue queries.  The
       client-server model trades performance for protection,  as
       it  does not require that the applications share a protec-
       tion domain with the  server,  but  IPC/RPC  is  generally
       slower than a function call.  In addition, this model sim-
       plifies the creation  of  network  client-server  applica-
       tions.

       In the embedded model, an application links the DB library
       directly into its address space.  This provides for faster
       access  to  database  functionality,  but  means  that the
       applications sharing log files, lock manager,  transaction
       manager  or  memory pool manager have the ability to read,
       write, and corrupt each other's data.

       It is the application designer's responsibility to  select
       the appropriate model for their application.

       Applications  require a single include file, _<_d_b_._h_>, which
       must be installed in an appropriate location on  the  sys-
       tem.

CC++++
       The  C++  classes provide a thin wrapper around the C API,
       with the major advantages being improved encapsulation and
       an optional exception mechanism for errors.


       The  classes  and  methods  are  named  in  a fashion that
       directly corresponds to structures and functions in the  C
       interface.   Likewise,  arguments to methods appear in the
       same order as  the  C  interface,  except  to  remove  the
       explicit  ``this''  pointer.   The #defines used for flags
       are identical between the C and C++ interfaces.

       As a rule, each C++ object has exactly one structure  from
       the  underlying C API associated with it.  The C structure
       is allocated with each constructor  call  and  deallocated
       with each destructor call.  Thus, the rules the user needs
       to follow in allocating and  deallocating  structures  are
       the same between the C and C++ interfaces.

       To ensure portability to many platforms, both new and old,
       we  make  few  assumptions  about  the  C++  compiler  and
       library.   For example, we do not expect STL, templates or
       namespaces to be available.  The newest C++  feature  used
       is  exceptions, which are used liberally to transmit error
       information.  Even the use of exceptions can  be  disabled
       at   runtime,   by   using  _D_b_E_n_v_:_:_s_e_t___e_r_r_o_r___m_o_d_e_l()  (see
       _D_b_E_n_v(3)).  For a discussion of the  exception  mechanism,
       see _D_b_E_x_c_e_p_t_i_o_n(3).

       For  the rest of this manual page, C interfaces are listed
       as the primary reference,  and  C++  interfaces  following
       parenthetically, e.g., _d_b___o_p_e_n (_D_b_:_:_o_p_e_n).

JJAAVVAA
       The  Java classes provide a layer around the C API that is
       almost identical to the C++ layer.  The classes and  meth-
       ods are, for the most part identical to the C++ layer.  Db
       constants and #defines are represented  as  "static  final
       int" values.  Errors conditions appear as Java exceptions.

       As in C++, each Java object has exactly one structure from
       the  underlying C API associated with it.  The Java struc-
       ture is allocated with each constructor or open call,  but
       is deallocated only when the Java GC does so.  Because the
       timing or ordering of GC  is  not  predictable,  the  user
       should  take  care  to do a close() when finished with any
       object that has such a method.


SSUUBBSSYYSSTTEEMMSS
       The DB library is made up of  five  major  subsystems,  as
       follows:

       Access methods
            The  access  methods subsystem is made up of general-
            purpose support for creating and accessing files for-
            matted as B+tree's, hashed files, and fixed and vari-
            able length records.  These modules are useful in the
            absence of transactions for processes that need fast,
            formatted file support.  See _d_b___o_p_e_n(3)  and  _d_b___c_u_r_-
            _s_o_r(3) (_D_b(3) and _D_b_c(3)) for more information.

       Locking
            The  locking subsystem is a general-purpose lock man-
            ager used by  DB.   This  module  is  useful  in  the
            absence  of  the rest of the DB package for processes
            that require a fast, configurable lock manager.   See
            _d_b___l_o_c_k(3)  (_D_b_L_o_c_k_T_a_b(3)  and  _D_b_L_o_c_k(3))  for  more
            information.

       Logging
            The logging subsystem is the logging support used  to
            support the DB transaction model.  It is largely spe-
            cific to the DB package,  and  unlikely  to  be  used
            elsewhere.   See _d_b___l_o_g(3) (_D_b_L_o_g(3)) for more infor-
            mation.

       Memory Pool
            The memory  pool  subsystem  is  the  general-purpose
            shared memory buffer pool used by DB.  This module is
            useful outside of the DB package for  processes  that
            require  page-oriented,  cached,  shared file access.
            See _d_b___m_p_o_o_l(3) (_D_b_M_p_o_o_l(3) and  _D_b_M_p_o_o_l_F_i_l_e(3))  for
            more information.

       Transactions
            The  transaction subsystem implements the DB transac-
            tion model.  It is largely specific to the  DB  pack-
            age.   See  _d_b___t_x_n(3)  (_D_b_T_x_n_M_g_r(3) and _D_b_T_x_n(3)) for
            more information.

       There are several stand-alone utilities that  support  the
       DB environment.  They are as follows:

       db_archive
            The  _d_b___a_r_c_h_i_v_e  utility  supports  database  backup,
            archival   and   log   file   administration.     See
            _d_b___a_r_c_h_i_v_e(1) for more information.

       db_recover
            The _d_b___r_e_c_o_v_e_r utility runs after an unexpected DB or
            system failure to restore the database to  a  consis-
            tent  state.  See _d_b___r_e_c_o_v_e_r(1) for more information.

       db_checkpoint
            The _d_b___c_h_e_c_k_p_o_i_n_t utility runs as a  daemon  process,
            monitoring  the database log and periodically issuing
            checkpoints.  See _d_b___c_h_e_c_k_p_o_i_n_t(1) for more  informa-
            tion.

       db_deadlock
            The  _d_b___d_e_a_d_l_o_c_k  utility  runs  as a daemon process,
            periodically traversing the database lock  structures
            and aborting transactions when it detects a deadlock.
            See _d_b___d_e_a_d_l_o_c_k(1) for more information.

       db_dump
            The _d_b___d_u_m_p utility writes a copy of the database  to
            a   flat-text   file   in  a  portable  format.   See
            _d_b___d_u_m_p(1) for more information.

       db_load
            The _d_b___l_o_a_d utility reads the flat-text file produced
            by  _d_b___d_u_m_p,  and loads it into a database file.  See
            _d_b___l_o_a_d(1) for more information.

       db_stat
            The _d_b___s_t_a_t utility displays statistics for databases
            and  database  environments.  See _d_b___s_t_a_t(1) for more
            information.

NNAAMMIINNGG AANNDD TTHHEE DDBB EENNVVIIRROONNMMEENNTT
       The  DB  application  environment  is  described  by   the
       _d_b___a_p_p_i_n_i_t(3)  (_D_b_E_n_v(3))  manual  page.   The  _d_b___a_p_p_i_n_i_t
       (_D_b_E_n_v_:_:_a_p_p_i_n_i_t) function is used to create  a  consistent
       naming scheme for all of the subsystems sharing a DB envi-
       ronment.  If _d_b___a_p_p_i_n_i_t (_D_b_E_n_v_:_:_a_p_p_i_n_i_t) is not called  by
       a  DB application, naming is performed as specified by the
       manual page for the specific subsystem.

       DB applications that run with additional privilege  should
       always  call  the  _d_b___a_p_p_i_n_i_t (_D_b_E_n_v_:_:_a_p_p_i_n_i_t) function to
       initialize DB naming for their application.  This  ensures
       that  the  environment  variables  DB_HOME and TMPDIR will
       only be used if the application explicitly specifies  that
       they are safe.

AADDMMIINNIISSTTEERRIINNGG TTHHEE DDBB EENNVVIIRROONNMMEENNTT
       A DB environment consists of a database home directory and
       all the long-running daemons necessary to ensure continued
       functioning  of  DB and its applications.  In the presence
       of transactions,  the  checkpoint  daemon,  _d_b___c_h_e_c_k_p_o_i_n_t,
       must be run as long as there are applications present (see
       _d_b___c_h_e_c_k_p_o_i_n_t(1) for  details).   When  locking  is  being
       used,  the deadlock detection daemon, _d_b___d_e_a_d_l_o_c_k, must be
       run  as  long  as  there  are  applications  present  (see
       _d_b___d_e_a_d_l_o_c_k(1)  for details).  The _d_b___a_r_c_h_i_v_e utility pro-
       vides information to facilitate log reclamation  and  cre-
       ation   of   database  snapshots  (see  _d_b___a_r_c_h_i_v_e(1)  for
       details).   After  application  or  system  failure,   the
       _d_b___r_e_c_o_v_e_r utility must be run before any applications are
       restarted to return the database  to  a  consistent  state
       (see _d_b___r_e_c_o_v_e_r(1) for details).

       The  simplest  way to administer a DB application environ-
       ment is to create a single ``home'' directory that  houses
       all the files for the applications that are sharing the DB
       environment.  In this model,  the  shared  memory  regions
       (i.e.,  the locking, logging, memory pool, and transaction
       regions) and log files will be  stored  in  the  specified
       directory  hierarchy.   In addition, all data files speci-
       fied using relative pathnames will be  named  relative  to
       this home directory.  When recovery needs to be run (e.g.,
       after system or application failure),  this  directory  is
       specified  as the home directory to _d_b___r_e_c_o_v_e_r(1), and the
       system is restored to a consistent state,  ready  for  the
       applications to be restarted.

       In situations where further customization is desired, such
       as placing the log files on a separate device, it is  rec-
       ommended  that the application installation process create
       a configuration file named ``DB_CONFIG'' in  the  database
       home   directory,   specifying   the  customization.   See
       _d_b___a_p_p_i_n_i_t(3) (_D_b_E_n_v(3)) for details on this procedure.

       The DB architecture does not support  placing  the  shared
       memory  regions  on  remote filesystems, e.g., the Network
       File System (NFS) and the Andrew File System  (AFS).   For
       this  reason, the database home directory must reside on a
       local filesystem.   Databases,  log  files  and  temporary
       files  may  be  placed on remote filesystems, although the
       application may incur a performance penalty for doing  so.

       It is important to realize that all applications sharing a
       single home directory implicitly trust each  other.   They
       have  access  to  each  other's  data as it resides in the
       shared memory buffer pool and will share resources such as
       buffer  space  and  locks.  At the same time, any applica-
       tions that access the same files mmuusstt share an environment
       if  consistency  is  to be maintained across the different
       applications.

EERRRROORR RREETTUURRNNSS
       Except for the historic _d_b_m and  _h_s_e_a_r_c_h  interfaces  (see
       _d_b___d_b_m(3)  and  _d_b___h_s_e_a_r_c_h(3)), DB does not use the global
       variable _e_r_r_n_o to return error values.  The return  values
       for all DB functions can be grouped into three categories:

        0   A return value of 0 indicates that the operation  was
            successful.

       >0   A  return value that is greater than 0 indicates that
            there was a system error.  The _e_r_r_n_o  value  returned
            by the system is returned by the function, e.g., when
            a DB function  is  unable  to  allocate  memory,  the
            return value from the function will be ENOMEM.

       <0   A return value that is less than 0 indicates a condi-
            tion that was not a system failure, but  was  not  an
            unqualified  success, either.  For example, a routine
            to retrieve a key/data pair  from  the  database  may
            return  DB_NOTFOUND  when  the key/data pair does not
            appear in the database, as opposed to the value of 0,
            which  would  be  returned  if the key/data pair were
            found in  the  database.   All  such  special  values
            returned  by DB functions are less than 0 in order to
            avoid conflict with possible values of _e_r_r_n_o.

       There are two special return values that are somewhat sim-
       ilar  in  meaning, are returned in similar situations, and
       therefore might be confused: DB_NOTFOUND and  DB_KEYEMPTY.
       The  DB_NOTFOUND error return indicates that the requested
       key/data pair did not exist in the database or that start-
       or  end-of-file  has  been reached.  The DB_KEYEMPTY error
       return indicates that the requested  key/data  pair  logi-
       cally  exists  but  was  never  explicitly  created by the
       application (the recno access  method  will  automatically
       create   key/data  pairs  under  some  circumstances,  see
       _d_b___o_p_e_n(3) (_D_b(3)) for  more  information),  or  that  the
       requested  key/data pair was deleted and is currently in a
       deleted state.

SSIIGGNNAALLSS
       When applications using DB receive signals, it  is  impor-
       tant  that  they  exit gracefully, discarding any DB locks
       that they may hold.  This is normally done  by  setting  a
       flag  when  a  signal  arrives, and then checking for that
       flag periodically within the  application.   Specifically,
       the  signal  handler  should  not attempt to release locks
       and/or close the database handles  itself.   This  is  not
       guaranteed  to  work  correctly  and the results are unde-
       fined.

       If an application exits holding a lock, the  situation  is
       no  different  than  if  the  application crashed, and all
       applications participating  in  the  database  environment
       must be shutdown, and then recovery must be performed.  If
       this is not done, the locks that the application held  can
       cause  unresolvable  deadlocks  inside  the  database, and
       applications may then hang.

MMUULLTTII--TTHHRREEAADDIINNGG
       See _d_b___t_h_r_e_a_d(3) for information on using DB  in  threaded
       applications.

DDAATTAABBAASSEE AANNDD PPAAGGEE SSIIZZEESS
       DB  stores  database  file page numbers as unsigned 32-bit
       numbers and database file page sizes  as  unsigned  16-bit
       numbers.  This results in a maximum database size of 2^48.
       The minimum database page size is 512 bytes, resulting  in
       a minimum maximum database size of 2^41.

       DB  is potentially further limited if the host system does
       not have filesystem support for files  larger  than  2^32,
       including seeking to absolute offsets within such files.

       The maximum btree depth is 255.

BBYYTTEE OORRDDEERRIINNGG
       The  database files created by DB can be created in either
       little or big-endian formats.  By default, the native for-
       mat  of  the machine on which the database is created will
       be used.  Any format database can be  used  on  a  machine
       with  a  different  native format, although it is possible
       that the application will incur a performance penalty  for
       the run-time conversion.

EEXXTTEENNDDIINNGG DDBB
       DB  includes tools to simplify the development of applica-
       tion-specific logging and recovery.  Specifically, given a
       description  of  the information to be logged, these tools
       will automatically  create  logging  functions  (functions
       that  take the values as parameters and construct a single
       record that is written to the log), read functions  (func-
       tions  that  read  a  log record and unmarshall the values
       into a structure that maps onto the values  you  chose  to
       log),  a print function (for debugging), templates for the
       recovery functions,  and  automatic  dispatching  to  your
       recovery functions.

EEXXAAMMPPLLEESS
       There  are  a  number  of  examples  included  with the DB
       library distribution, intended to demonstrate various ways
       of using the DB library.

       Some  applications  require  the use of formatted files to
       store data, but do not require concurrent access  and  can
       cope  with  the  loss of data due to catastrophic failure.
       Generally, these applications create short-lived databases
       that  are  discarded  or  recreated when the system fails.
       Such applications need only use  the  DB  access  methods.
       The  DB access methods will use the memory pool subsystem,
       but the application is unlikely to do so explicitly.   See
       the files _e_x_a_m_p_l_e_s_/_e_x___a_c_c_e_s_s_._c, _e_x_a_m_p_l_e_s_/_e_x___b_t_r_e_c_._c, _e_x_a_m_-
       _p_l_e_s___c_x_x_/_A_c_c_e_s_s_E_x_a_m_p_l_e_._c_p_p    and     _j_a_v_a_/_s_r_c_/_c_o_m_/_s_l_e_e_p_y_-
       _c_a_t_/_e_x_a_m_p_l_e_s_/_A_c_c_e_s_s_E_x_a_m_p_l_e_._j_a_v_a in the DB source distribu-
       tion for C, C++, and Java language code  examples  of  how
       such applications might use the DB library.

       Some applications require the use formatted files to store
       data,    but    also    need    to    use    _d_b___a_p_p_i_n_i_t(3)
       (_D_b_E_n_v_:_:_a_p_p_i_n_i_t(3))  for  environment initialization.  See
       the files _e_x_a_m_p_l_e_s_/_e_x___a_p_p_i_n_i_t_._c, _e_x_a_m_p_l_e_s___c_x_x_/_A_p_p_i_n_i_t_E_x_a_m_-
       _p_l_e_._c_p_p   or  _j_a_v_a_/_s_r_c_/_c_o_m_/_s_l_e_e_p_y_c_a_t_/_e_x_a_m_p_l_e_s_/_A_p_p_i_n_i_t_E_x_a_m_-
       _p_l_e_._j_a_v_a in the DB source distribution for C, C++ and Java
       language  code  examples  of how such an application might
       use the DB library.

       Some applications use the DB access methods, but are  also
       concerned  about  catastrophic failure, and therefore need
       to transaction protect the underlying DB files.   See  the
       files  _e_x_a_m_p_l_e_s_/_e_x___t_p_c_b_._c, _e_x_a_m_p_l_e_s___c_x_x_/_T_p_c_b_E_x_a_m_p_l_e_._c_p_p or
       _j_a_v_a_/_s_r_c_/_c_o_m_/_s_l_e_e_p_y_c_a_t_/_e_x_a_m_p_l_e_s_/_T_p_c_b_E_x_a_m_p_l_e_._j_a_v_a in the DB
       source  distribution  for  C,  C++  and Java language code
       examples of how such  an  application  might  use  the  DB
       library.

       Some  applications will benefit from the ability to buffer
       input files other than the  underlying  DB  access  method
       files.    See   the  files  _e_x_a_m_p_l_e_s_/_e_x___m_p_o_o_l_._c  or  _e_x_a_m_-
       _p_l_e_s___c_x_x_/_M_p_o_o_l_E_x_a_m_p_l_e_._c_p_p in the  DB  source  distribution
       for C and C++ language code examples of how such an appli-
       cation might use the DB library.

       Some applications need a general-purpose lock manager sep-
       arate from locking support for the DB access methods.  See
       the files _e_x_a_m_p_l_e_s_/_e_x___l_o_c_k_._c, _e_x_a_m_p_l_e_s___c_x_x_/_L_o_c_k_E_x_a_m_p_l_e_._c_p_p
       or _j_a_v_a_/_s_r_c_/_c_o_m_/_s_l_e_e_p_y_c_a_t_/_e_x_a_m_p_l_e_s_/_L_o_c_k_E_x_a_m_p_l_e_._j_a_v_a in the
       DB source distribution for C, C++ and Java  language  code
       examples  of  how  such  an  application  might use the DB
       library.

       Some applications will use the  DB  access  methods  in  a
       threaded fashion, including trickle flushing of the under-
       lying buffer pool and deadlock detection.   See  the  file
       _e_x_a_m_p_l_e_s_/_e_x___t_h_r_e_a_d_._c in the DB source distribution for a C
       language code example of how such an application might use
       the DB library.  Note that the Java API assumes a threaded
       environment and performs all  thread-specific  initializa-
       tion automatically.

CCOOMMPPAATTIIBBIILLIITTYY
       The DB 2.0 library provides backward compatible interfaces
       for the  historic  UNIX  _d_b_m(3),  _n_d_b_m(3)  and  _h_s_e_a_r_c_h(3)
       interfaces.   See  _d_b___d_b_m(3) and _d_b___h_s_e_a_r_c_h(3) for further
       information on these interfaces.  It also provides a back-
       ward   compatible  interface  for  the  historic  DB  1.85
       release.  DDBB 22..00 ddooeess nnoott pprroovviiddee  ddaattaabbaassee  ccoommppaattiibbiilliittyy
       ffoorr  aannyy  ooff  tthhee aabboovvee iinntteerrffaacceess,, aanndd eexxiissttiinngg ddaattaabbaasseess
       mmuusstt bbee ccoonnvveerrtteedd mmaannuuaallllyy..  To convert existing databases
       from  the  DB 1.85 format to the DB 2.0 format, review the
       _d_b___d_u_m_p_1_8_5(1) and _d_b___l_o_a_d(1) manual pages.

       The name space in DB 2.0 has been  changed  from  that  of
       previous  DB versions, notably version 1.85, for portabil-
       ity and consistency reasons.  The only name collisions  in
       the  two  libraries  are  the  names  used  by the _d_b_m(3),
       _n_d_b_m(3), _h_s_e_a_r_c_h(3) and the DB 1.85  compatibility  inter-
       faces.   To  include  both  DB 1.85 and DB 2.0 in a single
       library, remove the _d_b_m(3), _n_d_b_m(3) and _h_s_e_a_r_c_h(3)  inter-
       faces  from  either  of the two libraries, and the DB 1.85
       compatibility interface from the DB 2.0 library.  This can
       be done by editing the library Makefiles and reconfiguring
       and rebuilding the DB 2.0 library.  Obviously, if you  use
       the  historic  interfaces, you will get the version in the
       library from which you did not remove it.  Similarly,  you
       will  not be able to access DB 2.0 files using the DB 1.85
       compatibility interface, since you have removed that  from
       the library as well.

       It  is  possible  to simply relink applications written to
       the DB 1.85 interface against the DB 2.0 library.   Recom-
       pilation  of  such  applications is slightly more complex.
       When the DB 2.0 library  is  installed,  it  installs  two
       include  files,  _d_b_._h  and  _d_b___1_8_5_._h.   The former file is
       likely to replace the DB 1.85 version's include file which
       had the same name.  If this did not happen, recompiling DB
       1.85 applications to use the DB  2.0  library  is  simple:
       recompile  as  done  historically, and load against the DB
       2.0 library instead of the DB 1.85 library.  If,  however,
       the  DB 2.0 installation process has replaced the system's
       _d_b_._h include file, replace the  application's  include  of
       _d_b_._h with inclusion of _d_b___1_8_5_._h, recompile as done histor-
       ically, and then load against the DB 2.0 library.

       Applications written using the historic interfaces of  the
       DB  library  should not require significant effort to port
       to the DB 2.0 interfaces.   While  the  functionality  has
       been  greatly  enhanced  in DB 2.0, the historic interface
       and functionality and is largely unchanged.  Reviewing the
       application's calls into the DB library and updating those
       calls to the new names, flags and return values should  be
       sufficient.

       While loading applications that use the DB 1.85 interfaces
       against the DB 2.0 library, or converting DB 1.85 function
       calls  to  DB  2.0 function calls will work, reconsidering
       your application's interface to the DB database library in
       light  of the additional functionality in DB 2.0 is recom-
       mended, as it is likely to result in enhanced  application
       performance.

SSEEEE AALLSSOO:: AADDMMIINNIISSTTRRAATTIIVVEE AANNDD OOTTHHEERR UUTTIILLIITTIIEESS
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1)

SSEEEE AALLSSOO:: CC AAPPII
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___l_o_c_k(3), _d_b___l_o_g(3),
       _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_x_n(3)

SSEEEE AALLSSOO:: CC++++ aanndd JJaavvaa AAPPII
       _D_b(3), _D_b_c(3), _D_b_E_n_v(3), _D_b_E_x_c_e_p_t_i_o_n(3), _D_b_I_n_f_o(3), _D_b_L_o_c_k(3),
       _D_b_L_o_c_k_T_a_b(3), _D_b_L_o_g(3), _D_b_L_s_n(3), _D_b_M_p_o_o_l(3), _D_b_M_p_o_o_l_F_i_l_e(3),
       _D_b_t(3), _D_b_T_x_n(3), _D_b_T_x_n_M_g_r(3)

SSEEEE AALLSSOO:: AADDDDIITTIIOONNAALL RREEFFEERREENNCCEESS
       _L_I_B_T_P_: _P_o_r_t_a_b_l_e_, _M_o_d_u_l_a_r _T_r_a_n_s_a_c_t_i_o_n_s _f_o_r _U_N_I_X, Margo Seltzer,
       Michael Olson, USENIX proceedings, Winter 1992.
