

NNAAMMEE
       db_log - log management functions

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb..hh>>

       iinntt
       lloogg__ooppeenn((ccoonnsstt cchhaarr **ddiirr,,
            uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,, DDBB__EENNVV **ddbbeennvv,, DDBB__LLOOGG ****rreeggiioonnpp));;

       iinntt
       lloogg__cclloossee((DDBB__LLOOGG **llooggpp));;

       iinntt
       lloogg__fflluusshh((DDBB__LLOOGG **llooggpp,, ccoonnsstt DDBB__LLSSNN **llssnn));;

       iinntt
       lloogg__ggeett((DDBB__LLOOGG **llooggpp,, DDBB__LLSSNN **llssnn,, DDBBTT **ddaattaa,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       lloogg__ccoommppaarree((ccoonnsstt DDBB__LLSSNN **llssnn00,, ccoonnsstt DDBB__LLSSNN **llssnn11));;

       iinntt
       lloogg__ffiillee((DDBB__LLOOGG **llooggpp,, ccoonnsstt DDBB__LLSSNN **llssnn,, cchhaarr **nnaammeepp,, ssiizzee__tt lleenn));;

       iinntt
       lloogg__ppuutt((DDBB__LLOOGG **llooggpp,, DDBB__LLSSNN **llssnn,, ccoonnsstt DDBBTT **ddaattaa,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       lloogg__uunnlliinnkk((ccoonnsstt cchhaarr **ddiirr,, iinntt ffoorrccee,, DDBB__EENNVV **));;

       iinntt
       lloogg__aarrcchhiivvee((DDBB__LLOOGG **llooggpp,,
            cchhaarr ****lliisstt[[]],, uu__iinntt3322__tt ffllaaggss,, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt))));;

       iinntt
       lloogg__rreeggiisstteerr((DDBB__LLOOGG **llooggpp,,
            ccoonnsstt DDBB **ddbbpp,, ccoonnsstt cchhaarr **nnaammee,, DDBBTTYYPPEE ttyyppee,, uu__iinntt3322__tt **ffiiddpp));;

       iinntt
       lloogg__uunnrreeggiisstteerr((DDBB__LLOOGG **llooggpp,, uu__iinntt3322__tt ffiidd));;

       iinntt
       lloogg__ssttaatt((DDBB__LLOOGG **llooggpp,, DDBB__LLOOGG__SSTTAATT ****sspppp,, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt))));;

DDEESSCCRRIIPPTTIIOONN
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see _d_b___i_n_t_r_o(3).


       This manual page describes the specific details of the log
       manager.

       These functions provide a general-purpose logging facility
       sufficient for transaction management.  Logs can be shared
       by multiple processes.

       The DB transaction log is represented by a directory  con-
       taining  a  set  of  files.  The log is a record-oriented,
       append-only file, with records identified and accessed via
       _D_B___L_S_N's (database log sequence numbers).

       DB_LSN's  are returned on each _l_o_g___p_u_t operation, and only
       those DB_LSN's returned by _l_o_g___p_u_t can later  be  used  to
       retrieve records from the log.

  _l_o_g___o_p_e_n
       The _l_o_g___o_p_e_n function copies a pointer, to the log identi-
       fied by the ddiirreeccttoorryy _d_i_r, into the memory location refer-
       enced by _r_e_g_i_o_n_p.

       If  the  _d_b_e_n_v  argument to _l_o_g___o_p_e_n was initialized using
       _d_b___a_p_p_i_n_i_t,   _d_i_r   is   interpreted   as   described   by
       _d_b___a_p_p_i_n_i_t(3).

       Otherwise,  if _d_i_r is not NULL, it is interpreted relative
       to the current working directory of the process.   If  _d_i_r
       is  NULL,  the following environment variables are checked
       in order: ``TMPDIR'', ``TEMP'', and ``TMP''.   If  one  of
       them  is set, log files are created relative to the direc-
       tory it specifies.  If none of them  are  set,  the  first
       possible   one  of  the  following  directories  is  used:
       _/_v_a_r_/_t_m_p, _/_u_s_r_/_t_m_p, _/_t_e_m_p, _/_t_m_p, _C_:_/_t_e_m_p and _C_:_/_t_m_p.

       All files associated with the  log  are  created  in  this
       directory.  This directory must already exist when

       log_open  is  called.  If the log already exists, the pro-
       cess must have permission to read and write  the  existing
       files.   If  the log does not already exist, it is option-
       ally created and initialized.

       If the log region is  being  created  and  log  files  are
       already  present, the log files are ``recovered'' and sub-
       sequent log writes are appended to the end of the log.

       The log is stored in one or more files  in  the  specified
       directory.  Each file is named using the format

            log.NNNNN

       where  ``NNNNN'' is the sequence number of the file within
       the log.


       The _f_l_a_g_s and _m_o_d_e arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.


       DB_THREAD
            Cause  the  DB_LOG  handle  returned  by the _l_o_g___o_p_e_n
            function to be useable by multiple threads  within  a
            single  address space, i.e., to be ``free-threaded''.

       All files created by the log subsystem  are  created  with
       mode  _m_o_d_e  (as described in _c_h_m_o_d(2)) and modified by the
       process'  umask  value  at  the  time  of  creation   (see
       _u_m_a_s_k(2)).   The group ownership of created files is based
       on the system and directory defaults, and is  not  further
       specified by DB.

       The  logging  subsystem  is  configured based on the _d_b_e_n_v
       argument to _l_o_g___o_p_e_n, which is a pointer to a structure of
       type DB_ENV (typedef'd in <db.h>).  Applications will nor-
       mally  use  the  same  DB_ENV  structure  (initialized  by
       _d_b___a_p_p_i_n_i_t(3)), as an argument to all of the subsystems in
       the DB package.

       References to the DB_ENV structure are maintained  by  DB,
       so  it may not be discarded until the last close function,
       corresponding to an open function  for  which  it  was  an
       argument,  has returned.  In order to ensure compatibility
       with future releases of  DB,  all  fields  of  the  DB_ENV
       structure  that  are not explicitly set should be initial-
       ized to 0 before the first time the structure is used.  Do
       this  by declaring the structure external or static, or by
       calling the C library routine _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       The fields of the DB_ENV structure used  by  _l_o_g___o_p_e_n  are
       described  below.   If  _d_b_e_n_v is NULL or any of its fields
       are set to 0, defaults appropriate for the system are used
       where possible.

       The  following  fields in the DB_ENV structure may be ini-
       tialized before calling _l_o_g___o_p_e_n:

       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       int db_verbose;
            The error fields of the DB_ENV  behave  as  described
            for _d_b___a_p_p_i_n_i_t(3).


       u_int32_t lg_max;
            The  maximum  size  of  a  single  file  in  the log.
            Because DB_LSN file offsets are unsigned 4-byte  val-
            ues,  _l_g___m_a_x  may  not  be  larger  than  the maximum
            unsigned 4-byte value.

            If _l_g___m_a_x is 0, a default value is used.

            See the section "LOG FILE LIMITS" below, for  further
            information.

       The  _l_o_g___o_p_e_n function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _l_o_g___c_l_o_s_e
       The _l_o_g___c_l_o_s_e function closes the  log  specified  by  the
       _l_o_g_p argument.

       In  addition, if the _d_i_r argument to _l_o_g___o_p_e_n was NULL and
       _d_b_e_n_v was not initialized using _d_b___a_p_p_i_n_i_t, all files cre-
       ated  for  this  shared  region  will  be  removed,  as if
       _l_o_g___u_n_l_i_n_k were called.

       When multiple threads are using the DB_LOG handle  concur-
       rently,  only a single thread may call the _l_o_g___c_l_o_s_e func-
       tion.

       The _l_o_g___c_l_o_s_e function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _l_o_g___f_l_u_s_h
       The  _l_o_g___f_l_u_s_h  function  guarantees  that all log records
       whose LSNs are less than or equal  to  the  _l_s_n  parameter
       have been written to disk.  If _l_s_n is NULL, all records in
       the log are flushed.

       The _l_o_g___f_l_u_s_h function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _l_o_g___g_e_t
       The  _l_o_g___g_e_t  function  implements  a cursor inside of the
       log, retrieving records from the log according to the  _l_s_n
       and _f_l_a_g_s parameters.

       The  data field of the _d_a_t_a structure is set to the record
       retrieved and the size field indicates the number of bytes
       in  the  record.  See _d_b___d_b_t(3) for a description of other
       fields in the _d_a_t_a structure.  WWhheenn mmuullttiippllee  tthhrreeaaddss  aarree
       uussiinngg  tthhee rreettuurrnneedd DDBB__LLOOGG hhaannddllee ccoonnccuurrrreennttllyy,, eeiitthheerr tthhee
       DDBB__DDBBTT__MMAALLLLOOCC oorr DDBB__DDBBTT__UUSSEERRMMEEMM ffllaaggss  mmuusstt  bbee  ssppeecciiffiieedd
       ffoorr aannyy DDBBTT uusseedd ffoorr ddaattaa rreettrriieevvaall..


       The _f_l_a_g_s parameter must be set to exactly one of the fol-
       lowing values:

       DB_CHECKPOINT
            The last record written with the  DB_CHECKPOINT  flag
            specified  to the _l_o_g___p_u_t function is returned in the
            _d_a_t_a argument.  The _l_s_n argument is overwritten  with
            the  DB_LSN of the record returned.  If no record has
            been previously written with the  DB_CHECKPOINT  flag
            specified, the first record in the log is returned.

            If  the log is empty the _l_o_g___g_e_t function will return
            DB_NOTFOUND.

       DB_FIRST
            The first record from any of the log files  found  in
            the  log  directory is returned in the _d_a_t_a argument.
            The _l_s_n argument is overwritten with  the  DB_LSN  of
            the record returned.

            If  the log is empty the _l_o_g___g_e_t function will return
            DB_NOTFOUND.

       DB_LAST
            The last record in the log is returned  in  the  _d_a_t_a
            argument.   The  _l_s_n argument is overwritten with the
            DB_LSN of the record returned.

            If the log is empty, the _l_o_g___g_e_t function will return
            DB_NOTFOUND.

       DB_NEXT
            The  current  log  position  is  advanced to the next
            record in the log and that record is returned in  the
            _d_a_t_a  argument.  The _l_s_n argument is overwritten with
            the DB_LSN of the record returned.

            If the pointer has not been initialized via DB_FIRST,
            DB_LAST,  DB_SET,  DB_NEXT,  or DB_PREV, _l_o_g___g_e_t will
            return the first record in the log.  If the last  log
            record has already been returned or the log is empty,
            the _l_o_g___g_e_t function will return DB_NOTFOUND.

            If the log was opened with the  DB_THREAD  flag  set,
            calls  to  _l_o_g___g_e_t  with  the  DB_NEXT  flag set will
            return EINVAL.

       DB_PREV
            The current log position is  moved  to  the  previous
            record  in the log and that record is returned in the
            _d_a_t_a argument.  The _l_s_n argument is overwritten  with
            the DB_LSN of the record returned.

            If the pointer has not been initialized via DB_FIRST,
            DB_LAST, DB_SET, DB_NEXT, or  DB_PREV,  _l_o_g___g_e_t  will
            return  the last record in the log.  If the first log
            record has already been returned or the log is empty,
            the _l_o_g___g_e_t function will return DB_NOTFOUND.

            If  the  log  was opened with the DB_THREAD flag set,
            calls to _l_o_g___g_e_t  with  the  DB_PREV  flag  set  will
            return EINVAL.

       DB_CURRENT
            Return  the  log  record  currently referenced by the
            log.

            If the log  pointer  has  not  been  initialized  via
            DB_FIRST, DB_LAST, DB_SET, DB_NEXT, or DB_PREV, or if
            the log was  opened  with  the  DB_THREAD  flag  set,
            _l_o_g___g_e_t will return EINVAL.

       DB_SET
            Retrieve  the  record  specified by the _l_s_n argument.
            If the specified DB_LSN is invalid  (e.g.,  does  not
            appear in the log) _l_o_g___g_e_t will return EINVAL.

       Otherwise, the _l_o_g___g_e_t function returns the value of _e_r_r_n_o
       on failure and 0 on success.

  _l_o_g___c_o_m_p_a_r_e
       The _l_o_g___c_o_m_p_a_r_e function allows the caller to compare  two
       DB_LSN's.   _L_o_g___c_o_m_p_a_r_e  returns 0 if the two DB_LSN's are
       equal, 1 if _l_s_n_0 is greater than _l_s_n_1, and -1 if  _l_s_n_0  is
       less than _l_s_n_1.

  _l_o_g___f_i_l_e
       The  _l_o_g___f_i_l_e  function  maps DB_LSN's to file names.  The
       _l_o_g___f_i_l_e function copies the name of the  file  containing
       the  record  named  by _l_s_n into the memory location refer-
       enced by _n_a_m_e_p.  (This mapping of DB_LSN to file is needed
       for  database  administration.  For example, a transaction
       manager typically records the earliest DB_LSN  needed  for
       restart,  and  the  database  administrator  may  want  to
       archive log files to tape when they contain only  DB_LSN's
       before the earliest one needed for restart.)

       The  _l_e_n  argument  is  the  length of the _n_a_m_e_p buffer in
       bytes.  If _n_a_m_e_p is too  short  to  hold  the  file  name,
       _l_o_g___f_i_l_e  will  return  ENOMEM.  Note, as described above,
       log file names are quite short, on the order of 10 charac-
       ters.

       The  _l_o_g___f_i_l_e function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _l_o_g___p_u_t
       The _l_o_g___p_u_t function appends  records  to  the  log.   The
       DB_LSN of the put record is returned in the _l_s_n parameter.
       The _f_l_a_g_s parameter may be set to  one  of  the  following
       values:

       DB_CHECKPOINT
            The  log  should write a checkpoint record, recording
            any information necessary to make the log  structures
            recoverable after a crash.

       DB_CURLSN
            The  DB_LSN  of the next record to be put is returned
            in the _l_s_n parameter.

       DB_FLUSH
            The log is forced to disk after this record is  writ-
            ten,  guaranteeing that all records with DB_LSNs less
            than or equal to the one being put are on disk before
            this  function  returns  (this function is most often
            used for a transaction commit, see _d_b___t_x_n(3)).

       The caller is  responsible  for  providing  any  necessary
       structure to _d_a_t_a.  (For example, in a write-ahead logging
       protocol, the application must  understand  what  part  of
       _d_a_t_a  is an operation code, what part is redo information,
       and what part is  undo  information.   In  addition,  most
       transaction  managers will store in _d_a_t_a the DB_LSN of the
       previous log record for the same transaction,  to  support
       chaining back through the transaction's log records during
       undo.)

       The _l_o_g___p_u_t function returns the value of _e_r_r_n_o on failure
       and 0 on success.


  _l_o_g___u_n_l_i_n_k
       The _l_o_g___u_n_l_i_n_k function destroys the log region identified
       by the directory _d_i_r, removing all files used to implement
       the  log region.  (The log files themselves and the direc-
       tory _d_i_r are not removed.)  If there  are  processes  that
       have  called  _l_o_g___o_p_e_n  without  calling  _l_o_g___c_l_o_s_e (i.e.,
       there are  processes  currently  using  the  log  region),
       _l_o_g___u_n_l_i_n_k  will  fail  without further action, unless the
       force flag is set, in which case _l_o_g___u_n_l_i_n_k  will  attempt
       to remove the log region files regardless of any processes
       still using the log region.

       The result of attempting to forcibly  destroy  the  region
       when  a  process has the region open is unspecified.  Pro-
       cesses using a shared memory region maintain an open  file
       descriptor  for  it.   On UNIX systems, the region removal
       should succeed and processes that have already joined  the
       region  should  continue  to  run  in  the  region without
       change, however  processes  attempting  to  join  the  log
       region will either fail or attempt to create a new region.

       On other systems, e.g., WNT, where  the  _u_n_l_i_n_k(2)  system
       call  will fail if any process has an open file descriptor
       for the file, the region removal will fail.

       In the case of catastrophic or  system  failure,  database
       recovery  must  be  performed  (see  _d_b___r_e_c_o_v_e_r(1)  or the
       DB_RECOVER and DB_RECOVER_FATAL flags  to  _d_b___a_p_p_i_n_i_t(3)).
       Alternatively,  if  recovery  is  not  required because no
       database state is maintained across failures, it is possi-
       ble  to clean up a log region by removing all of the files
       in the directory specified to the  _l_o_g___o_p_e_n  function,  as
       log  region files are never created in any directory other
       than the one specified to _l_o_g___o_p_e_n.  Note,  however,  that
       this  has  the  potential  to  remove files created by the
       other DB subsystems in this database environment.

       The _l_o_g___u_n_l_i_n_k function returns  the  value  of  _e_r_r_n_o  on
       failure and 0 on success.

  _l_o_g___a_r_c_h_i_v_e
       The  _l_o_g___a_r_c_h_i_v_e  function creates a NULL-terminated array
       of log or database file names and copies a pointer to them
       into the user-specified memory location _l_i_s_t.

       By  default,  _l_o_g___a_r_c_h_i_v_e  returns the names of all of the
       log files that are no  longer  in  use  (e.g.,  no  longer
       involved in active transactions), and that may be archived
       for catastrophic recovery and then removed from  the  sys-
       tem.   If there were no file names to return, _l_i_s_t will be
       set to NULL.

       Arrays of log file names are created in allocated  memory.
       If  _d_b___m_a_l_l_o_c  is  non-NULL,  it is called to allocate the
       memory, otherwise, the library function _m_a_l_l_o_c(3) is used.
       The  function _d_b___m_a_l_l_o_c must match the calling conventions
       of the _m_a_l_l_o_c(3) library routine.  Regardless, the  caller
       is  responsible  for deallocating the returned memory.  To
       deallocate the returned memory, free each returned  memory
       pointer;  pointers  inside  the  memory  do not need to be
       individually freed.

       The _f_l_a_g_s argument is specified by oorr'ing together one  or
       more of the following values:

       DB_ARCH_ABS
            All  pathnames  are  returned  as absolute pathnames,
            instead of relative to the database home directory.

       DB_ARCH_DATA
            Return the database files that need to be archived in
            order to recover the database from catastrophic fail-
            ure.  If any of the  database  files  have  not  been
            accessed  during  the  lifetime  of  the  current log
            files, _l_o_g___a_r_c_h_i_v_e will  not  include  them  in  this
            list.   It  is  also  possible that some of the files
            referenced in the log have since  been  deleted  from
            the system.

       DB_ARCH_LOG
            Return  all  the log file names regardless of whether
            or not they are in use.

       The DB_ARCH_DATA and DB_ARCH_LOG flags are mutually exclu-
       sive.

       The  _l_o_g___a_r_c_h_i_v_e  function  returns  the value of _e_r_r_n_o on
       failure and 0 on success.

       The _l_o_g___a_r_c_h_i_v_e function is the underlying  function  used
       by the _d_b___a_r_c_h_i_v_e(1) utility.  See the source code for the
       _d_b___a_r_c_h_i_v_e utility for an example of using _l_o_g___a_r_c_h_i_v_e  in
       a UNIX environment.  See the _d_b___a_r_c_h_i_v_e(1) manual page for
       more information on database archival procedures.

  _l_o_g___r_e_g_i_s_t_e_r
       The _l_o_g___r_e_g_i_s_t_e_r function registers a file name  with  the
       log  manager  and copies a file identification number into
       the memory location referenced by _f_i_d_p.  This file identi-
       fication  number should be used in all subsequent log mes-
       sages that refer to operations on this file.  The log man-
       ager  records  all file name to file identification number
       mappings at each checkpoint so that a recovery process can
       identify the file to which a record in the log refers.

       The  _l_o_g___r_e_g_i_s_t_e_r function is called when an access method
       registers the open of a file.  The _d_b_p parameter should be
       a  pointer  to the DB structure which is being returned by
       the access method.

       The _t_y_p_e parameter should be one of the DB types specified
       in _d_b___o_p_e_n(3), e.g., DB_HASH.

       The  _l_o_g___r_e_g_i_s_t_e_r  function  returns the value of _e_r_r_n_o on
       failure and 0 on success.

  _l_o_g___u_n_r_e_g_i_s_t_e_r
       The _l_o_g___u_n_r_e_g_i_s_t_e_r function disassociates the file name to
       file  identification number mapping for the file identifi-
       cation number specified by the _f_i_d  parameter.   The  file
       identification number may then be reused.

       The  _l_o_g___u_n_r_e_g_i_s_t_e_r function returns the value of _e_r_r_n_o on
       failure and 0 on success.

  _l_o_g___s_t_a_t
       The _l_o_g___s_t_a_t function creates a statistical structure  and
       copies  a  pointer  to  it  into the user-specified memory
       location.

       Statistical structure are created in allocated memory.  If
       _d_b___m_a_l_l_o_c  is  non-NULL, it is called to allocate the mem-
       ory, otherwise, the library function  _m_a_l_l_o_c(3)  is  used.
       The  function _d_b___m_a_l_l_o_c must match the calling conventions
       of the _m_a_l_l_o_c(3) library routine.  Regardless, the  caller
       is  responsible  for deallocating the returned memory.  To
       deallocate the returned memory, free each returned  memory
       pointer;  pointers  inside  the  memory  do not need to be
       individually freed.

       The log region statistics are stored  in  a  structure  of
       type  DB_LOG_STAT  (typedef'd  in  <db.h>).  The following
       DB_LOG_STAT fields will be filled in:

       u_int32_t st_magic;
            The magic number that identifies  a  file  as  a  log
            file.
       u_int32_t st_version;
            The version of the log file type.
       u_int32_t st_refcnt;
            The number of references to the region.
       u_int32_t st_regsize;
            The size of the region.
       int st_mode;
            The mode of any created log files.
       u_int32_t st_lg_max;
            The  maximum  size  of any individual file comprising
            the log.
       u_int32_t st_w_mbytes;
            The number of megabytes written to this log.
       u_int32_t st_w_bytes;
            The number of bytes over and above _s_t___w___m_b_y_t_e_s  writ-
            ten to this log.
       u_int32_t st_wc_mbytes;
            The number of megabytes written to this log since the
            last checkpoint.
       u_int32_t st_wc_bytes;
            The number of bytes over and above _s_t___w_c___m_b_y_t_e_s writ-
            ten to this log since the last checkpoint.
       u_int32_t st_cur_file;
            The current log file number.
       u_int32_t st_cur_offset;
            The byte offset in the current log file.
       u_int32_t st_region_wait;
            The  number  of  times  that  a thread of control was
            forced to wait before obtaining the region lock.
       u_int32_t st_region_nowait;
            The number of times that a thread of control was able
            to obtain the region lock without waiting.

LLOOGG FFIILLEE LLIIMMIITTSS
       Log file sizes impose a time limit on the length of time a
       database may be  accessed  under  transaction  protection,
       before  it needs to be dumped and reloaded (see _d_b___d_u_m_p_(_3_)
       and _d_b___l_o_a_d_(_3_)_)_.  Unfortunately,  the  limits  are  poten-
       tially difficult to calculate.

       The log file name consists of "log." followed by 5 digits,
       resulting in a maximum of 99,999 log files.   Consider  an
       application performing 600 transactions per second, for 15
       hours a day, logged into 10Mb log files, where each trans-
       action  is  logging  approximately 100 bytes of data.  The
       calculation:

              (10 * 2^20 * 99999) /
                   (600 * 60 * 60 * 15 * 100) = 323.63

       indicates that the system will run out of log  file  space
       in  roughly  324 days.  If we increase the maximum size of
       the files from 10Mb to 100Mb, the same  calculation  indi-
       cates  that the application will run out of log file space
       in roughly 9 years.

       There is no way to reset the log file name space in Berke-
       ley  DB.   If  your application is reaching the end of its
       log file name space, you should:

       1.   Archive your databases as if to  prepare  for  catas-
            trophic  failure (see _d_b___a_r_c_h_i_v_e(1) for more informa-
            tion).

       2.   Dump and re-load aallll your databases  (see  _d_b___d_u_m_p(1)
            and _d_b___l_o_a_d(1) for more information).

       3.   Remove  all  of the log files from the database envi-
            ronment (see _d_b___a_r_c_h_i_v_e(1) for more information).

       4.   Restart your applications.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The following environment variables affect  the  execution
       of _d_b___l_o_g:

       DB_HOME
            If  the  _d_b_e_n_v  argument  to _l_o_g___o_p_e_n was initialized
            using _d_b___a_p_p_i_n_i_t, the  environment  variable  DB_HOME
            may  be used as the path of the database home for the
            interpretation of the _d_i_r argument  to  _l_o_g___o_p_e_n,  as
            described  in  _d_b___a_p_p_i_n_i_t(3).  Specifically, _l_o_g___o_p_e_n
            is affected by  the  configuration  string  value  of
            DB_LOG_DIR.

       TMPDIR
            If  the  _d_b_e_n_v  argument  to _l_o_g___o_p_e_n was NULL or not
            initialized using _d_b___a_p_p_i_n_i_t, the  environment  vari-
            able  TMPDIR may be used as the directory in which to
            create the log, as described in the _l_o_g___o_p_e_n  section
            above.
EERRRROORRSS
       The _l_o_g___o_p_e_n function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: atoi(3), close(2), db_version(3), fcntl(2),
       fflush(3), log_close(3), log_unlink(3), lseek(2), mal-
       loc(3), memcpy(3), memset(3), mmap(2), munmap(2), open(2),
       opendir(3), read(2), readdir(3), realloc(3), sig-
       fillset(3), sigprocmask(2), stat(2), strchr(3), strcpy(3),
       strdup(3), strerror(3), strlen(3), strncmp(3), unlink(2),
       and write(2).

       In  addition,  the  _l_o_g___o_p_e_n  function may fail and return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            The shared memory region was locked and  (repeatedly)
            unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The  DB_THREAD  flag  was specified and spinlocks are
            not implemented for this architecture.

            The specified file size was too large.

       The _l_o_g___c_l_o_s_e function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: close(2), fcntl(2), fflush(3), munmap(2), and
       strerror(3).

       The  _l_o_g___f_l_u_s_h  function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: close(2), fcntl(2), fflush(3), fsync(2),
       lseek(2), malloc(3), memcpy(3), memset(3), open(2), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3), strlen(3), unlink(2), and write(2).

       In addition, the _l_o_g___f_l_u_s_h function may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The  _l_o_g___g_e_t function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: atoi(3), close(2), fcntl(2), fflush(3),
       lseek(2), malloc(3), memcpy(3), memset(3), open(2),
       opendir(3), read(2), readdir(3), realloc(3), sig-
       fillset(3), sigprocmask(2), stat(2), strchr(3), strcpy(3),
       strdup(3), strerror(3), strlen(3), strncmp(3), and
       unlink(2).

       In addition, the _l_o_g___g_e_t  function  may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_FIRST flag was specified and no log files were
            found.

       The _l_o_g___f_i_l_e function may fail and return _e_r_r_n_o for any of
       the  errors  specified  for  the  following DB and library
       functions: close(2), fcntl(2), fflush(3), malloc(3), mem-
       cpy(3), memset(3), open(2), sigfillset(3), sigprocmask(2),
       stat(2), strcpy(3), strdup(3), strerror(3), strlen(3), and
       unlink(2).

       In  addition,  the  _l_o_g___f_i_l_e  function may fail and return
       _e_r_r_n_o for the following conditions:

       [ENOMEM]
            The supplied buffer was too small  to  hold  the  log
            file name.

       The  _l_o_g___p_u_t function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: close(2), fcntl(2), fflush(3), fsync(2),
       lseek(2), malloc(3), memcpy(3), memset(3), open(2), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3), strlen(3), time(3), unlink(2), and  write(2).

       In  addition,  the  _l_o_g___p_u_t  function  may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The record to be logged is larger  than  the  maximum
            log record.

       The  _l_o_g___u_n_l_i_n_k function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: close(2), fcntl(2), fflush(3), malloc(3), mem-
       cpy(3), memset(3), mmap(2), munmap(2), open(2), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3), strlen(3), and unlink(2).

       In addition, the _l_o_g___u_n_l_i_n_k function may fail  and  return
       _e_r_r_n_o for the following conditions:

       [EBUSY]
            The  shared  memory  region  was in use and the force
            flag was not set.

       The _l_o_g___a_r_c_h_i_v_e function may fail and return _e_r_r_n_o for any
       of  the  errors specified for the following DB and library
       functions: close(2), fcntl(2), fflush(3), getcwd(3),
       log_compare(3), log_get(3), malloc(3), memcpy(3), mem-
       set(3), open(2), qsort(3), realloc(3), sigfillset(3), sig-
       procmask(2), stat(2), strchr(3), strcmp(3), strcpy(3),
       strdup(3), strerror(3), strlen(3), and unlink(2).

       In addition, the _l_o_g___a_r_c_h_i_v_e function may fail and  return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The log was corrupted.

       The  _l_o_g___r_e_g_i_s_t_e_r  function  may fail and return _e_r_r_n_o for
       any of the errors  specified  for  the  following  DB  and
       library functions: close(2), fcntl(2), fflush(3),
       fsync(2), lseek(2), malloc(3), memcmp(3), memcpy(3), mem-
       set(3), open(2), realloc(3), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), time(3), unlink(2), and write(2).

       In addition, the _l_o_g___r_e_g_i_s_t_e_r function may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _l_o_g___u_n_r_e_g_i_s_t_e_r function may fail and return _e_r_r_n_o  for
       any  of  the  errors  specified  for  the following DB and
       library functions: close(2), fcntl(2), fflush(3),
       fsync(2), lseek(2), malloc(3), memcpy(3), memset(3),
       open(2), sigfillset(3), sigprocmask(2), stat(2), str-
       cpy(3), strdup(3), strerror(3), strlen(3), time(3),
       unlink(2), and write(2).

       In addition, the  _l_o_g___u_n_r_e_g_i_s_t_e_r  function  may  fail  and
       return _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _l_o_g___s_t_a_t function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: fcntl(2), and malloc(3).

BBUUGGSS
       The  log  files  are not machine architecture independent.
       Specifically, log file metadata is not stored in  a  fixed
       byte order.

SSEEEE AALLSSOO
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___i_n_t_e_r_n_a_l(3),
       _d_b___l_o_c_k(3), _d_b___l_o_g(3), _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_h_r_e_a_d(3),
       _d_b___t_x_n(3)
