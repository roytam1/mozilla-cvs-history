

NNAAMMEE
       db_open - database access methods

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb..hh>>

       iinntt
       ddbb__ooppeenn((ccoonnsstt cchhaarr **ffiillee,, DDBBTTYYPPEE ttyyppee,, uu__iinntt3322__tt ffllaaggss,,
            iinntt mmooddee,, DDBB__EENNVV **ddbbeennvv,, DDBB__IINNFFOO **ddbbiinnffoo,, DDBB ****ddbbpppp));;

       iinntt
       DDBB-->>cclloossee((DDBB **ddbb,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       DDBB-->>ccuurrssoorr((DDBB **ddbb,, DDBB__TTXXNN **ttxxnniidd,, DDBBCC ****ccuurrssoorrpp));;

       iinntt
       DDBB-->>ddeell((DDBB **ddbb,, DDBB__TTXXNN **ttxxnniidd,, DDBBTT **kkeeyy,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       DDBB-->>ffdd((DDBB **ddbb,, iinntt **ffddpp));;

       iinntt
       DDBB-->>ggeett((DDBB **ddbb,, DDBB__TTXXNN **ttxxnniidd,, DDBBTT **kkeeyy,, DDBBTT **ddaattaa,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       DDBB-->>ppuutt((DDBB **ddbb,, DDBB__TTXXNN **ttxxnniidd,, DDBBTT **kkeeyy,, DDBBTT **ddaattaa,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       DDBB-->>ssyynncc((DDBB **ddbb,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       DDBB-->>ssttaatt((DDBB **ddbb,, vvooiidd **sspp,, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt)),, uu__iinntt3322__tt ffllaaggss));;

DDEESSCCRRIIPPTTIIOONN
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see _d_b___i_n_t_r_o(3).

       This manual page describes the overall structure of the DB
       library access methods.

       The currently supported file formats are btree, hashed and
       recno.   The btree format is a representation of a sorted,
       balanced tree structure.  The hashed format is an extensi-
       ble,  dynamic  hashing  scheme.  The recno format supports
       fixed or variable  length  records  (optionally  retrieved
       from a flat text file).

       Storage  and retrieval for the DB access methods are based
       on key/data pairs, or DBT structures as they are typedef'd
       in  the  <db.h>  include file.  See _d_b___d_b_t(3) for specific
       information on the structure and capabilities of a DBT.

       The _d_b___o_p_e_n function opens  the  database  represented  by
       _f_i_l_e  for  both reading and writing.  Files never intended
       to be shared or preserved on disk may be created  by  set-
       ting the file parameter to NULL.

       The  _d_b___o_p_e_n  function  copies a pointer to a DB structure
       (as typedef'd in the <db.h> include file), into the memory
       location  referenced  by  _d_b_p_p.  This structure includes a
       set of functions to perform various database  actions,  as
       described  below.   The _d_b___o_p_e_n function returns the value
       of _e_r_r_n_o on failure and 0 on success.

       Note, while most of the access methods  use  _f_i_l_e  as  the
       name  of  an  underlying file on disk, this is not guaran-
       teed.  Also, calling _d_b___o_p_e_n  is  a  reasonably  expensive
       operation.  (This is based on a model where the DBMS keeps
       a set of files open for a long time  rather  than  opening
       and closing them on each query.)

       The  _t_y_p_e  argument  is  of type DBTYPE (as defined in the
       <db.h> include file) and must be set to one  of  DB_BTREE,
       DB_HASH,  DB_RECNO  or DB_UNKNOWN.  If _t_y_p_e is DB_UNKNOWN,
       the database must already  exist  and  _d_b___o_p_e_n  will  then
       determine  if it is of type DB_BTREE, DB_HASH or DB_RECNO.

       The _f_l_a_g_s and _m_o_d_e arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.

       DB_NOMMAP
            Do  not  map  this  file (see _d_b___m_p_o_o_l(3) for further
            information).

       DB_RDONLY
            Open the database for reading only.  Any  attempt  to
            write the database using the access methods will fail
            regardless of the actual permissions of any  underly-
            ing files.


       DB_THREAD
            Cause  the DB handle returned by the _d_b___o_p_e_n function
            to be useable by multiple  threads  within  a  single
            address space, i.e., to be ``free-threaded''.
       DB_TRUNCATE
            ``Truncate''  the database if it exists, i.e., behave
            as if the database were just created, discarding  any
            previous contents.

       All  files  created by the access methods are created with
       mode _m_o_d_e (as described in _c_h_m_o_d(2)) and modified  by  the
       process'   umask  value  at  the  time  of  creation  (see
       _u_m_a_s_k(2)).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

DDBB__EENNVV
       The access methods make calls to the other  subsystems  in
       the  DB  library  based  on the _d_b_e_n_v argument to _d_b___o_p_e_n,
       which is a pointer to a structure of  type  DB_ENV  (type-
       def'd in <db.h>).  Applications will normally use the same
       DB_ENV structure (initialized  by  _d_b___a_p_p_i_n_i_t(3)),  as  an
       argument to all of the subsystems in the DB package.

       References  to  the DB_ENV structure are maintained by DB,
       so it may not be discarded until the last close  function,
       corresponding  to  an  open  function  for which it was an
       argument, has returned.  In order to ensure  compatibility
       with  future  releases  of  DB,  all  fields of the DB_ENV
       structure that are not explicitly set should  be  initial-
       ized to 0 before the first time the structure is used.  Do
       this by declaring the structure external or static, or  by
       calling the C library routine _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       The  fields  of  the  DB_ENV structure used by _d_b___o_p_e_n are
       described below.  If _d_b_e_n_v is NULL or any  of  its  fields
       are set to 0, defaults appropriate for the system are used
       where possible.

       The following fields in the DB_ENV structure may  be  ini-
       tialized before calling _d_b___o_p_e_n:

       DB_LOG *lg_info;
            If  modifications  to the file being opened should be
            logged, the _l_g___i_n_f_o field  contains  a  return  value
            from  the  function _l_o_g___o_p_e_n.  If _l_g___i_n_f_o is NULL, no
            logging is done by the DB access methods.

       DB_LOCKTAB *lk_info;
            If locking is required for the file being opened  (as
            is  the  case  when multiple processes or threads are
            accessing the same file), the _l_k___i_n_f_o field  contains
            a  return  value  from  the  function  _l_o_c_k___o_p_e_n.  If
            _l_k___i_n_f_o is NULL, no locking is done by the DB  access
            methods.

            If  both locking and transactions are being performed
            (i.e., both _l_k___i_n_f_o and _t_x___i_n_f_o  are  non-NULL),  the
            transaction  ID  will  be  used as the locker ID.  If
            only locking is being performed, _d_b___o_p_e_n will acquire
            a  locker ID from _l_o_c_k___i_d(3), and will use it for all
            locks required for this instance of _d_b___o_p_e_n.

       DB_MPOOL *mp_info;
            If the cache for the  file  being  opened  should  be
            maintained in a shared buffer pool, the _m_p___i_n_f_o field
            contains a return value from the function  _m_e_m_p___o_p_e_n.
            If  _m_p___i_n_f_o  is NULL, a memory pool may still be cre-
            ated by DB, but it will be private to the application
            and managed by DB.

       DB_TXNMGR *tx_info;
            If  the accesses to the file being opened should take
            place in the context of transactions (providing atom-
            icity and error recovery), the _t_x___i_n_f_o field contains
            a  return  value  from  the  function  _t_x_n___o_p_e_n  (see
            _d_b___t_x_n(3)).    If  transactions  are  specified,  the
            application is responsible for making suitable  calls
            to  _t_x_n___b_e_g_i_n, _t_x_n___a_b_o_r_t, and _t_x_n___c_o_m_m_i_t.  If _t_x___i_n_f_o
            is NULL, no transaction support is  done  by  the  DB
            access methods.

            When  the access methods are used in conjunction with
            transactions, the application must abort the transac-
            tion (using _t_x_n___a_b_o_r_t) if any of the transaction pro-
            tected access method calls  (i.e.,  any  calls  other
            than  open,  close  and  sync) returns a system error
            (e.g., deadlock, which returns EAGAIN).  As described
            by  _d_b___i_n_t_r_o(3),  a system error is any value greater
            than 0.

DDBB__IINNFFOO
       The access methods are configured using the  DB_INFO  data
       structure  argument  to _d_b___o_p_e_n.  The DB_INFO structure is
       typedef'd in <db.h> and has a large number of fields, most
       specific  to  a  single  access method, although a few are
       shared.  The fields that are common to all access  methods
       are  listed  here;  those specific to an individual access
       method are described below.  No reference to  the  DB_INFO
       structure  is  maintained by DB, so it is possible to dis-
       card it as soon as the _d_b___o_p_e_n call returns.

       In order to ensure compatibility with future  releases  of
       DB, all fields of the DB_INFO structure should be initial-
       ized to 0 before  the  structure  is  used.   Do  this  by
       declaring  the structure external or static, or by calling
       the C library function _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       If possible, defaults appropriate for the system are  used
       for  the DB_INFO fields if _d_b_i_n_f_o is NULL or any fields of
       the DB_INFO structure are set to 0.  The following DB_INFO
       fields may be initialized before calling _d_b___o_p_e_n:
       size_t db_cachesize;
            A suggested maximum size of the memory pool cache, in
            bytes.  If _d_b___c_a_c_h_e_s_i_z_e is 0, an appropriate  default
            is  used.  It is an error to specify both the _m_p___i_n_f_o
            field and a non-zero _d_b___c_a_c_h_e_s_i_z_e.

            NNoottee,, tthhee mmiinniimmuumm nnuummbbeerr ooff ppaaggeess iinn tthhee ccaacchhee sshhoouulldd
            bbee  nnoo lleessss tthhaann 1100,, aanndd tthhee aacccceessss mmeetthhooddss wwiillll ffaaiill
            iiff aann iinnssuuffffiicciieennttllyy llaarrggee ccaacchhee  iiss  ssppeecciiffiieedd..   In
            addition, for applications that exhibit strong local-
            ity in their data  access  patterns,  increasing  the
            size  of the cache can significantly improve applica-
            tion performance.

       int db_lorder;
            The byte order for integers in  the  stored  database
            metadata.   The  number should represent the order as
            an integer, for example, big endian order is the num-
            ber  4,321,  and  little  endian  order is the number
            1,234.  If _d_b___l_o_r_d_e_r is 0,  the  host  order  of  the
            machine where the DB library was compiled is used.

            The   value  of  _d_b___l_o_r_d_e_r  is  ignored  except  when
            databases are being created.  If a  database  already
            exists, the byte order it uses is determined when the
            file is read.

            TThhee aacccceessss mmeetthhooddss pprroovviiddee nnoo  gguuaarraanntteeeess  aabboouutt  tthhee
            bbyyttee  oorrddeerriinngg  ooff tthhee aapppplliiccaattiioonn ddaattaa ssttoorreedd iinn tthhee
            ddaattaabbaassee,, aanndd aapppplliiccaattiioonnss aarree rreessppoonnssiibbllee ffoorr  mmaaiinn--
            ttaaiinniinngg aannyy nneecceessssaarryy oorrddeerriinngg..

       size_t db_pagesize;
            The  size  of  the  pages  used  to hold items in the
            database, in bytes.  The minimum  page  size  is  512
            bytes  and  the  maximum  page size is 64K bytes.  If
            _d_b___p_a_g_e_s_i_z_e is 0, a page size is  selected  based  on
            the   underlying  filesystem  I/O  block  size.   The
            selected size has a lower limit of 512 bytes  and  an
            upper limit of 16K bytes.

       void *(*db_malloc)(size_t);
            The  flag  DB_DBT_MALLOC,  when  specified in the DBT
            structure, will cause the DB library to allocate mem-
            ory  which  then  becomes  the  responsibility of the
            calling application.  See _d_b___d_b_t(3) for more informa-
            tion.

            On  systems  where there may be multiple library ver-
            sions of malloc (notably Windows NT), specifying  the
            DB_DBT_MALLOC  flag  will fail because the DB library
            will allocate memory from a different heap  than  the
            application will use to free it.  To avoid this prob-
            lem, the _d_b___m_a_l_l_o_c field should be set  to  point  to
            the  application's  allocation routine.  If _d_b___m_a_l_l_o_c
            is non-NULL, it will be used to allocate  the  memory
            returned  when  the  DB_DBT_MALLOC  flag is set.  The
            _d_b___m_a_l_l_o_c function must match the calling conventions
            of the _m_a_l_l_o_c(3) library routine.

BBTTRREEEE
       The btree data structure is a sorted, balanced tree struc-
       ture storing associated key/data pairs.  Searches,  inser-
       tions,  and  deletions in the btree will all complete in O
       (lg base N) where base is the average number of  keys  per
       page.   Often,  inserting ordered data into btrees results
       in pages that are half-full.  This implementation has been
       modified  to  make  ordered (or inverse ordered) insertion
       the best case, resulting in nearly perfect page space uti-
       lization.

       Space  freed  by deleting key/data pairs from the database
       is never reclaimed from the  filesystem,  although  it  is
       reused  where possible.  This means that the btree storage
       structure is grow-only.  If  sufficiently  many  keys  are
       deleted from a tree that shrinking the underlying database
       file is desirable, this can be accomplished by creating  a
       new tree from a scan of the existing one.

       The  following additional fields and flags may be initial-
       ized in the DB_INFO structure before calling _d_b___o_p_e_n, when
       using the btree access method:

       int (*bt_compare)(const DBT *, const DBT *);
            The  _b_t___c_o_m_p_a_r_e  function is the key comparison func-
            tion.  It must return an integer less than, equal to,
            or  greater  than  zero  if the first key argument is
            considered to be respectively less than, equal to, or
            greater  than the second key argument.  The same com-
            parison function must be used on a given  tree  every
            time it is opened.

            The  _d_a_t_a  and  _s_i_z_e  fields  of the DBT are the only
            fields that may be used for the purposes of this com-
            parison.

            If  _b_t___c_o_m_p_a_r_e  is  NULL, the keys are compared lexi-
            cally, with  shorter  keys  collating  before  longer
            keys.

       u_int32_t bt_minkey;
            The minimum number of keys that will be stored on any
            single page.  This value is used to  determine  which
            keys  will be stored on overflow pages, i.e. if a key
            or data item is larger than the pagesize  divided  by
            the  _b_t___m_i_n_k_e_y  value,  it will be stored on overflow
            pages instead of in the page itself.   The  _b_t___m_i_n_k_e_y
            value  specified  must be at least 2; if _b_t___m_i_n_k_e_y is
            0, a value of 2 is used.

       size_t (*bt_prefix)(const DBT *, const DBT *);
            The _b_t___p_r_e_f_i_x function is the prefix comparison func-
            tion.   If  specified,  this function must return the
            number of bytes of the second key argument  that  are
            necessary  to  determine  that it is greater than the
            first key argument.  If the keys are equal,  the  key
            length should be returned.

            The  _d_a_t_a  and  _s_i_z_e  fields  of the DBT are the only
            fields that may be used for the purposes of this com-
            parison.

            This is used to compress the keys stored on the btree
            internal pages.   The  usefulness  of  this  is  data
            dependent, but in some data sets can produce signifi-
            cantly reduced  tree  sizes  and  search  times.   If
            _b_t___p_r_e_f_i_x  is  NULL,  and  no  comparison function is
            specified, a default lexical comparison  function  is
            used.  If _b_t___p_r_e_f_i_x is NULL and a comparison function
            is specified, no prefix comparison is done.

       u_int32_t flags;
            The following additional flags may  be  specified  by
            oorr'ing together one or more of the following values:

            DB_DUP
                 Permit  duplicate  keys in the tree, i.e. inser-
                 tion when the key of  the  key/data  pair  being
                 inserted already exists in the tree will be suc-
                 cessful.  The ordering of duplicates in the tree
                 is  determined by the order of insertion, unless
                 the ordering is otherwise specified by use of  a
                 cursor  (see _d_b___c_u_r_s_o_r(3) for more information.)
                 It is  an  error  to  specify  both  DB_DUP  and
                 DB_RECNUM.

            DB_RECNUM
                 Support  retrieval from btrees using record num-
                 bers.    For   more   information,    see    the
                 DB_SET_RECNO   flag   to  the  _D_B_-_>_g_e_t  function
                 (below),  and  the  cursor  _c___g_e_t  function  (in
                 _d_b___c_u_r_s_o_r(3)).

                 Logical  record numbers in btrees are mutable in
                 the face of record insertion or  deletion.   See
                 the  DB_RENUMBER flag in the RECNO section below
                 for further discussion.

                 Maintaining record counts within a btree  intro-
                 duces  a serious point of contention, namely the
                 page  locations  where  the  record  counts  are
                 stored.   In  addition,  the entire tree must be
                 locked during  both  insertions  and  deletions,
                 effectively  single-threading the tree for those
                 operations.  Specifying DB_RECNUM can result  in
                 serious  performance degradation for some appli-
                 cations and data sets.

                 It is  an  error  to  specify  both  DB_DUP  and
                 DB_RECNUM.

HHAASSHH
       The  hash data structure is an extensible, dynamic hashing
       scheme.  Backward compatible interfaces to  the  functions
       described  in _d_b_m(3), _n_d_b_m(3) and _h_s_e_a_r_c_h(3) are provided,
       however these interfaces are not compatible with  previous
       file formats.

       The  following additional fields and flags may be initial-
       ized in the DB_INFO structure before calling _d_b___o_p_e_n, when
       using the hash access method:

       u_int32_t h_ffactor;
            The  desired density within the hash table.  It is an
            approximation of the number of keys allowed to  accu-
            mulate  in  any one bucket, determining when the hash
            table grows or shrinks.   The  default  value  is  0,
            indicating  that  the  fill  factor  will be selected
            dynamically as pages are filled.

       u_int32_t (*h_hash)(const void *, u_int32_t);
            The _h___h_a_s_h field is a user defined hash function;  if
            _h___h_a_s_h  is  NULL,  a  default  hash function is used.
            Since no hash function performs equally well  on  all
            possible  data,  the  user may find that the built-in
            hash function performs poorly with a particular  data
            set.   User  specified  hash  functions  must  take a
            pointer to a byte string and a  length  as  arguments
            and return a u_int32_t value.

            If  a  hash  function  is  specified,  _h_a_s_h___o_p_e_n will
            attempt to determine if the hash  function  specified
            is  the  same  as the one with which the database was
            created, and will fail if it detects that it is  not.

       u_int32_t h_nelem;
            An  estimate of the final size of the hash table.  If
            not set or set  too  low,  hash  tables  will  expand
            gracefully  as  keys  are  entered, although a slight
            performance degradation may be noticed.  The  default
            value is 1.

       u_int32_t flags;
            The  following  additional  flags may be specified by
            oorr'ing together one or more of the following values:

            DB_DUP
                 Permit duplicate keys in the tree,  i.e.  inser-
                 tion  when  the  key  of the key/data pair being
                 inserted already exists in the tree will be suc-
                 cessful.  The ordering of duplicates in the tree
                 is determined by the order of insertion,  unless
                 the  ordering is otherwise specified by use of a
                 cursor (see _d_b___c_u_r_s_o_r(3) for more  information.)

RREECCNNOO
       The  recno  access  method  provides support for fixed and
       variable length records, optionally backed by a flat  text
       (byte  stream)  file.   Both  fixed  and  variable  length
       records are accessed by their logical record number.

       It is valid to create a record whose record number is more
       than  one  greater  than  the last record currently in the
       database.  For example, the creation of record  number  8,
       when  records  6  and 7 do not yet exist, is not an error.
       However, any  attempt  to  retrieve  such  records  (e.g.,
       records 6 and 7) will return DB_KEYEMPTY.

       Deleting  a  record will not, by default, renumber records
       following the deleted record (see  DB_RENUMBER  below  for
       more   information).   Any  attempt  to  retrieve  deleted
       records will return DB_KEYEMPTY.

       The following additional fields and flags may be  initial-
       ized in the DB_INFO structure before calling _d_b___o_p_e_n, when
       using the recno access method:

       int re_delim;
            For variable length records, if the _r_e___s_o_u_r_c_e file is
            specified  and  the  DB_DELIMITER  flag  is  set, the
            delimiting byte used to mark the end of a  record  in
            the  source file.  If the _r_e___s_o_u_r_c_e file is specified
            and the DB_DELIMITER flag is not set, <newline> char-
            acters (i.e. ``\n'', 0x0a) are interpreted as end-of-
            record markers.

       u_int32_t re_len;
            The length of a fixed-length record.

       int re_pad;
            For fixed length records, if the DB_PAD flag is  set,
            the  pad  character for short records.  If the DB_PAD
            flag is not set, <space> characters (i.e., 0x20)  are
            used for padding.

       char *re_source;
            The purpose of the _r_e___s_o_u_r_c_e field is to provide fast
            access and modification to databases  that  are  nor-
            mally stored as flat text files.


            If  the  _r_e___s_o_u_r_c_e field is non-NULL, it specifies an
            underlying flat text database file that  is  read  to
            initialize  a  transient record number index.  In the
            case of variable length records, the records are sep-
            arated  by  the  byte  value  _r_e___d_e_l_i_m.  For example,
            standard UNIX byte stream files can be interpreted as
            a  sequence  of  variable length records separated by
            <newline> characters.

            In addition, when cached data would normally be writ-
            ten  back  to the underlying database file (e.g., the
            _c_l_o_s_e or _s_y_n_c functions are  called),  the  in-memory
            copy  of  the  database  will  be written back to the
            _r_e___s_o_u_r_c_e file.

            By default, the backing source file is  read  lazily,
            i.e.,  records  are not read from the file until they
            are requested by the application.  IIff  mmuullttiippllee  pprroo--
            cceesssseess  ((nnoott  tthhrreeaaddss)) aarree aacccceessssiinngg aa rreeccnnoo ddaattaabbaassee
            ccoonnccuurrrreennttllyy  aanndd  eeiitthheerr   iinnsseerrttiinngg   oorr   ddeelleettiinngg
            rreeccoorrddss,,  tthhee bbaacckkiinngg ssoouurrccee ffiillee mmuusstt bbee rreeaadd iinn iittss
            eennttiirreettyy bbeeffoorree mmoorree tthhaann aa ssiinnggllee  pprroocceessss  aacccceesssseess
            tthhee  ddaattaabbaassee,,  aanndd  oonnllyy tthhaatt pprroocceessss sshhoouulldd ssppeecciiffyy
            tthhee bbaacckkiinngg ssoouurrccee ffiillee aass ppaarrtt ooff tthhee ddbb__ooppeenn  ccaallll..
            See  the DB_SNAPSHOT flag below for more information.

            RReeaaddiinngg aanndd wwrriittiinngg tthhee bbaacckkiinngg ssoouurrccee ffiillee ssppeecciiffiieedd
            bbyy  rree__ssoouurrccee  ccaannnnoott  bbee  ttrraannssaaccttiioonnaallllyy  pprrootteecctteedd
            bbeeccaauussee iitt iinnvvoollvveess ffiilleessyysstteemm  ooppeerraattiioonnss  tthhaatt  aarree
            nnoott ppaarrtt ooff tthhee DDBB ttrraannssaaccttiioonn mmeetthhooddoollooggyy..  For this
            reason, if a temporary database is used to  hold  the
            records, i.e., a NULL was specified as the _f_i_l_e argu-
            ment to _d_b___o_p_e_n, it is possible to lose the  contents
            of the _r_e___s_o_u_r_c_e file, e.g., if the system crashes at
            the right instant.  If a file is  used  to  hold  the
            database, i.e., a file name was specified as the _f_i_l_e
            argument to _d_b___o_p_e_n, normal database recovery on that
            file   can  be  used  to  prevent  information  loss,
            although it is still possible that  the  contents  of
            _r_e___s_o_u_r_c_e will be lost if the system crashes.

            The  _r_e___s_o_u_r_c_e  file  must  already exist (but may be
            zero-length) when _d_b___o_p_e_n is called.

            For all of the above reasons, the _r_e___s_o_u_r_c_e field  is
            generally  used  to  specify databases that are read-
            only for DB applications, and that are either  gener-
            ated  on the fly by software tools, or modified using
            a different mechanism, e.g., a text editor.

       u_int32_t flags;
            The following additional flags may  be  specified  by
            oorr'ing together one or more of the following values:

            DB_DELIMITER
                 The _r_e___d_e_l_i_m field is set.

            DB_FIXEDLEN
                 The  records  are  fixed-length, not byte delim-
                 ited.  The structure  element  _r_e___l_e_n  specifies
                 the length of the record, and the structure ele-
                 ment _r_e___p_a_d is used as the pad character.

                 Any records added to the database that are  less
                 than _r_e___l_e_n bytes long are automatically padded.
                 Any attempt to insert records into the  database
                 that  are  greater  than  _r_e___l_e_n bytes long will
                 cause the call to fail immediately and return an
                 error.

            DB_PAD
                 The _r_e___p_a_d field is set.

            DB_RENUMBER
                 Specifying the DB_RENUMBER flag causes the logi-
                 cal record numbers to be mutable, and change  as
                 records  are  added  to  and  deleted  from  the
                 database.  For example, the deletion  of  record
                 number  4  causes records numbered 5 and greater
                 to be renumbered downward by 1.  If a cursor was
                 positioned  to  record number 4 before the dele-
                 tion, it will reference the new record number 4,
                 if  any  such record exists, after the deletion.
                 If a cursor was positioned after record number 4
                 before the deletion, it will be shifted downward
                 1 logical record, continuing  to  reference  the
                 same record as it did before.

                 Using  the _c___p_u_t or _p_u_t interfaces to create new
                 records will  cause  the  creation  of  multiple
                 records  if  the  record number is more than one
                 greater than the largest record currently in the
                 database.  For example, creating record 28, when
                 record 25 was previously the last record in  the
                 database,  will create records 26 and 27 as well
                 as 28.  Attempts to retrieve records  that  were
                 created  in  this manner will result in an error
                 return of DB_KEYEMPTY.

                 If a created record is not at  the  end  of  the
                 database,  all  records following the new record
                 will be automatically renumbered  upward  by  1.
                 For  example,  the creation of a new record num-
                 bered 8 causes records numbered 8 and greater to
                 be  renumbered  upward  by  1.   If a cursor was
                 positioned to record number 8 or greater  before
                 the insertion, it will be shifted upward 1 logi-
                 cal record, continuing  to  reference  the  same
                 record as it did before.

                 For  these reasons, concurrent access to a recno
                 database with the DB_RENUMBER flag specified may
                 be  largely  meaningless,  although  it  is sup-
                 ported.

            DB_SNAPSHOT
                 This flag specifies that any specified _r_e___s_o_u_r_c_e
                 file  be  read  in  its entirety when _d_b___o_p_e_n is
                 called.  If this  flag  is  not  specified,  the
                 _r_e___s_o_u_r_c_e file may be read lazily.


DDBB OOPPEERRAATTIIOONNSS
       The  DB structure returned by _d_b___o_p_e_n describes a database
       type, and includes a set of functions to  perform  various
       actions,  as  described  below.   Each  of these functions
       takes a pointer to a DB structure, and  may  take  one  or
       more  DBT *'s and a flag value as well.  The fields of the
       DB structure are as follows:

       DBTYPE type;
            The type of the underlying access  method  (and  file
            format).    Set   to  one  of  DB_BTREE,  DB_HASH  or
            DB_RECNO.  This field may be used  to  determine  the
            type of the database after a return from _d_b___o_p_e_n with
            the _t_y_p_e argument set to DB_UNKNOWN.

       int (*close)(DB *db, u_int32_t flags);
            A pointer to a function to flush any cached  informa-
            tion  to  disk,  close  any open cursors (see _d_b___c_u_r_-
            _s_o_r(3)), free any allocated resources, and close  any
            underlying files.  Since key/data pairs are cached in
            memory, failing to sync the file with  the  _c_l_o_s_e  or
            _s_y_n_c  function  may  result  in  inconsistent or lost
            information.

            The _f_l_a_g_s parameter must be set to 0 or the following
            value:

            DB_NOSYNC
                 Do not flush cached information to disk.

            The  DB_NOSYNC flag is a dangerous option.  It should
            only be set if the application is doing logging (with
            transactions)  so  that  the  database is recoverable
            after a  system  or  application  crash,  or  if  the
            database  is  always generated from scratch after any
            system or application crash.

            IItt iiss iimmppoorrttaanntt ttoo uunnddeerrssttaanndd  tthhaatt  fflluusshhiinngg  ccaacchheedd
            iinnffoorrmmaattiioonn  ttoo  ddiisskk  oonnllyy  mmiinniimmiizzeess  tthhee wwiinnddooww ooff
            ooppppoorrttuunniittyy ffoorr ccoorrrruupptteedd ddaattaa..  While  unlikely,  it
            is  possible  for  database corruption to happen if a
            system or application crash occurs while writing data
            to  the database.  To ensure that database corruption
            never occurs, applications must either: use  transac-
            tions  and  logging with automatic recovery, use log-
            ging and application-specific  recovery,  or  edit  a
            copy  of  the  database,  and,  once all applications
            using the database have  successfully  called  _c_l_o_s_e,
            replace  the original database with the updated copy.

            When multiple threads are using the DB handle concur-
            rently,  only  a single thread may call the DB handle
            close function.

            The _c_l_o_s_e function returns  the  value  of  _e_r_r_n_o  on
            failure and 0 on success.

       int (*cursor)(DB *db, DB_TXN *txnid, DBC **cursorp);
            A pointer to a function to create a cursor and copy a
            pointer to it into the memory referenced by  _c_u_r_s_o_r_p.

            A  cursor  is  a structure used to provide sequential
            access through a database.  This  interface  and  its
            associated  functions replaces the functionality pro-
            vided by the _s_e_q function in previous releases of the
            DB library.


            If  the file is being accessed under transaction pro-
            tection, the _t_x_n_i_d  parameter  is  a  transaction  ID
            returned  from _t_x_n___b_e_g_i_n, otherwise, NULL.  If trans-
            action protection is enabled, cursors must be  opened
            and  closed  within the context of a transaction, and
            the _t_x_n_i_d parameter specifies the transaction context
            in  which  the  cursor may be used.  See _d_b___c_u_r_s_o_r(3)
            for more information.

            The _c_u_r_s_o_r function returns the  value  of  _e_r_r_n_o  on
            failure and 0 on success.

       int (*del)(DB *db, DB_TXN *txnid, DBT *key, u_int32_t
            flags);
            A pointer to a function to remove key/data pairs from
            the  database.  The key/data pair associated with the
            specified _k_e_y is discarded from the database.  In the
            presence of duplicate key values, all records associ-
            ated with the designated key will be discarded.

            If the file is being accessed under transaction  pro-
            tection,  the  _t_x_n_i_d  parameter  is  a transaction ID
            returned from _t_x_n___b_e_g_i_n, otherwise, NULL.

            The _f_l_a_g_s parameter is currently unused, and must  be
            set to 0.

            The  _d_e_l function returns the value of _e_r_r_n_o on fail-
            ure, 0 on success, and DB_NOTFOUND if  the  specified
            _k_e_y did not exist in the file.

       int (*fd)(DB *db, int *fdp);
            A pointer to a function that copies a file descriptor
            representative of the underlying  database  into  the
            memory  referenced  by _f_d_p.  A file descriptor refer-
            encing the same file will be  returned  to  all  pro-
            cesses that call _d_b___o_p_e_n with the same _f_i_l_e argument.
            This file descriptor may be safely used as  an  argu-
            ment  to the _f_c_n_t_l(2) and _f_l_o_c_k(2) locking functions.
            The file descriptor  is  not  necessarily  associated
            with  any  of the underlying files used by the access
            method.

            The _f_d function only supports a  coarse-grained  form
            of locking.  Applications should use the lock manager
            where possible.

            The _f_d function returns the value of _e_r_r_n_o on failure
            and 0 on success.

       int (*get)(DB *db, DB_TXN *txnid,
                 DBT *key, DBT *data, u_int32_t flags);
            A  pointer  to  a  function  that is an interface for
            keyed retrieval from the database.  The  address  and
            length  of the data associated with the specified _k_e_y
            are returned in the structure referenced by _d_a_t_a.

            In the presence of duplicate  key  values,  _g_e_t  will
            return  the  first  data item for the designated key.
            Duplicates are sorted by insert  order  except  where
            this  order has been overridden by cursor operations.
            RReettrriieevvaall ooff dduupplliiccaatteess rreeqquuiirreess tthhee  uussee  ooff  ccuurrssoorr
            ooppeerraattiioonnss..  See _d_b___c_u_r_s_o_r(3) for details.

            If  the file is being accessed under transaction pro-
            tection, the _t_x_n_i_d  parameter  is  a  transaction  ID
            returned from _t_x_n___b_e_g_i_n, otherwise, NULL.

            The _f_l_a_g_s parameter must be set to 0 or the following
            value:

            DB_SET_RECNO
                 Retrieve the specified  numbered  key/data  pair
                 from  a database.  Upon return, both the _k_e_y and
                 _d_a_t_a items will have been filled  in,  not  just
                 the  data  item as is done for all other uses of
                 the _g_e_t function.

                 The _d_a_t_a field of the specified _k_e_y  must  be  a
                 pointer  to  a  memory  location  from  which  a
                 _d_b___r_e_c_n_o___t  may  be  read,   as   described   in
                 _d_b___d_b_t(3).  This memory location will be read to
                 determine the record to be retrieved.

                 For DB_SET_RECNO to be specified, the underlying
                 database  must be of type btree and it must have
                 been  created  with  the  DB_RECNUM  flag   (see
                 _d_b___o_p_e_n(3)).

            If the database is a recno database and the requested
            key exists, but was never explicitly created  by  the
            application  or  was  later deleted, the _g_e_t function
            returns DB_KEYEMPTY.  Otherwise, if the requested key
            isn't  in  the  database,  the  _g_e_t  function returns
            DB_NOTFOUND.  Otherwise, the _g_e_t function returns the
            value of _e_r_r_n_o on failure and 0 on success.

       int (*put)(DB *db, DB_TXN *txnid,
                 DBT *key, DBT *data, u_int32_t flags);
            A  pointer  to  a function to store key/data pairs in
            the database.  If the database  supports  duplicates,
            the  _p_u_t  function adds the new data value at the end
            of the duplicate set.

            If the file is being accessed under transaction  pro-
            tection,  the  _t_x_n_i_d  parameter  is  a transaction ID
            returned from _t_x_n___b_e_g_i_n, otherwise, NULL.

            The flags value is specified by oorr'ing  together  one
            or more of the following values:

            DB_APPEND
                 Append  the  key/data  pair  to  the  end of the
                 database.  For DB_APPEND to  be  specified,  the
                 underlying  database must be of type recno.  The
                 record  number  allocated  to  the   record   is
                 returned in the specified _k_e_y.

            DB_NOOVERWRITE
                 Enter the new key/data pair only if the key does
                 not already appear in the database.

            The default behavior of the _p_u_t function is to  enter
            the  new  key/data  pair,  replacing  any  previously
            existing key if duplicates are disallowed, or to  add
            a duplicate entry if duplicates are allowed.  Even if
            the designated database allows duplicates, a call  to
            _p_u_t with the DB_NOOVERWRITE flag set will fail if the
            key already exists in the database.

            The _p_u_t function returns the value of _e_r_r_n_o on  fail-
            ure,  0 on success, and DB_KEYEXIST if the DB_NOOVER-
            WRITE _f_l_a_g was set and the key already exists in  the
            file.

       int (*sync)(DB *db, u_int32_t flags);
            A  pointer to a function to flush any cached informa-
            tion to disk.  If the database is in memory only, the
            _s_y_n_c  function has no effect and will always succeed.

            The _f_l_a_g_s parameter is currently unused, and must  be
            set to 0.

            See  the  _c_l_o_s_e function description above for a dis-
            cussion of DB and cached data.

            The _s_y_n_c function returns the value of _e_r_r_n_o on fail-
            ure and 0 on success.

       int (*stat)(DB *db, void *sp,
                 void *(*db_malloc)(size_t), u_int32_t flags);
            A  pointer  to  a  function  to  create a statistical
            structure and copy a pointer to it  into  user-speci-
            fied  memory  locations.  Specifically, if _s_p is non-
            NULL, a pointer to the statistics  for  the  database
            are copied into the memory location it references.

            Statistical  structures are created in allocated mem-
            ory.  If _d_b___m_a_l_l_o_c is non-NULL, it is called to allo-
            cate the memory, otherwise, the library function _m_a_l_-
            _l_o_c(3) is used.  The function  _d_b___m_a_l_l_o_c  must  match
            the calling conventions of the _m_a_l_l_o_c(3) library rou-
            tine.  Regardless,  the  caller  is  responsible  for
            deallocating  the returned memory.  To deallocate the
            returned memory, free each returned  memory  pointer;
            pointers inside the memory do not need to be individ-
            ually freed.

            IInn tthhee pprreesseennccee  ooff  mmuullttiippllee  tthhrreeaaddss  oorr  pprroocceesssseess
            aacccceessssiinngg  aann  aaccttiivvee ddaattaabbaassee,, tthhee rreettuurrnneedd iinnffoorrmmaa--
            ttiioonn mmaayy bbee oouutt--ooff--ddaattee..

            TThhiiss ffuunnccttiioonn mmaayy aacccceessss aallll  ooff  tthhee  ppaaggeess  iinn  tthhee
            ddaattaabbaassee,,  aanndd  tthheerreeffoorree  mmaayy iinnccuurr aa sseevveerree ppeerrffoorr--
            mmaannccee ppeennaallttyy aanndd hhaavvee oobbvviioouuss  nneeggaattiivvee  eeffffeeccttss  oonn
            tthhee uunnddeerrllyyiinngg bbuuffffeerr ppooooll..


            The _f_l_a_g_s parameter must be set to 0 or the following
            value:


            DB_RECORDCOUNT
                 Fill in the _b_t___n_r_e_c_s  field  of  the  statistics
                 structure, but do not collect any other informa-
                 tion.  This flag makes it reasonable for  appli-
                 cations   to  request  a  record  count  from  a
                 database   without   incurring   a   performance
                 penalty.    It   is  only  available  for  recno
                 databases, or btree databases where the underly-
                 ing  database  was  created  with  the DB_RECNUM
                 flag.

            The _s_t_a_t function returns the value of _e_r_r_n_o on fail-
            ure and 0 on success.

            In the case of a btree or recno database, the statis-
            tics are stored in a structure of type  DB_BTREE_STAT
            (typedef'd  in <db.h>).  The following fields will be
            filled in:

            u_int32_t bt_magic;
                 Magic number that identifies the file as a btree
                 file.
            u_int32_t bt_version;
                 The version of the btree file type.
            u_int32_t bt_flags;
                 Permanent   database  flags,  including  DB_DUP,
                 DB_FIXEDLEN, DB_RECNUM and DB_RENUMBER.
            u_int32_t bt_minkey;
                 The _b_t___m_i_n_k_e_y value specified to _d_b___o_p_e_n(3),  if
                 any.
            u_int32_t bt_re_len;
                 The  _r_e___l_e_n  value  specified  to _d_b___o_p_e_n(3), if
                 any.
            u_int32_t bt_re_pad;
                 The _r_e___p_a_d value  specified  to  _d_b___o_p_e_n(3),  if
                 any.
            u_int32_t bt_pagesize;
                 Underlying tree page size.
            u_int32_t bt_levels;
                 Number of levels in the tree.
            u_int32_t bt_nrecs;
                 Number  of  data  items in the tree (since there
                 may be multiple data items per key, this  number
                 may not be the same as the number of keys).
            u_int32_t bt_int_pg;
                 Number of tree internal pages.
            u_int32_t bt_leaf_pg;
                 Number of tree leaf pages.
            u_int32_t bt_dup_pg;
                 Number of tree duplicate pages.
            u_int32_t bt_over_pg;
                 Number of tree overflow pages.
            u_int32_t bt_free;
                 Number of pages on the free list.
            u_int32_t bt_freed;
                 Number of pages made available for reuse because
                 they were emptied.
            u_int32_t bt_int_pgfree;
                 Number of bytes free in tree internal pages.
            u_int32_t bt_leaf_pgfree;
                 Number of bytes free in tree leaf pages.
            u_int32_t bt_dup_pgfree;
                 Number of bytes free in tree duplicate pages.
            u_int32_t bt_over_pgfree;
                 Number of bytes free in tree overflow pages.
            u_int32_t bt_pfxsaved;
                 Number of bytes saved by prefix compression.
            u_int32_t bt_split;
                 Total number of tree page splits (includes  fast
                 and root splits).
            u_int32_t bt_rootsplit;
                 Number of root page splits.
            u_int32_t bt_fastsplit;
                 Number  of  fast  splits.   When sorted keys are
                 added to the database, the DB btree  implementa-
                 tion  will  split  left or right to increase the
                 page-fill factor.  This number is a  measure  of
                 how  often it was possible to make such a split.
            u_int32_t bt_added;
                 Number of keys added.
            u_int32_t bt_deleted;
                 Number of keys deleted.
            u_int32_t bt_get;
                 Number of keys  retrieved.   (Note,  this  value
                 will  not  reflect  any  keys retrieved when the
                 database was open for read-only access, as there
                 is  no  permanent location to store the informa-
                 tion in this case.)
            u_int32_t bt_cache_hit;
                 Number of hits in tree fast-insert  code.   When
                 sorted  keys  are  added to the database, the DB
                 btree implementation will check  the  last  page
                 where  an  insert  occurred  before doing a full
                 lookup.  This number is a measure of  how  often
                 the lookup was successful.
            u_int32_t bt_cache_miss;
                 Number  of misses in tree fast-insert code.  See
                 the description of bt_cache_hit; this number  is
                 a measure of how often the lookup failed.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The  following  environment variables affect the execution
       of _d_b___o_p_e_n:

       DB_HOME
            If the _d_b_e_n_v  argument  to  _d_b___o_p_e_n  was  initialized
            using  _d_b___a_p_p_i_n_i_t,  the  environment variable DB_HOME
            may be used as the path of the database home for  the
            interpretation  of  the  _d_i_r  argument to _d_b___o_p_e_n, as
            described in _d_b___a_p_p_i_n_i_t(3).  Specifically, _d_b___o_p_e_n is
            affected   by   the  configuration  string  value  of
            DB_DATA_DIR.

EEXXAAMMPPLLEESS
       Applications that create short-lived  databases  that  are
       discarded  or  recreated  when  the  system  fails and are
       unconcerned with concurrent access and loss of data due to
       catastrophic  failure,  may  wish to use the _d_b___o_p_e_n func-
       tionality without other parts of  the  DB  library.   Such
       applications  will  only  be  concerned with the DB access
       methods.  The DB access methods will use the  memory  pool
       subsystem,  but the application is unlikely to be aware of
       this.   See  the  files  _e_x_a_m_p_l_e_/_e_x___a_c_c_e_s_s_._c   and   _e_x_a_m_-
       _p_l_e_/_e_x___b_t_r_e_c_._c  in  the  DB source distribution for C lan-
       guage code examples of how such applications might use the
       DB library.

EERRRROORRSS
       The  _d_b___o_p_e_n function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: DB->sync(3), calloc(3), close(2), fcntl(2),
       fflush(3), lock_get(3), lock_id(3), lock_put(3),
       lock_vec(3), log_put(3), log_register(3), log_unregis-
       ter(3), malloc(3), memcpy(3), memmove(3), memp_close(3),
       memp_fclose(3), memp_fget(3), memp_fopen(3), memp_fput(3),
       memp_fset(3), memp_fsync(3), memp_open(3), memp_regis-
       ter(3), memset(3), mmap(2), munmap(2), open(2), read(2),
       realloc(3), sigfillset(3), sigprocmask(2), stat(2), str-
       cpy(3), strdup(3), strerror(3), strlen(3), time(3), and
       unlink(2).

       In addition, the _d_b___o_p_e_n  function  may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An  invalid  flag  value  or  parameter was specified
            (e.g., unknown database type, page size,  hash  func-
            tion,  recno pad byte, byte order) or a flag value or
            parameter that is incompatible with the current  _f_i_l_e
            specification.

            The  DB_THREAD  flag  was specified and spinlocks are
            not implemented for this architecture.

            There is a mismatch between  the  version  number  of
            _f_i_l_e and the software.

            A  _r_e___s_o_u_r_c_e  file  was  specified  with  either  the
            DB_THREAD flag or a non-NULL  _t_x___i_n_f_o  field  in  the
            DB_ENV argument to db_open.

       [ENOENT]
            A non-existent _r_e___s_o_u_r_c_e file was specified.

       [EPERM]
            Database  corruption  was  detected.   All subsequent
            database calls (other  than  _D_B_-_>_c_l_o_s_e)  will  return
            EPERM.

       The  _D_B_-_>_c_l_o_s_e  function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: DB->sync(3), calloc(3), close(2), fflush(3),
       lock_get(3), lock_put(3), lock_vec(3), log_put(3),
       log_unregister(3), malloc(3), memcpy(3), memmove(3),
       memp_close(3), memp_fclose(3), memp_fget(3), memp_fput(3),
       memp_fset(3), memp_fsync(3), memset(3), munmap(2), real-
       loc(3), and strerror(3).

       The _D_B_-_>_c_u_r_s_o_r function may fail and return _e_r_r_n_o for  any
       of  the  errors specified for the following DB and library
       functions: calloc(3).

       In addition, the _D_B_-_>_c_u_r_s_o_r function may fail  and  return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       [EPERM]
            Database  corruption  was  detected.   All subsequent
            database calls (other  than  _D_B_-_>_c_l_o_s_e)  will  return
            EPERM.

       The  _D_B_-_>_d_e_l function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: calloc(3), fcntl(2), fflush(3), lock_get(3),
       lock_id(3), lock_put(3), lock_vec(3), log_put(3), mal-
       loc(3), memcmp(3), memcpy(3), memmove(3), memp_fget(3),
       memp_fput(3), memp_fset(3), memset(3), realloc(3), and
       strerror(3).

       In  addition,  the  _D_B_-_>_d_e_l  function  may fail and return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  _D_B_-_>_c_l_o_s_e) will return
            EPERM.

       In addition, the _D_B_-_>_f_d function may fail and return _e_r_r_n_o
       for the following conditions:

       [ENOENT]
            The  _D_B_-_>_f_d  function  was  called  for  an in-memory
            database, or no underlying file has yet been created.

       [EPERM]
            Database  corruption  was  detected.   All subsequent
            database calls (other  than  _D_B_-_>_c_l_o_s_e)  will  return
            EPERM.

       The  _D_B_-_>_g_e_t function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: DBcursor->c_get(3), calloc(3), fcntl(2),
       fflush(3), lock_get(3), lock_id(3), lock_put(3),
       lock_vec(3), log_put(3), malloc(3), memcmp(3), memcpy(3),
       memmove(3), memp_fget(3), memp_fput(3), memp_fset(3), mem-
       set(3), realloc(3), and strerror(3).

       In  addition,  the  _D_B_-_>_g_e_t  function  may fail and return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_THREAD flag was specified  to  the  _d_b___o_p_e_n(3)
            function    and    neither   the   DB_DBT_MALLOC   or
            DB_DBT_USERMEM flags were set in the DBT.

            A record number of 0 was specified.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  _D_B_-_>_c_l_o_s_e) will return
            EPERM.

       The _D_B_-_>_p_u_t function may fail and return _e_r_r_n_o for any  of
       the  errors  specified  for  the  following DB and library
       functions: calloc(3), fcntl(2), fflush(3), lock_get(3),
       lock_id(3), lock_put(3), lock_vec(3), log_put(3), mal-
       loc(3), memcmp(3), memcpy(3), memmove(3), memp_fget(3),
       memp_fput(3), memp_fset(3), memset(3), realloc(3), and
       strerror(3).

       In addition, the _D_B_-_>_p_u_t  function  may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EACCES]
            An attempt was made to modify a read-only database.

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            A record number of 0 was specified.

            An attempt was made to add a record to a fixed-length
            database that was too large to fit.

            An attempt was made to do a partial put.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  _D_B_-_>_c_l_o_s_e) will return
            EPERM.

       [ENOSPC]
            A btree exceeded the maximum btree depth (255).

       The _D_B_-_>_s_t_a_t function may fail and return _e_r_r_n_o for any of
       the  errors  specified  for  the  following DB and library
       functions: calloc(3), fcntl(2), fflush(3), lock_get(3),
       lock_id(3), lock_put(3), lock_vec(3), malloc(3), mem-
       cpy(3), memp_fget(3), memp_fput(3), and memset(3).

       The _D_B_-_>_s_y_n_c function may fail and return _e_r_r_n_o for any of
       the  errors  specified  for  the  following DB and library
       functions: DB->get(3), DB->sync(3), calloc(3), close(2),
       fcntl(2), fflush(3), lock_get(3), lock_id(3), lock_put(3),
       lock_vec(3), log_put(3), malloc(3), memcpy(3), memmove(3),
       memp_fget(3), memp_fput(3), memp_fset(3), memp_fsync(3),
       memset(3), munmap(2), open(2), realloc(3), strerror(3),
       unlink(2), and write(2).

       In  addition,  the  _D_B_-_>_s_y_n_c  function may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  _D_B_-_>_c_l_o_s_e) will return
            EPERM.

SSEEEE AALLSSOO
       _T_h_e _U_b_i_q_u_i_t_o_u_s _B_-_t_r_e_e, Douglas Comer,  ACM  Comput.  Surv.
       11, 2 (June 1979), 121-138.

       _P_r_e_f_i_x  _B_-_t_r_e_e_s,  Bayer and Unterauer, ACM Transactions on
       Database Systems, Vol. 2, 1 (March 1977), 11-26.

       _T_h_e _A_r_t  _o_f  _C_o_m_p_u_t_e_r  _P_r_o_g_r_a_m_m_i_n_g  _V_o_l_.  _3_:  _S_o_r_t_i_n_g  _a_n_d
       _S_e_a_r_c_h_i_n_g, D.E. Knuth, 1968, pp 471-480.

       _D_y_n_a_m_i_c _H_a_s_h _T_a_b_l_e_s, Per-Ake Larson, Communications of the
       ACM, April 1988.

       _A _N_e_w _H_a_s_h _P_a_c_k_a_g_e _f_o_r _U_N_I_X, Margo  Seltzer,  USENIX  Pro-
       ceedings, Winter 1991.

       _D_o_c_u_m_e_n_t  _P_r_o_c_e_s_s_i_n_g  _i_n  _a  _R_e_l_a_t_i_o_n_a_l  _D_a_t_a_b_a_s_e  _S_y_s_t_e_m,
       Michael  Stonebraker,  Heidi  Stettner,   Joseph   Kalash,
       Antonin  Guttman,  Nadene  Lynn,  Memorandum  No.  UCB/ERL
       M82/32, May 1982.

       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___i_n_t_e_r_n_a_l(3),
       _d_b___l_o_c_k(3), _d_b___l_o_g(3), _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_h_r_e_a_d(3),
       _d_b___t_x_n(3)
