

NNAAMMEE
       db_dbt - DB key/data pairs

SSYYNNOOPPSSIISS
       ttyyppeeddeeff ssttrruucctt {{
              vvooiidd **ddaattaa;;
              uu__iinntt3322__tt ssiizzee;;
              uu__iinntt3322__tt uulleenn;;
              uu__iinntt3322__tt ddlleenn;;
              uu__iinntt3322__tt ddooffff;;
              uu__iinntt3322__tt ffllaaggss;;
       }} DDBBTT;;

KKEEYY//DDAATTAA PPAAIIRRSS
       Storage  and retrieval for the DB access methods are based
       on key/data pairs.  Both key and  data  items  are  repre-
       sented by the DBT data structure.

       Key  and data byte strings may reference strings of essen-
       tially unlimited length, although any two  keys  must  fit
       into available memory at the same time so that they may be
       compared, and any one data item must  fit  into  available
       memory so that it may be returned.

       In  order  to ensure compatibility with future releases of
       DB, all fields of the DBT structure that are  not  explic-
       itly  set should be initialized to 0 before the first time
       the structure is used.  Do this by declaring the structure
       external  or  static,  or by calling the C library routine
       _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       By default, the _f_l_a_g_s structure element is expected to  be
       0.   In  this  default  case, when being provided a key or
       data item by the application, the DB package  expects  the
       _d_a_t_a  structure  element to point to a byte string of _s_i_z_e
       bytes.  When returning a key/data item to the application,
       the  DB package will store into the _d_a_t_a structure element
       a pointer to a byte string of _s_i_z_e bytes.  BByy ddeeffaauulltt,, tthhee
       mmeemmoorryy  rreeffeerreenncceedd  bbyy  tthhiiss  ssttoorreedd ppooiinntteerr iiss oonnllyy vvaalliidd
       uunnttiill tthhee nneexxtt ccaallll ttoo tthhee DDBB ppaacckkaaggee uussiinngg tthhee DDBB  hhaannddllee
       rreettuurrnneedd bbyy _d_b___o_p_e_n.

       TThhee aacccceessss mmeetthhooddss pprroovviiddee nnoo gguuaarraanntteeeess aabboouutt bbyyttee ssttrriinngg
       aalliiggnnmmeenntt,, aanndd aapppplliiccaattiioonnss aarree rreessppoonnssiibbllee ffoorr  mmaaiinnttaaiinn--
       iinngg  aannyy nneecceessssaarryy aalliiggnnmmeenntt..  Use the DB_DBT_USERMEM flag
       to cause returned items to be placed in  memory  of  arbi-
       trary alignment.

       The elements of the DBT structure are defined as follows:

       void *data;
            A pointer to a byte string.

       u_int32_t size;
            The length of _d_a_t_a, in bytes.

       u_int32_t ulen;
            The  size  of the user's buffer (referenced by _d_a_t_a),
            in bytes.  This location is not  written  by  the  DB
            functions.   See  the  DB_DBT_USERMEM  flag  for more
            information.

       u_int32_t dlen;
            The length of the partial record being read or  writ-
            ten   by   the   application,   in  bytes.   See  the
            DB_DBT_PARTIAL flag for more information.

       u_int32_t doff;
            The offset of the partial record being read or  writ-
            ten   by   the   application,   in  bytes.   See  the
            DB_DBT_PARTIAL flag for more information.

       u_int32_t flags;
            The flags value is specified by oorr'ing  together  one
            or more of the following values:

            DB_DBT_MALLOC
                 Ignored  except when retrieving information from
                 a database, e.g., a _D_B_-_>_g_e_t  or  _D_B_c_u_r_s_o_r_-_>_c___g_e_t
                 call.   This  flag  causes DB to allocate memory
                 for the returned key or data  item  (using  _m_a_l_-
                 _l_o_c(3),  or  the user-specified malloc function)
                 and return a pointer to it in the _d_a_t_a field  of
                 the  key  or  data DBT structure.  The allocated
                 memory becomes the responsibility of the calling
                 application.   It  is  an  error to specify both
                 DB_DBT_MALLOC and DB_DBT_USERMEM.

            DB_DBT_USERMEM
                 Ignored except when retrieving information  from
                 a  database,  e.g., a _D_B_-_>_g_e_t or _D_B_c_u_r_s_o_r_-_>_c___g_e_t
                 call.  The _d_a_t_a field of the key or data  struc-
                 ture must reference memory that is at least _u_l_e_n
                 bytes in length.  If the length of the requested
                 item  is  less  than  or equal to that number of
                 bytes, the item is copied into the memory refer-
                 enced by the _d_a_t_a field.  Otherwise, an error is
                 returned, the _s_i_z_e field is set  to  the  length
                 needed  for  the  requested  item, and the _e_r_r_n_o
                 variable is set to ENOMEM.  It is  an  error  to
                 specify both DB_DBT_MALLOC and DB_DBT_USERMEM.

            DB_DBT_PARTIAL
                 Ignored except when specified for a data parame-
                 ter,  where  this  flag   causes   the   partial
                 retrieval or storage of an item.  If the calling
                 application is  doing  a  get,  the  _d_l_e_n  bytes
                 starting  _d_o_f_f  bytes  from the beginning of the
                 retrieved data record are returned  as  if  they
                 comprised  the  entire record.  If any or all of
                 the specified bytes do not exist in the  record,
                 the  get is successful and the existing bytes or
                 0 bytes are returned.

                 For example, if the data portion of a  retrieved
                 record  was  100  bytes, and a partial retrieval
                 was done using a DBT having a _d_l_e_n field  of  20
                 and  a _d_o_f_f field of 85, the get call would suc-
                 ceed, the _d_a_t_a field would reference the last 15
                 bytes of the record, and the _s_i_z_e field would be
                 set to 15.

                 If the calling application is doing a  put,  the
                 _d_l_e_n  bytes  starting _d_o_f_f bytes from the begin-
                 ning of the  specified  key's  data  record  are
                 replaced  by  the data specified by the _d_a_t_a and
                 _s_i_z_e structure elements.   If  _d_l_e_n  is  smaller
                 than  _s_i_z_e, the record will grow, and if _d_l_e_n is
                 larger than _s_i_z_e, the record  will  shrink.   If
                 the  specified  bytes  do  not exist, the record
                 will be extended using nul bytes  as  necessary,
                 and the put call will succeed.

                 It  is  an  error to attempt a partial put using
                 the _D_B_-_>_p_u_t function in a database that supports
                 duplicate  records.   Partial  puts in databases
                 supporting duplicate records must be done  using
                 a  _d_b___c_u_r_s_o_r(3)  function.   It  is  an error to
                 attempt a partial put with  differing  _d_l_e_n  and
                 _s_i_z_e  values  in  a  recno  database with fixed-
                 length records.

                 For example, if the data portion of a  retrieved
                 record was 100 bytes, and a partial put was done
                 using a DBT having a _d_l_e_n field of  20,  a  _d_o_f_f
                 field of 85, and a _s_i_z_e field of 30, the result-
                 ing record would be 115 bytes in  length,  where
                 the  last  30  bytes would be those specified by
                 the put call.

       The default algorithm of associating returned key or  data
       items with the DB handle returned by _d_b___o_p_e_n(3) will obvi-
       ously not work when DB handles are being used concurrently
       by  multiple threads within a process, i.e, when DB_THREAD
       was specified to _d_b___o_p_e_n(3).  WWhheenn  mmuullttiippllee  tthhrreeaaddss  aarree
       uussiinngg  tthhee  rreettuurrnneedd  DDBB  hhaannddllee  ccoonnccuurrrreennttllyy,, eeiitthheerr tthhee
       DDBB__DDBBTT__MMAALLLLOOCC oorr DDBB__DDBBTT__UUSSEERRMMEEMM ffllaaggss  mmuusstt  bbee  ssppeecciiffiieedd
       ffoorr aannyy DDBBTT uusseedd ffoorr kkeeyy oorr ddaattaa rreettrriieevvaall..

LLOOGGIICCAALL RREECCOORRDD NNUUMMBBEERRSS
       In all cases for the recno access method, and when calling
       the  _d_b_-_>_g_e_t  and   _c_u_r_s_o_r_-_>_c___g_e_t   functions   with   the
       DB_SET_RECNO  flag  specified,  the  _d_a_t_a field of the key
       must be a pointer to a memory location of type _d_b___r_e_c_n_o___t,
       as  typedef'd  in the <db.h> include file.  This type is a
       32-bit unsigned type, (which limits the number of  logical
       records  in  a  recno  database,  and  the maximum logical
       record which  may  be  directly  retrieved  from  a  btree
       database,  to  4,294,967,296).   The _s_i_z_e field of the key
       should be the size of that type, e.g., in the  C  program-
       ming language, ``sizeof(db_recno_t)''.

       Logical record numbers are 1-based, not 0-based, i.e., the
       first record in the database is record number 1.

BBUUGGSS
       The DB access methods provide  no  guarantees  about  byte
       string  alignment,  and  applications  are responsible for
       maintaining any necessary alignment.

       The name DBT is a mnemonic for ``data  base  thang'',  and
       was  used  because  noone could think of a reasonable name
       that wasn't already in use somewhere else.

SSEEEE AALLSSOO
       The DB library is a family of  groups  of  functions  that
       provides  a  modular programming interface to transactions
       and record-oriented file  access.   The  library  includes
       support  for  transactions, locking, logging and file page
       caching, as well as various indexed access methods.   Many
       of  the  functional  groups  (e.g.,  the file page caching
       functions) are useful independent of the  other  DB  func-
       tions,  although  some  functional  groups  are explicitly
       based on other functional groups (e.g.,  transactions  and
       logging).   For  a  general description of the DB package,
       see _d_b___i_n_t_r_o(3).

       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___i_n_t_e_r_n_a_l(3),
       _d_b___l_o_c_k(3), _d_b___l_o_g(3), _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_h_r_e_a_d(3),
       _d_b___t_x_n(3)
