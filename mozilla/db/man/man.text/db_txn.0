

NNAAMMEE
       db_txn - DB transaction management

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb..hh>>

       iinntt
       ttxxnn__ooppeenn((ccoonnsstt cchhaarr **ddiirr,,
            uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,, DDBB__EENNVV **ddbbeennvv,, DDBB__TTXXNNMMGGRR ****rreeggiioonnpp));;

       iinntt
       ttxxnn__bbeeggiinn((DDBB__TTXXNNMMGGRR **ttxxnnpp,, DDBB__TTXXNN **ppiidd,, DDBB__TTXXNN ****ttiidd));;

       iinntt
       ttxxnn__pprreeppaarree((DDBB__TTXXNN **ttiidd));;

       iinntt
       ttxxnn__ccoommmmiitt((DDBB__TTXXNN **ttiidd));;

       iinntt
       ttxxnn__aabboorrtt((DDBB__TTXXNN **ttiidd));;

       uu__iinntt3322__tt
       ttxxnn__iidd((DDBB__TTXXNN **ttiidd));;

       iinntt
       ttxxnn__cchheecckkppooiinntt((ccoonnsstt DDBB__TTXXNNMMGGRR **ttxxnnpp,, uu__iinntt3322__tt kkbbyyttee,, uu__iinntt3322__tt mmiinn));;

       iinntt
       ttxxnn__cclloossee((DDBB__TTXXNNMMGGRR **ttxxnnpp));;

       iinntt
       ttxxnn__uunnlliinnkk((ccoonnsstt cchhaarr **ddiirr,, iinntt ffoorrccee,, DDBB__EENNVV **ddbbeennvv));;

       iinntt
       ttxxnn__ssttaatt((DDBB__TTXXNNMMGGRR **ttxxnnpp,,
            DDBB__TTXXNN__SSTTAATT ****ssttaattpp,, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt))));;

DDEESSCCRRIIPPTTIIOONN
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see _d_b___i_n_t_r_o(3).

       This  manual page describes the specific details of the DB
       transaction support.

       The _d_b___t_x_n functions are the library interface  that  pro-
       vides  transaction semantics.  Full transaction support is
       provided by a collection of modules  that  provide  inter-
       faces to the services required for transaction processing.

       These services are recovery (see  _d_b___l_o_g(3)),  concurrency
       control  (see  _d_b___l_o_c_k(3)),  and  the management of shared
       data (see  _d_b___m_p_o_o_l(3)).   Transaction  semantics  can  be
       applied  to  the  access  methods  described in _d_b___o_p_e_n(3)
       through function call parameters.

       The model intended for transactional use (and the one that
       is used by the access methods) is write-ahead logging pro-
       vided by _d_b___l_o_g(3)  to  record  both  before-  and  after-
       images.   Locking  follows  a two-phase protocol, with all
       locks being released at transaction commit.

  _t_x_n___o_p_e_n
       The _t_x_n___o_p_e_n function copies a pointer, to the transaction
       region  identified  by  the ddiirreeccttoorryy _d_i_r, into the memory
       location referenced by _r_e_g_i_o_n_p.

       If the _d_b_e_n_v argument to _t_x_n___o_p_e_n  was  initialized  using
       _d_b___a_p_p_i_n_i_t,   _d_i_r   is   interpreted   as   described   by
       _d_b___a_p_p_i_n_i_t(3).

       Otherwise, if _d_i_r is not NULL, it is interpreted  relative
       to  the  current working directory of the process.  If _d_i_r
       is NULL, the following environment variables  are  checked
       in  order:  ``TMPDIR'',  ``TEMP'', and ``TMP''.  If one of
       them is set, transaction region files are created relative
       to  the  directory it specifies.  If none of them are set,
       the first possible one of  the  following  directories  is
       used: _/_v_a_r_/_t_m_p, _/_u_s_r_/_t_m_p, _/_t_e_m_p, _/_t_m_p, _C_:_/_t_e_m_p and _C_:_/_t_m_p.

       All files associated with the transaction region are  cre-
       ated in this directory.  This directory must already exist
       when

       transaction region_open is  called.   If  the  transaction
       region already exists, the process must have permission to
       read and write the existing  files.   If  the  transaction
       region  does  not  already exist, it is optionally created
       and initialized.

       The _f_l_a_g_s and _m_o_d_e arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.


       DB_THREAD
            Cause  the  DB_TXNMGR handle returned by the _t_x_n___o_p_e_n
            function to be useable by multiple threads  within  a
            single  address space, i.e., to be ``free-threaded''.

       DB_TXN_NOSYNC
            On transaction commit, do not synchronously flush the
            log.   This  means  that transactions exhibit the ACI
            (atomicity, consistency  and  isolation)  properties,
            but not D (durability), i.e., database integrity will
            be maintained but it is possible that some number  of
            the  most  recently  committed  transactions  may  be
            undone during recovery instead of being redone.

            The number of transactions that  are  potentially  at
            risk is governed by how often the log is checkpointed
            (see _d_b___c_h_e_c_k_p_o_i_n_t(1)) and how many log  updates  can
            fit on a single log page.

       All files created by the transaction subsystem are created
       with mode _m_o_d_e (as described in _c_h_m_o_d(2)) and modified  by
       the  process'  umask  value  at  the time of creation (see
       _u_m_a_s_k(2)).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

       The transaction subsystem is configured based on the _d_b_e_n_v
       argument to _t_x_n___o_p_e_n, which is a pointer to a structure of
       type DB_ENV (typedef'd in <db.h>).  Applications will nor-
       mally  use  the  same  DB_ENV  structure  (initialized  by
       _d_b___a_p_p_i_n_i_t(3)), as an argument to all of the subsystems in
       the DB package.

       References  to  the DB_ENV structure are maintained by DB,
       so it may not be discarded until the last close  function,
       corresponding  to  an  open  function  for which it was an
       argument, has returned.  In order to ensure  compatibility
       with  future  releases  of  DB,  all  fields of the DB_ENV
       structure that are not explicitly set should  be  initial-
       ized to 0 before the first time the structure is used.  Do
       this by declaring the structure external or static, or  by
       calling the C library routine _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       The  fields  of  the DB_ENV structure used by _t_x_n___o_p_e_n are
       described below.  If _d_b_e_n_v is NULL or any  of  its  fields
       are set to 0, defaults appropriate for the system are used
       where possible.

       The following fields in the DB_ENV structure may  be  ini-
       tialized before calling _t_x_n___o_p_e_n:

       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       int db_verbose;
            The  error  fields  of the DB_ENV behave as described
            for _d_b___a_p_p_i_n_i_t(3).


       DB_LOG *lg_info;
            The logging region that is being used for this trans-
            action  environment.   The  _l_g___i_n_f_o  field contains a
            return value from the function _l_o_g___o_p_e_n.  LLooggggiinngg  iiss
            rreeqquuiirreedd  ffoorr  ttrraannssaaccttiioonn eennvviirroonnmmeennttss,, aanndd iitt iiss aann
            eerrrroorr ttoo nnoott ssppeecciiffyy aa llooggggiinngg rreeggiioonn..

       DB_LOCKTAB *lk_info;
            The locking region that is being used for this trans-
            action  environment.   The  _l_k___i_n_f_o  field contains a
            return value from the function _l_o_c_k___o_p_e_n.  If _l_k___i_n_f_o
            is NULL, no locking is done in this transaction envi-
            ronment.

       u_int32_t tx_max;
            The maximum number of simultaneous transactions  that
            are supported.  This bounds the size of backing files
            and is used to derive limits for the size of the lock
            region and logfiles.  When there are more than _t_x___m_a_x
            concurrent transactions, calls to _t_x_n___b_e_g_i_n may cause
            backing  files  to  grow.   If _t_x___m_a_x is 0, a default
            value is used.

       int (*tx_recover)(DB_LOG *logp, DBT *log_rec,
                 DB_LSN *lsnp, int redo, void *info);
            A function that is called by _t_x_n___a_b_o_r_t during  trans-
            action abort.  This function takes five arguments:

            logp A pointer to the transaction log (DB_LOG *).

            log_rec
                 A log record.

            lsnp A pointer to a log sequence number (DB_LSN *).

            redo An  integer value that is set to one of the fol-
                 lowing values:

                 DB_TXN_BACKWARD_ROLL
                      The log is being read backward to determine
                      which  transactions have been committed and
                      which transactions  were  not  (and  should
                      therefore be aborted during recovery).

                 DB_TXN_FORWARD_ROLL
                      The log is being played forward, any trans-
                      action ids encountered that have  not  been
                      entered  into  the  list referenced by _i_n_f_o
                      should be ignored.

                 DB_TXN_OPENFILES
                      The log is being read to open all the files
                      required to perform recovery.

                 DB_TXN_REDO
                      Redo  the  operation  described  by the log
                      record.

                 DB_TXN_UNDO
                      Undo the operation  described  by  the  log
                      record.

            info An  opaque pointer used to reference the list of
                 transaction IDs encountered during recovery.

            If _r_e_c_o_v_e_r is NULL,  the  default  is  that  only  DB
            access  method  operations are transaction protected,
            and the default recover function will be used.

       The _t_x_n___o_p_e_n function returns the value of _e_r_r_n_o on  fail-
       ure and 0 on success.

  _t_x_n___b_e_g_i_n
       The  _t_x_n___b_e_g_i_n  function  creates a new transaction in the
       designated transaction manager, copying  a  pointer  to  a
       DB_TXN  that uniquely identifies it into the memory refer-
       enced by _t_i_d.  If the _p_i_d argument is  non-NULL,  the  new
       transaction  is  a nested transaction with the transaction
       indicated by _p_i_d as its parent.

       Transactions may not span threads, i.e., each  transaction
       must  begin  and end in the same thread, and each transac-
       tion may only be used by a single thread.

       The _t_x_n___b_e_g_i_n function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _t_x_n___p_r_e_p_a_r_e
       The  _t_x_n___p_r_e_p_a_r_e function initiates the beginning of a two
       phase commit.  In a distributed  transaction  environment,
       _d_b  can  be  used as a local transaction manager.  In this
       case, the distributed transaction manager must  send  _p_r_e_-
       _p_a_r_e  messages  to  each local manager.  The local manager
       must then issue a _t_x_n___p_r_e_p_a_r_e  and  await  its  successful
       return  before  responding  to the distributed transaction
       manager.  Only after the distributed  transaction  manager
       receives successful responses from all of its _p_r_e_p_a_r_e mes-
       sages should it issue any _c_o_m_m_i_t messages.

       The _t_x_n___p_r_e_p_a_r_e function returns the  value  of  _e_r_r_n_o  on
       failure and 0 on success.

  _t_x_n___c_o_m_m_i_t
       The  _t_x_n___c_o_m_m_i_t function ends the transaction specified by
       the _t_i_d argument.  If DB_TXN_NOSYNC was not  specified,  a
       commit  log  record is written and flushed to disk, as are
       all previously written log records.  If the transaction is
       nested,  its locks are acquired by the parent transaction,
       otherwise its locks are released.  Any  applications  that
       require  strict  two-phase  locking  must  not release any
       locks explicitly, leaving  them  all  to  be  released  by
       _t_x_n___c_o_m_m_i_t.

       The  _t_x_n___c_o_m_m_i_t  function  returns  the  value of _e_r_r_n_o on
       failure and 0 on success.

  _t_x_n___a_b_o_r_t
       The _t_x_n___a_b_o_r_t function causes an abnormal  termination  of
       the transaction.  The log is played backwards and any nec-
       essary  recovery  operations  are  initiated  through  the
       _r_e_c_o_v_e_r function specified to _t_x_n___o_p_e_n.  After recovery is
       completed, all locks held by the transaction are  acquired
       by the parent transaction in the case of a nested transac-
       tion or released in the case of a non-nested  transaction.
       As  is  the case for _t_x_n___c_o_m_m_i_t, applications that require
       strict two phase locking should not explicitly release any
       locks.

       The _t_x_n___a_b_o_r_t function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _t_x_n___i_d
       The _t_x_n___i_d function  returns  the  unique  transaction  id
       associated  with the specified transaction.  Locking calls
       made on behalf of this transaction should  use  the  value
       returned  from  _t_x_n___i_d  as  the  locker  parameter  to the
       _l_o_c_k___g_e_t or _l_o_c_k___v_e_c calls.

  _t_x_n___c_l_o_s_e
       The _t_x_n___c_l_o_s_e function detaches a process from the  trans-
       action  environment  specified  by  the DB_TXNMGR pointer.
       All  mapped  regions  are  unmapped  and   any   allocated
       resources  are  freed.   Any  uncommitted transactions are
       aborted.

       In addition, if the _d_i_r argument to _t_x_n___o_p_e_n was NULL  and
       _d_b_e_n_v was not initialized using _d_b___a_p_p_i_n_i_t, all files cre-
       ated for  this  shared  region  will  be  removed,  as  if
       _t_x_n___u_n_l_i_n_k were called.

       When  multiple threads are using the DB_TXNMGR handle con-
       currently, only a single thread  may  call  the  _t_x_n___c_l_o_s_e
       function.

       The _t_x_n___c_l_o_s_e function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.


  _t_x_n___u_n_l_i_n_k
       The _t_x_n___u_n_l_i_n_k function destroys  the  transaction  region
       identified  by  the directory _d_i_r, removing all files used
       to implement the transaction region.  (The  directory  _d_i_r
       is  not removed.)  If there are processes that have called
       _t_x_n___o_p_e_n without calling _t_x_n___c_l_o_s_e (i.e., there  are  pro-
       cesses currently using the transaction region), _t_x_n___u_n_l_i_n_k
       will fail without further action, unless the force flag is
       set,  in  which case _t_x_n___u_n_l_i_n_k will attempt to remove the
       transaction region files regardless of any processes still
       using the transaction region.

       The  result  of  attempting to forcibly destroy the region
       when a process has the region open is  unspecified.   Pro-
       cesses  using a shared memory region maintain an open file
       descriptor for it.  On UNIX systems,  the  region  removal
       should  succeed and processes that have already joined the
       region should  continue  to  run  in  the  region  without
       change,  however processes attempting to join the transac-
       tion region will either fail or attempt to  create  a  new
       region.   On other systems, e.g., WNT, where the _u_n_l_i_n_k(2)
       system call will fail if any  process  has  an  open  file
       descriptor for the file, the region removal will fail.

       In  the  case  of catastrophic or system failure, database
       recovery must  be  performed  (see  _d_b___r_e_c_o_v_e_r(1)  or  the
       DB_RECOVER  and  DB_RECOVER_FATAL flags to _d_b___a_p_p_i_n_i_t(3)).
       Alternatively, if recovery  is  not  required  because  no
       database state is maintained across failures, it is possi-
       ble to clean up a transaction region by  removing  all  of
       the files in the directory specified to the _t_x_n___o_p_e_n func-
       tion, as transaction region files are never created in any
       directory other than the one specified to _t_x_n___o_p_e_n.  Note,
       however, that this has the potential to remove files  cre-
       ated  by the other DB subsystems in this database environ-
       ment.

       The _t_x_n___u_n_l_i_n_k function returns  the  value  of  _e_r_r_n_o  on
       failure and 0 on success.

  _t_x_n___c_h_e_c_k_p_o_i_n_t
       The  _t_x_n___c_h_e_c_k_p_o_i_n_t  function  syncs the underlying memory
       pool, writes a checkpoint  record  to  the  log  and  then
       flushes the log.

       If either _k_b_y_t_e or _m_i_n is non-zero, the checkpoint is only
       done if more than _m_i_n minutes have passed since  the  last
       checkpoint,  or  if  more than _k_b_y_t_e kilobytes of log data
       have been written since the last checkpoint.

       The _t_x_n___c_h_e_c_k_p_o_i_n_t function returns the value of _e_r_r_n_o  on
       failure,  0  on  success,  and DB_INCOMPLETE if there were
       pages that needed to be written but that _m_e_m_p___s_y_n_c(3)  was
       unable to write immediately.  In this case, the _t_x_n___c_h_e_c_k_-
       _p_o_i_n_t call should be retried.


       The _t_x_n___c_h_e_c_k_p_o_i_n_t function  is  the  underlying  function
       used by the _d_b___c_h_e_c_k_p_o_i_n_t(1) utility.  See the source code
       for the _d_b___c_h_e_c_k_p_o_i_n_t utility  for  an  example  of  using
       _t_x_n___c_h_e_c_k_p_o_i_n_t in a UNIX environment.

  _t_x_n___s_t_a_t
       The  _t_x_n___s_t_a_t function creates a statistical structure and
       copies a pointer to  it  into  the  user-specified  memory
       location.

       Statistical structure are created in allocated memory.  If
       _d_b___m_a_l_l_o_c is non-NULL, it is called to allocate  the  mem-
       ory,  otherwise,  the  library function _m_a_l_l_o_c(3) is used.
       The function _d_b___m_a_l_l_o_c must match the calling  conventions
       of  the _m_a_l_l_o_c(3) library routine.  Regardless, the caller
       is responsible for deallocating the returned  memory.   To
       deallocate  the returned memory, free each returned memory
       pointer; pointers inside the memory  do  not  need  to  be
       individually freed.

       The  transaction  region statistics are stored in a struc-
       ture of type DB_TXN_STAT (typedef'd in <db.h>).  The  fol-
       lowing DB_TXN_STAT fields will be filled in:

       u_int32_t st_refcnt;
            The number of references to the region.
       u_int32_t st_regsize;
            The size of the region.
       DB_LSN st_last_ckp;
            The LSN of the last checkpoint.
       DB_LSN st_pending_ckp;
            The  LSN  of  any  checkpoint  that  is  currently in
            progress.   If  _s_t___p_e_n_d_i_n_g___c_k_p   is   the   same   as
            _s_t___l_a_s_t___c_k_p there is no checkpoint in progress.
       time_t st_time_ckp;
            The  time  the last completed checkpoint finished (as
            returned by _t_i_m_e(2)).
       u_int32_t st_last_txnid;
            The last transaction ID allocated.
       u_int32_t st_maxtxns;
            The maximum number of active  transactions  supported
            by the region.
       u_int32_t st_naborts;
            The number of transactions that have aborted.
       u_int32_t st_nactive;
            The number of transactions that are currently active.
       u_int32_t st_nbegins;
            The number of transactions that have begun.
       u_int32_t st_ncommits;
            The number of transactions that have committed.
       u_int32_t st_region_wait;
            The number of times that  a  thread  of  control  was
            forced to wait before obtaining the region lock.

       u_int32_t st_region_nowait;
            The number of times that a thread of control was able
            to obtain the region lock without waiting.
       DB_TXN_ACTIVE *st_txnarray;
            A pointer to an  array  of  _s_t___n_a_c_t_i_v_e  DB_TXN_ACTIVE
            structures,  describing the currently active transac-
            tions.  The following  fields  of  the  DB_TXN_ACTIVE
            structure (typedef'd in <db.h>) will be filled in:


            u_int32_t txnid;
                 The  transaction ID as returned by _t_x_n___b_e_g_i_n(3).
            DB_LSN lsn;
                 The LSN of the transaction-begin record.


TTRRAANNSSAACCTTIIOONNSS
       Creating transaction protected applications using  the  DB
       access  methods  requires little system customization.  In
       most cases, the default parameters to  the  locking,  log-
       ging,  memory  pool,  and transaction subsystems will suf-
       fice.  Applications can use _d_b___a_p_p_i_n_i_t(3) to perform  this
       initialization, or they may do it explicitly.

       Each  database  operation  (i.e.,  any  call to a function
       underlying the handles returned by _d_b___o_p_e_n(3) and  _d_b___c_u_r_-
       _s_o_r(3))  is  normally  performed  on  behalf  of  a unique
       locker.  If multiple calls on behalf of  the  same  locker
       are desired, then transactions must be used.

       Once  the  application  has  initialized the DB subsystems
       that it is  using,  it  may  open  the  DB  access  method
       databases.   For applications performing transactions, the
       databases must be opened after  subsystem  initialization,
       and  cannot  be opened as part of a transaction.  Once the
       databases are opened, the application can  group  sets  of
       operations  into  transactions,  by surrounding the opera-
       tions  with  the  appropriate  _t_x_n___b_e_g_i_n,  _t_x_n___c_o_m_m_i_t  and
       _t_x_n___a_b_o_r_t calls.  Databases accessed by a transaction must
       not be closed during the transaction.   Note,  it  is  not
       necessary  to  transaction protect read-only transactions,
       unless those transactions require repeatable reads.

       The DB access methods will make the appropriate calls into
       the lock, log and memory pool subsystems in order to guar-
       antee that transaction semantics are  applied.   When  the
       application is ready to exit, all outstanding transactions
       should have been committed or aborted.  At this point, all
       open  DB  files  should  be  closed.  Once the DB database
       files are closed, the  DB  subsystems  should  be  closed,
       either explicitly or by calling _d_b___a_p_p_e_x_i_t(3).

       It is also possible to use the locking, logging and trans-
       action subsystems of DB to provide  transaction  semantics
       to  objects  other  than  those described by the DB access
       methods.  In these cases, the application will  need  more
       explicit  customization  of  the subsystems as well as the
       development of appropriate data-structure-specific  recov-
       ery functions.

       For  example, consider an application that provides trans-
       action semantics  to  data  stored  in  plain  UNIX  files
       accessed using the _r_e_a_d(2) and _w_r_i_t_e(2) system calls.  The
       operations for which transaction protection is desired are
       bracketed by calls to _t_x_n___b_e_g_i_n and _t_x_n___c_o_m_m_i_t.

       Before  data  are  referenced, the application must make a
       call to the lock manager,  _d_b___l_o_c_k,  for  a  lock  of  the
       appropriate  type (e.g., read) on the object being locked.
       The object might be a page in the file, a byte, a range of
       bytes, or some key.  It is up to the application to ensure
       that appropriate locks are acquired.  Before  a  write  is
       performed,  the application should acquire a write lock on
       the object, by making an appropriate call to the lock man-
       ager,  _d_b___l_o_c_k.   Then, the application should make a call
       to the log manager, _d_b___l_o_g, to record  enough  information
       to  redo the operation in case of failure after commit and
       to undo the operation in case of abort.  As  discussed  in
       the  _d_b___l_o_g(3) manual page, the application is responsible
       for providing any necessary structure to the  log  record.
       For  example, the application must understand what part of
       the log record is an operation code, what part  identifies
       the  file  being  modified, what part is redo information,
       and what part is undo information.

       After the log message  is  written,  the  application  may
       issue  the  write  system  call.   After  all requests are
       issued,  the  application  may  call   _t_x_n___c_o_m_m_i_t.    When
       _t_x_n___c_o_m_m_i_t returns, the caller is guaranteed that all nec-
       essary log writes have been written to disk.

       At any time, the application  may  call  _t_x_n___a_b_o_r_t,  which
       will  result in the appropriate calls to the _r_e_c_o_v_e_r func-
       tion to restore the  ``database''  to  a  consistent  pre-
       transaction  state.  (The recover function must be able to
       either re-apply or undo the update depending on  the  con-
       text, for each different type of log record.)

       If the application should crash, the recovery process uses
       the _d_b___l_o_g interface to read the log and call the  _r_e_c_o_v_e_r
       function to restore the database to a consistent state.

       The  _t_x_n___p_r_e_p_a_r_e  function provides the core functionality
       to implement distributed transactions,  but  it  does  not
       manage  the  notification  of distributed transaction man-
       agers.  The caller is responsible for issuing  _t_x_n___p_r_e_p_a_r_e
       calls  to  all sites participating in the transaction.  If
       all  responses  are  positive,  the  caller  can  issue  a
       _t_x_n___c_o_m_m_i_t.   If  any  of  the responses are negative, the
       caller should issue a _t_x_n___a_b_o_r_t.  In general, the _t_x_n___p_r_e_-
       _p_a_r_e  call requires that the transaction log be flushed to
       disk.

TTRRAANNSSAACCTTIIOONN IIDD LLIIMMIITTSS
       The transaction ID space in Berkeley DB is 2^31, or 2 bil-
       lion  entries.   It is possible that some environments may
       need to be aware of this limitation.  Consider an applica-
       tion  performing  600 transactions a second for 15 hours a
       day.  The transaction ID space will run out in roughly  66
       days:

              2^31 / (600 * 15 * 60 * 60) = 66

       Doing only 100 transactions a second exhausts the transac-
       tion ID space in roughly one year.

       The transaction ID space is reset each  time  recovery  is
       run.   If  you reach the end of your transaction ID space,
       shut down your applications and restart them after running
       recovery  (see  _d_b___r_e_c_o_v_e_r(1)  for more information).  The
       most   recently   allocated   transaction   ID   is    the
       _s_t___l_a_s_t___t_x_n_i_d value in the transaction statistics informa-
       tion, and is displayed by the _d_b___s_t_a_t(1) utility.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The following environment variables affect  the  execution
       of _d_b___t_x_n:

       DB_HOME
            If  the  _d_b_e_n_v  argument  to _t_x_n___o_p_e_n was initialized
            using _d_b___a_p_p_i_n_i_t, the  environment  variable  DB_HOME
            may  be used as the path of the database home for the
            interpretation of the _d_i_r argument  to  _t_x_n___o_p_e_n,  as
            described in _d_b___a_p_p_i_n_i_t(3).

       TMPDIR
            If  the  _d_b_e_n_v  argument  to _t_x_n___o_p_e_n was NULL or not
            initialized using _d_b___a_p_p_i_n_i_t, the  environment  vari-
            able  TMPDIR may be used as the directory in which to
            create the transaction region, as  described  in  the
            _t_x_n___o_p_e_n section above.

EERRRROORRSS
       The _t_x_n___o_p_e_n function may fail and return _e_r_r_n_o for any of
       the errors specified for  the  following  DB  and  library
       functions: close(2), db_version(3), fcntl(2), fflush(3),
       lseek(2), malloc(3), memcpy(3), memset(3), mmap(2), mun-
       map(2), open(2), sigfillset(3), sigprocmask(2), stat(2),
       strcpy(3), strdup(3), strerror(3), strlen(3), time(3),
       txn_unlink(3), unlink(2), and write(2).

       In  addition,  the  _t_x_n___o_p_e_n  function may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_THREAD flag was specified  and  spinlocks  are
            not implemented for this architecture.

            The _d_b_e_n_v parameter was NULL.

       [EAGAIN]
            The  shared memory region was locked and (repeatedly)
            unavailable.

       The _t_x_n___b_e_g_i_n function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: fcntl(2), fflush(3), log_put(3), lseek(2), mal-
       loc(3), memcpy(3), memset(3), mmap(2), munmap(2), str-
       error(3), and write(2).

       In addition, the _t_x_n___b_e_g_i_n function may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [ENOSPC]
            The  maximum  number  of  concurrent transactions has
            been reached.

       The _t_x_n___p_r_e_p_a_r_e function may fail and return _e_r_r_n_o for any
       of  the  errors specified for the following DB and library
       functions: fcntl(2), fflush(3), log_flush(3), and str-
       error(3).

       The  _t_x_n___c_o_m_m_i_t function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: fcntl(2), fflush(3), lock_vec(3), log_put(3),
       malloc(3), memcpy(3), and strerror(3).

       In addition, the _t_x_n___c_o_m_m_i_t function may fail  and  return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            The transaction was aborted.

       The  _t_x_n___a_b_o_r_t  function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: DBenv->tx_recover(3), fcntl(2), fflush(3),
       lock_vec(3), log_get(3), memset(3), and strerror(3).

       [EINVAL]
            The transaction was already aborted.

       The _t_x_n___c_h_e_c_k_p_o_i_n_t function may fail and return _e_r_r_n_o  for
       any  of  the  errors  specified  for  the following DB and
       library functions: fcntl(2), fflush(3), log_compare(3),
       log_put(3), malloc(3), memcpy(3), memp_sync(3), memset(3),
       strerror(3), and time(3).

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _t_x_n___c_l_o_s_e function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: close(2), fcntl(2), fflush(3), log_flush(3),
       munmap(2), strerror(3), and txn_abort(3).

       The  _t_x_n___u_n_l_i_n_k function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: close(2), fcntl(2), fflush(3), malloc(3), mem-
       cpy(3), memset(3), mmap(2), munmap(2), open(2), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3), strlen(3), and unlink(2).

       In addition, the _t_x_n___u_n_l_i_n_k function may fail  and  return
       _e_r_r_n_o for the following conditions:

       [EBUSY]
            The  shared  memory  region  was in use and the force
            flag was not set.

       The _t_x_n___s_t_a_t function may fail and return _e_r_r_n_o for any of
       the  errors  specified  for  the  following DB and library
       functions: fcntl(2), and malloc(3).

SSEEEE AALLSSOO
       _L_I_B_T_P_: _P_o_r_t_a_b_l_e_,  _M_o_d_u_l_a_r  _T_r_a_n_s_a_c_t_i_o_n_s  _f_o_r  _U_N_I_X,  Margo
       Seltzer, Michael Olson, USENIX proceedings, Winter 1992.

BBUUGGSS
       Nested transactions are not yet implemented.

       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___i_n_t_e_r_n_a_l(3),
       _d_b___l_o_c_k(3), _d_b___l_o_g(3), _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_h_r_e_a_d(3),
       _d_b___t_x_n(3)
