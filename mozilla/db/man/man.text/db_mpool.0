

NNAAMMEE
       db_mpool - shared memory buffer pool

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb..hh>>

       iinntt
       mmeemmpp__ooppeenn((cchhaarr **ddiirr,,
            uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,, DDBB__EENNVV **ddbbeennvv,, DDBB__MMPPOOOOLL ****rreeggiioonnpp));;

       iinntt
       mmeemmpp__cclloossee((DDBB__MMPPOOOOLL **mmpp));;

       iinntt
       mmeemmpp__ffooppeenn((DDBB__MMPPOOOOLL **mmpp,, cchhaarr **ffiillee,, uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,,
            ssiizzee__tt ppaaggeessiizzee,, DDBB__MMPPOOOOLL__FFIINNFFOO **ffiinnffoopp,, DDBB__MMPPOOOOLLFFIILLEE ****mmppff));;

       iinntt
       mmeemmpp__ffcclloossee((DDBB__MMPPOOOOLLFFIILLEE **mmppff));;

       iinntt
       mmeemmpp__ffggeett((DDBB__MMPPOOOOLLFFIILLEE **mmppff,,
            ddbb__ppggnnoo__tt **ppggnnooaaddddrr,, uu__iinntt3322__tt ffllaaggss,, vvooiidd ****ppaaggeepp));;

       iinntt
       mmeemmpp__ffppuutt((DDBB__MMPPOOOOLLFFIILLEE **mmppff,, vvooiidd **ppggaaddddrr,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       mmeemmpp__ffsseett((DDBB__MMPPOOOOLLFFIILLEE **mmppff,, vvooiidd **ppggaaddddrr,, uu__iinntt3322__tt ffllaaggss));;

       iinntt
       mmeemmpp__ffssyynncc((DDBB__MMPPOOOOLLFFIILLEE **mmppff));;

       iinntt
       mmeemmpp__uunnlliinnkk((ccoonnsstt cchhaarr **ddiirr,, iinntt ffoorrccee,, DDBB__EENNVV **));;

       iinntt
       mmeemmpp__rreeggiisstteerr((DDBB__MMPPOOOOLL **mmpp,, iinntt ffttyyppee,,
            iinntt ((**ppggiinn))((ddbb__ppggnnoo__tt ppggnnoo,, vvooiidd **ppggaaddddrr,, DDBBTT **ppggccooookkiiee)),,
            iinntt ((**ppggoouutt))((ddbb__ppggnnoo__tt ppggnnoo,, vvooiidd **ppggaaddddrr,, DDBBTT **ppggccooookkiiee))));;

       iinntt
       mmeemmpp__ttrriicckkllee((DDBB__MMPPOOOOLL **mmpp,, iinntt ppcctt,, iinntt **nnwwrrootteepp));;

       iinntt
       mmeemmpp__ssyynncc((DDBB__MMPPOOOOLL **mmpp,, LLSSNN **llssnn));;

       iinntt
       mmeemmpp__ssttaatt((DDBB__MMPPOOOOLL **mmpp,, DDBB__MMPPOOOOLL__SSTTAATT ****ggsspp,,
            DDBB__MMPPOOOOLL__FFSSTTAATT **((**ffsspp))[[]],, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt))));;

DDEESSCCRRIIPPTTIIOONN
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see _d_b___i_n_t_r_o(3).

       This  manual  page  describes  the specific details of the
       memory pool interface.

       The _d_b___m_p_o_o_l functions are the library interface  intended
       to  provide  general-purpose, page-oriented buffer manage-
       ment of one or more files.  While designed  to  work  with
       the  other  DB  functions, these functions are also useful
       for more general purposes.  The memory pools  (DB_MPOOL's)
       are  referred  to  in  this  document as simply ``pools''.
       Pools may be shared between processes.  Pools are  usually
       filled  by  pages from one or more files (DB_MPOOLFILE's).
       Pages in the pool are  replaced  in  LRU  (least-recently-
       used)  order,  with  each new page replacing the page that
       has been unused the longest.   Pages  retrieved  from  the
       pool  using  _m_e_m_p___f_g_e_t  are  ``pinned''  in  the  pool, by
       default, until they are returned  to  the  pool's  control
       using the _m_e_m_p___f_p_u_t function.

  _m_e_m_p___o_p_e_n
       The  _m_e_m_p___o_p_e_n  function  copies  a pointer, to the memory
       pool identified by the  ddiirreeccttoorryy  _d_i_r,  into  the  memory
       location referenced by _r_e_g_i_o_n_p.

       If  the  _d_b_e_n_v argument to _m_e_m_p___o_p_e_n was initialized using
       _d_b___a_p_p_i_n_i_t,   _d_i_r   is   interpreted   as   described   by
       _d_b___a_p_p_i_n_i_t(3).

       Otherwise,  if _d_i_r is not NULL, it is interpreted relative
       to the current working directory of the process.   If  _d_i_r
       is  NULL,  the following environment variables are checked
       in order: ``TMPDIR'', ``TEMP'', and ``TMP''.   If  one  of
       them is set, memory pool files are created relative to the
       directory it specifies.  If none  of  them  are  set,  the
       first  possible  one of the following directories is used:
       _/_v_a_r_/_t_m_p, _/_u_s_r_/_t_m_p, _/_t_e_m_p, _/_t_m_p, _C_:_/_t_e_m_p and _C_:_/_t_m_p.

       All files associated with the memory pool are  created  in
       this directory.  This directory must already exist when

       memory  pool_open  is  called.  If the memory pool already
       exists, the process must have permission to read and write
       the  existing  files.  If the memory pool does not already
       exist, it is optionally created and initialized.

       The _f_l_a_g_s and _m_o_d_e arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by oorr'ing together one or more of
       the following values:
       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.

       DB_MPOOL_PRIVATE
            Create  a  private  MPOOL that is not shared with any
            other process (although it may be shared  with  other
            threads).

       DB_NOMMAP
            Always  copy files in this memory pool into the local
            cache instead of mapping  them  into  process  memory
            (see  the description of the _m_p___m_m_a_p_s_i_z_e field of the
            DB_ENV structure for further information).


       DB_THREAD
            Cause the DB_MPOOL handle returned by  the  _m_e_m_p___o_p_e_n
            function  to  be useable by multiple threads within a
            single address space, i.e., to be  ``free-threaded''.

       All files created by the memory pool subsystem (other than
       files created by the _m_e_m_p___f_o_p_e_n function, which are  sepa-
       rately specified) are created with mode _m_o_d_e (as described
       in _c_h_m_o_d(2)) and modified by the process' umask  value  at
       the  time of creation (see _u_m_a_s_k(2)).  The group ownership
       of created files is based  on  the  system  and  directory
       defaults, and is not further specified by DB.

       The memory pool subsystem is configured based on the _d_b_e_n_v
       argument to _m_e_m_p___o_p_e_n, which is a pointer to  a  structure
       of  type  DB_ENV (typedef'd in <db.h>).  Applications will
       normally use the same  DB_ENV  structure  (initialized  by
       _d_b___a_p_p_i_n_i_t(3)), as an argument to all of the subsystems in
       the DB package.

       References to the DB_ENV structure are maintained  by  DB,
       so  it may not be discarded until the last close function,
       corresponding to an open function  for  which  it  was  an
       argument,  has returned.  In order to ensure compatibility
       with future releases of  DB,  all  fields  of  the  DB_ENV
       structure  that  are not explicitly set should be initial-
       ized to 0 before the first time the structure is used.  Do
       this  by declaring the structure external or static, or by
       calling the C library routine _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       The fields of the DB_ENV structure used by  _m_e_m_p___o_p_e_n  are
       described  below.   If  _d_b_e_n_v is NULL or any of its fields
       are set to 0, defaults appropriate for the system are used
       where possible.

       The  following  fields in the DB_ENV structure may be ini-
       tialized before calling _m_e_m_p___o_p_e_n:
       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       int db_verbose;
            The error fields of the DB_ENV  behave  as  described
            for _d_b___a_p_p_i_n_i_t(3).



       size_t mp_mmapsize;
            Files that are opened read-only in the pool (and that
            satisfy a few other criteria) are, by default, mapped
            into  the  process  address  space  instead  of being
            copied into the local cache.  This can result in bet-
            ter-than-usual performance, as available virtual mem-
            ory is normally much larger than the local cache, and
            page faults are faster than page copying on many sys-
            tems.  However, in the presence  of  limited  virtual
            memory  it  can cause resource starvation, and in the
            presence of large databases, it can result in immense
            process sizes.  If _m_p___m_m_a_p_s_i_z_e is non-zero, it speci-
            fies the maximum file size, in bytes, for a  file  to
            be   mapped  into  the  process  address  space.   By
            default, it is set to 10Mb.

       size_t mp_size;
            The suggested size  of  the  pool,  in  bytes.   This
            should  be the size of the normal working data set of
            the application, with some small amount of additional
            memory  for  unusual  situations.  (Note, the working
            set is not the same as the number  of  simultaneously
            referenced  pages, and should be quite a bit larger!)
            The default cache size is  128K  bytes  (16  8K  byte
            pages), and may not be less than 20K bytes.

       The _m_e_m_p___o_p_e_n function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _m_e_m_p___c_l_o_s_e
       The _m_e_m_p___c_l_o_s_e function closes the pool indicated  by  the
       DB_MPOOL pointer _m_p, as returned by _m_e_m_p___o_p_e_n.  This func-
       tion does not imply a call to _m_e_m_p___f_s_y_n_c, but does imply a
       call  to  _m_e_m_p___f_c_l_o_s_e  for any remaining open DB_MPOOLFILE
       pointers returned to this process by calls to  _m_e_m_p___f_o_p_e_n.

       In addition, if the _d_i_r argument to _m_e_m_p___o_p_e_n was NULL and
       _d_b_e_n_v  was  not  initialized  using  _d_b___a_p_p_i_n_i_t,  or   the
       DB_MPOOL_PRIVATE  flag was set, all files created for this
       shared region will be  removed,  as  if  _m_e_m_p___u_n_l_i_n_k  were
       called.

       When  multiple  threads are using the DB_MPOOL handle con-
       currently, only a single thread may  call  the  _m_e_m_p___c_l_o_s_e
       function.

       The  _m_e_m_p___c_l_o_s_e  function  returns  the  value of _e_r_r_n_o on
       failure and 0 on success.

  _m_e_m_p___f_o_p_e_n
       The _m_e_m_p___f_o_p_e_n function opens a file in the pool specified
       by the DB_MPOOL argument, copying the DB_MPOOLFILE pointer
       representing it into the  memory  location  referenced  by
       _m_p_f.

       The  _f_i_l_e  argument  is the name of the file to be opened.
       If _f_i_l_e is NULL, a private file is created that cannot  be
       shared  with  any other process (although it may be shared
       with other threads).

       The _f_l_a_g_s and _m_o_d_e arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.

       DB_NOMMAP
            Always copy this file into the local cache instead of
            mapping it into process memory (see  the  description
            of  the _m_p___m_m_a_p_s_i_z_e field of the DB_ENV structure for
            further information).

       DB_RDONLY
            Open any underlying  files  for  reading  only.   Any
            attempt  to  write  the file using the pool functions
            will fail, regardless of the  actual  permissions  of
            the file.

       All  files  created by the function _m_e_m_p___f_o_p_e_n are created
       with mode _m_o_d_e (as described in _c_h_m_o_d(2)) and modified  by
       the  process'  umask  value  at  the time of creation (see
       _u_m_a_s_k(2)).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

       The _p_a_g_e_s_i_z_e argument is the size, in bytes, of  the  unit
       of transfer between the application and the pool, although
       it is not necessarily the unit  of  transfer  between  the
       pool and the source file.

       Files  opened  in the pool may be further configured based
       on the _f_i_n_f_o_p argument to _m_e_m_p___f_o_p_e_n, which is  a  pointer
       to  a  structure  of  type  DB_MPOOL_FINFO  (typedef'd  in
       <db.h>).  No references to the _f_i_n_f_o_p structure are  main-
       tained  by  DB, so it may be discarded when the _m_e_m_p___f_o_p_e_n
       function returns.  In order to ensure  compatibility  with
       future  releases  of  DB, all fields of the DB_MPOOL_FINFO
       structure that are not explicitly set should  be  initial-
       ized to 0 before the first time the structure is used.  Do
       this by declaring the structure external or static, or  by
       calling the C library routine _b_z_e_r_o(3) or _m_e_m_s_e_t(3).

       The   fields  of  the  DB_MPOOL_FINFO  structure  used  by
       _m_e_m_p___f_o_p_e_n are described  below.  If _f_i_n_f_o_p is NULL or any
       of  its  fields  are  set to their default value, defaults
       appropriate for the system are used.

       int ftype;
            The _f_t_y_p_e field should be the same as a  _f_t_y_p_e  argu-
            ment  previously specified to the _m_e_m_p___r_e_g_i_s_t_e_r func-
            tion, unless no input or  output  processing  of  the
            file's  pages  are necessary, in which case it should
            be 0.  (See  the  description  of  the  _m_e_m_p___r_e_g_i_s_t_e_r
            function for more information.)

       DBT *pgcookie;
            The  _p_g_c_o_o_k_i_e  field contains the byte string that is
            passed to the _p_g_i_n and _p_g_o_u_t functions for this file,
            if any.  If no _p_g_i_n or _p_g_o_u_t functions are specified,
            the _p_g_c_o_o_k_i_e field should be NULL.  (See the descrip-
            tion  of the _m_e_m_p___r_e_g_i_s_t_e_r function for more informa-
            tion.)

       u_int8_t *fileid;
            The _f_i_l_e_i_d field is a unique identifier for the file.
            The mpool functions must be able to uniquely identify
            files in order that multiple processes sharing a file
            will correctly share its underlying pages.  Normally,
            the _f_i_l_e_i_d field should be NULL and the  mpool  func-
            tions  will  use  the file's device and inode numbers
            (see _s_t_a_t(2)) for this purpose.  On some filesystems,
            (e.g.,  FAT or NFS) file device and inode numbers are
            not necessarily unique across system reboots.  AAppppllii--
            ccaattiioonnss  wwaannttiinngg  ttoo  mmaaiinnttaaiinn aa sshhaarreedd mmeemmoorryy bbuuffffeerr
            ppooooll aaccrroossss ssyysstteemm rreebboooottss,, wwhheerree tthhee  ppooooll  ccoonnttaaiinnss
            ppaaggeess  ffrroomm  ffiilleess  ssttoorreedd  oonn ssuucchh ffiilleessyysstteemmss,, mmuusstt
            ssppeecciiffyy aa uunniiqquuee ffiillee iiddeennttiiffiieerr  ttoo  tthhee  _m_e_m_p___f_o_p_e_n
            call and each process opening or registering the file
            must provide the  same  unique  identifier.   If  the
            _f_i_l_e_i_d   field  is  non-NULL,  it  must  reference  a
            DB_FILE_ID_LEN (as defined in <db.h>) length array of
            bytes  that  will  be  used  to uniquely identify the
            file.  This should not be necessary for most applica-
            tions.  Specifically, it is not necessary if the mem-
            ory pool is re-instantiated after each system reboot,
            the  application  is  using  the  DB  access  methods
            instead of calling the pool functions explicitly,  or
            the  files  in the memory pool are stored on filesys-
            tems where the file device and inode numbers  do  not
            change across system reboots.
       int32_t lsn_offset;
            The _l_s_n___o_f_f_s_e_t field is the zero-based byte offset in
            the page of the page's log sequence number (LSN),  or
            -1  if no LSN offset is specified.  (See the descrip-
            tion of the _m_e_m_p___s_y_n_c function for more information.)

       u_int32_t clear_len;
            The _c_l_e_a_r___l_e_n field is the number of initial bytes in
            a page that should be set to zero when  the  page  is
            created   as  a  result  of  the  DB_MPOOL_CREATE  or
            DB_MPOOL_NEW flags being specified to _m_e_m_p___f_g_e_t.   If
            _f_i_n_f_o_p  is NULL or _c_l_e_a_r___l_e_n is 0, the entire page is
            cleared.

       The _m_e_m_p___f_o_p_e_n function returns  the  value  of  _e_r_r_n_o  on
       failure and 0 on success.

  _m_e_m_p___f_c_l_o_s_e
       The  _m_e_m_p___f_c_l_o_s_e function closes the source file indicated
       by the DB_MPOOLFILE pointer _m_p_f.  This function  does  not
       imply  a  call to _m_e_m_p___f_s_y_n_c, i.e. no pages are written to
       the source file as as a result of calling _m_e_m_p___f_c_l_o_s_e.

       In addition, if the _f_i_l_e argument to _m_e_m_p___f_o_p_e_n was  NULL,
       any underlying files created for this DB_MPOOLFILE will be
       removed.

       The _m_e_m_p___f_c_l_o_s_e function returns the  value  of  _e_r_r_n_o  on
       failure and 0 on success.

  _m_e_m_p___f_g_e_t
       The  _m_e_m_p___f_g_e_t  function copies a pointer to the page with
       the page number specified by  _p_g_n_o_a_d_d_r,  from  the  source
       file  specified  by the DB_MPOOLFILE pointer _m_p_f, into the
       memory location referenced by _p_a_g_e_p.  If the page does not
       exist or cannot be retrieved, _m_e_m_p___f_g_e_t will fail.

       The returned page is size_t type aligned.

       PPaaggee  nnuummbbeerrss bbeeggiinn aatt 00,, ee..gg..,, tthhee ffiirrsstt ppaaggee iinn tthhee ffiillee
       iiss ppaaggee nnuummbbeerr 00,, nnoott ppaaggee nnuummbbeerr 11..

       The _f_l_a_g_s argument is specified by oorr'ing together one  or
       more of the following values:

       DB_MPOOL_CREATE
            If  the specified page does not exist, create it.  In
            this  case,  the  _p_g_i_n  function,  if  specified,  is
            called.

       DB_MPOOL_LAST
            Return  the last page of the source file and copy its
            page number to the location referenced by _p_g_n_o_a_d_d_r.

       DB_MPOOL_NEW
            Create a new page in the file and copy its page  num-
            ber  to the location referenced by _p_g_n_o_a_d_d_r.  In this
            case, the _p_g_i_n function, if specified, is not called.

       The  DB_MPOOL_CREATE, DB_MPOOL_LAST and DB_MPOOL_NEW flags
       are mutually exclusive.

       Created pages have all their bytes set to 0, unless other-
       wise specified when the file was opened.

       All  pages  returned  by  _m_e_m_p___f_g_e_t will be retained (i.e.
       ``pinned'')  in  the  pool  until  a  subsequent  call  to
       _m_e_m_p___f_p_u_t.

       The _m_e_m_p___f_g_e_t function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _m_e_m_p___f_p_u_t
       The _m_e_m_p___f_p_u_t function indicates that the page  referenced
       by _p_g_a_d_d_r can be evicted from the pool.  _P_g_a_d_d_r must be an
       address previously returned by _m_e_m_p___f_g_e_t.

       The _f_l_a_g_s argument is specified by oorr'ing together one  or
       more of the following values:

       DB_MPOOL_CLEAN
            Clear  any  previously  set  modification information
            (i.e., don't bother writing  the  page  back  to  the
            source file).

       DB_MPOOL_DIRTY
            The page has been modified and must be written to the
            source file before being evicted from the pool.

       DB_MPOOL_DISCARD
            The page is unlikely to be useful in the near future,
            and  should  be  discarded  before other pages in the
            pool.

       The DB_MPOOL_CLEAN and DB_MPOOL_DIRTY flags  are  mutually
       exclusive.

       The _m_e_m_p___f_p_u_t function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _m_e_m_p___f_s_e_t
       The _m_e_m_p___f_s_e_t function sets the flags associated with  the
       page  referenced  by  _p_g_a_d_d_r without unpinning it from the
       pool.  _P_g_a_d_d_r must be an address  previously  returned  by
       _m_e_m_p___f_g_e_t.   The  _f_l_a_g_s argument to _m_e_m_p___f_s_e_t is specified
       by oorr'ing together one or more of the values specified  as
       flags for the _m_e_m_p___f_p_u_t call.


       The _m_e_m_p___f_s_e_t function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

  _m_e_m_p___f_s_y_n_c
       The _m_e_m_p___f_s_y_n_c function writes all pages  associated  with
       the DB_MPOOLFILE pointer _m_p_f, that were marked as modified
       using _m_e_m_p___f_p_u_t or _m_e_m_p___f_s_e_t, back to the source file.  If
       any of the modified pages are also pinned (i.e., currently
       referenced by this or  another  process)  _m_e_m_p___f_s_y_n_c  will
       ignore them.

       The  _m_e_m_p___f_s_y_n_c  function  returns  the  value of _e_r_r_n_o on
       failure, 0 on success, and  DB_INCOMPLETE  if  there  were
       pages  which were modified but which _m_e_m_p___f_s_y_n_c was unable
       to write.


  _m_e_m_p___u_n_l_i_n_k
       The _m_e_m_p___u_n_l_i_n_k function destroys the memory pool  identi-
       fied  by  the  directory  _d_i_r,  removing all files used to
       implement the memory pool.   (The  directory  _d_i_r  is  not
       removed.)    If  there  are  processes  that  have  called
       _m_e_m_p___o_p_e_n without calling _m_e_m_p___c_l_o_s_e (i.e., there are pro-
       cesses  currently using the memory pool), _m_e_m_p___u_n_l_i_n_k will
       fail without further action, unless the force flag is set,
       in  which case _m_e_m_p___u_n_l_i_n_k will attempt to remove the mem-
       ory pool files regardless of any processes still using the
       memory pool.

       The  result  of  attempting to forcibly destroy the region
       when a process has the region open is  unspecified.   Pro-
       cesses  using a shared memory region maintain an open file
       descriptor for it.  On UNIX systems,  the  region  removal
       should  succeed and processes that have already joined the
       region should  continue  to  run  in  the  region  without
       change,  however  processes  attempting to join the memory
       pool will either fail or attempt to create a  new  region.
       On  other  systems,  e.g., WNT, where the _u_n_l_i_n_k(2) system
       call will fail if any process has an open file  descriptor
       for the file, the region removal will fail.

       In  the  case  of catastrophic or system failure, database
       recovery must  be  performed  (see  _d_b___r_e_c_o_v_e_r(1)  or  the
       DB_RECOVER  and  DB_RECOVER_FATAL flags to _d_b___a_p_p_i_n_i_t(3)).
       Alternatively, if recovery  is  not  required  because  no
       database state is maintained across failures, it is possi-
       ble to clean up a memory pool by removing all of the files
       in  the  directory specified to the _m_e_m_p___o_p_e_n function, as
       memory pool files are never created in any directory other
       than  the one specified to _m_e_m_p___o_p_e_n.  Note, however, that
       this has the potential to  remove  files  created  by  the
       other DB subsystems in this database environment.

       The  _m_e_m_p___u_n_l_i_n_k  function  returns  the value of _e_r_r_n_o on
       failure and 0 on success.

  _m_e_m_p___r_e_g_i_s_t_e_r
       The _m_e_m_p___r_e_g_i_s_t_e_r function registers page-in and  page-out
       functions for files of type _f_t_y_p_e in the specified pool.

       If the _p_g_i_n function is non-NULL, it is called each time a
       page is read into the memory pool  from  a  file  of  type
       _f_t_y_p_e,  or a page is created for a file of type _f_t_y_p_e (see
       the DB_MPOOL_CREATE flag for the _m_e_m_p___f_g_e_t function).   If
       the  _p_g_o_u_t  function is non-NULL, it is called each time a
       page is written to a file of type _f_t_y_p_e.

       Both the _p_g_i_n and _p_g_o_u_t functions are called with the page
       number,  a  pointer to the page being read or written, and
       any argument _p_g_c_o_o_k_i_e that was specified to the _m_e_m_p___f_o_p_e_n
       function  when  the  file  was opened.  The _p_g_i_n and _p_g_o_u_t
       functions should return 0 on success,  and  an  applicable
       non-zero  _e_r_r_n_o  value  on  failure,  in  which  case  the
       _d_b___m_p_o_o_l function calling it  will  also  fail,  returning
       that _e_r_r_n_o value.

       The  purpose  of  the _m_e_m_p___r_e_g_i_s_t_e_r function is to support
       processing when pages are entered into, or  flushed  from,
       the pool.  A file type must be specified to make it possi-
       ble for unrelated threads or processes, that are sharing a
       pool, to evict each other's pages from the pool.  Applica-
       tions should call  _m_e_m_p___r_e_g_i_s_t_e_r,  during  initialization,
       for each type of file requiring input or output processing
       that will be sharing the underlying pool.  (No registry is
       necessary  for  the  standard  access method types, btree,
       hash and recno, as _d_b___o_p_e_n(3) registers them  separately.)

       If  a  thread or process does not call _m_e_m_p___r_e_g_i_s_t_e_r for a
       file type, it is impossible for it to evict pages for  any
       file  requiring  input or output processing from the pool.
       For this reason, _m_e_m_p___r_e_g_i_s_t_e_r should always be called  by
       each  application  sharing  a  pool  for each type of file
       included in the pool, regardless of  whether  or  not  the
       application itself uses files of that type.

       There  are  no  standard values for _f_t_y_p_e, _p_g_i_n, _p_g_o_u_t and
       _p_g_c_o_o_k_i_e, except that the _f_t_y_p_e value for a file must be a
       non-zero positive number, as negative numbers are reserved
       for internal use by the  DB  library.   For  this  reason,
       applications  sharing  a pool must coordinate their values
       amongst themselves.

       The _m_e_m_p___r_e_g_i_s_t_e_r function returns the value of  _e_r_r_n_o  on
       failure and 0 on success.

  _m_e_m_p___t_r_i_c_k_l_e
       The  _m_e_m_p___t_r_i_c_k_l_e  function ensures that at least _p_c_t per-
       cent of the pages in the shared memory pool are  clean  by
       writing  dirty  pages  to  their  backing  files.   If the
       _n_w_r_o_t_e_p argument is non-NULL, the  number  of  pages  that
       were  written  to reach the correct percentage is returned
       in the memory location it references.

       The purpose of the _m_e_m_p___t_r_i_c_k_l_e function is  to  enable  a
       memory pool manager to ensure that a page is always avail-
       able for reading in new information without having to wait
       for a write.

       The  _m_e_m_p___t_r_i_c_k_l_e  function  returns the value of _e_r_r_n_o on
       failure and 0 on success.

  _m_e_m_p___s_y_n_c
       The _m_e_m_p___s_y_n_c function ensures that all the modified pages
       in the pool with log sequence numbers (LSNs) less than the
       _l_s_n argument are written to disk.

       The _m_e_m_p___s_y_n_c function returns the value of _e_r_r_n_o on fail-
       ure,  0  on success, and DB_INCOMPLETE if there were pages
       which need to be written but which _m_e_m_p___s_y_n_c was unable to
       write immediately.  In addition, if _m_e_m_p___s_y_n_c returns suc-
       cess, the value  of  _l_s_n  will  be  overwritten  with  the
       largest  LSN  from any page which was written by _m_e_m_p___s_y_n_c
       to satisfy this request.

       The purpose of the  _m_e_m_p___s_y_n_c  function  is  to  enable  a
       transaction  manager  to  ensure, as part of a checkpoint,
       that all pages modified by a certain time have been  writ-
       ten  to  disk.   Pages in the pool which cannot be written
       back to disk immediately (e.g., are currently pinned)  are
       written  to  disk as soon as it is possible to do so.  The
       expected behavior of the transaction manager  is  to  call
       the  _m_e_m_p___s_y_n_c  function and then, if the return indicates
       that some pages could not be written immediately, to  wait
       briefly  and  retry  again  with  the  same  LSN until the
       _m_e_m_p___s_y_n_c function returns that all pages have been  writ-
       ten.

       To  support  the  _m_e_m_p___s_y_n_c functionality, it is necessary
       that the pool functions know the location of  the  LSN  on
       the  page  for  each  file  type.  This location should be
       specified when the file is  opened  using  the  _m_e_m_p___f_o_p_e_n
       function.   (Note,  it  is  not  required  that the LSN be
       aligned on the page in any way.)

  _m_e_m_p___s_t_a_t
       The _m_e_m_p___s_t_a_t function creates statistical structures  and
       copies  pointers  to them into user-specified memory loca-
       tions.  The statistics include the number of files partic-
       ipating  in  the  pool,  the active pages in the pool, and
       information as to how effective the cache has been.

       Statistical structures are created  in  allocated  memory.

       If  _d_b___m_a_l_l_o_c  is  non-NULL,  it is called to allocate the
       memory, otherwise, the library function _m_a_l_l_o_c(3) is used.
       The  function _d_b___m_a_l_l_o_c must match the calling conventions
       of the _m_a_l_l_o_c(3) library routine.  Regardless, the  caller
       is  responsible  for deallocating the returned memory.  To
       deallocate the returned memory, free each returned  memory
       pointer;  pointers  inside  the  memory  do not need to be
       individually freed.

       If _g_s_p is non-NULL, the global statistics for  the  memory
       pool _m_p are copied into the memory location it references.
       The global statistics are stored in a  structure  of  type
       DB_MPOOL_STAT (typedef'd in <db.h>).

       The following DB_MPOOL_STAT fields will be filled in:

       u_int32_t st_refcnt;
            The number of references to the region.
       u_int32_t st_regsize;
            The size of the region.
       size_t st_cachesize;
            Cache size in bytes.
       u_int32_t st_cache_hit;
            Requested pages found in the cache.
       u_int32_t st_cache_miss;
            Requested pages not found in the cache.
       u_int32_t st_map;
            Requested  pages  mapped  into  the  process' address
            space  (there  is  no  available  information  as  to
            whether or not this request caused disk I/O, although
            examining the application  page  fault  rate  may  be
            helpful).
       u_int32_t st_page_create;
            Pages created in the cache.
       u_int32_t st_page_in;
            Pages read into the cache.
       u_int32_t st_page_out;
            Pages written from the cache to the backing file.
       u_int32_t st_ro_evict;
            Clean pages forced from the cache.
       u_int32_t st_rw_evict;
            Dirty pages forced from the cache.
       u_int32_t st_hash_buckets;
            Number of hash buckets in buffer hash table.
       u_int32_t st_hash_searches;
            Total number of buffer hash table lookups.
       u_int32_t st_hash_longest;
            The  longest  chain  ever  encountered in buffer hash
            table lookups.
       u_int32_t st_hash_examined;
            Total number of hash elements traversed  during  hash
            table lookups.
       u_int32_t st_page_clean;
            Clean pages currently in the cache.
       u_int32_t st_page_dirty;
            Dirty pages currently in the cache.
       u_int32_t st_page_trickle;
            Dirty pages written using the _m_e_m_p___t_r_i_c_k_l_e interface.
       u_int32_t st_region_wait;
            The number of times that  a  thread  of  control  was
            forced to wait before obtaining the region lock.
       u_int32_t st_region_nowait;
            The number of times that a thread of control was able
            to obtain the region lock without waiting.

       If _f_s_p is non-NULL, a pointer to a  NULL-terminated  vari-
       able  length  array of statistics for individual files, in
       the memory pool _m_p, is copied into the memory location  it
       references.  If no individual files currently exist in the
       memory pool, _f_s_p will be set to NULL.

       The per-file statistics are stored in structures  of  type
       DB_MPOOL_FSTAT   (typedef'd  in  <db.h>).   The  following
       DB_MPOOL_FSTAT fields will be filled in for each  file  in
       the pool, i.e., each element of the array:

       char *file_name;
            The name of the file.
       size_t st_pagesize;
            Page size in bytes.
       u_int32_t st_cache_hit;
            Requested pages found in the cache.
       u_int32_t st_cache_miss;
            Requested pages not found in the cache.
       u_int32_t st_map;
            Requested  pages  mapped  into  the  process' address
            space.
       u_int32_t st_page_create;
            Pages created in the cache.
       u_int32_t st_page_in;
            Pages read into the cache.
       u_int32_t st_page_out;
            Pages written from the cache to the backing file.

       The _m_e_m_p___s_t_a_t function returns the value of _e_r_r_n_o on fail-
       ure and 0 on success.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The  following  environment variables affect the execution
       of _d_b___m_p_o_o_l:

       DB_HOME
            If the _d_b_e_n_v argument to  _m_e_m_p___o_p_e_n  was  initialized
            using  _d_b___a_p_p_i_n_i_t,  the  environment variable DB_HOME
            may be used as the path of the database home for  the
            interpretation  of  the _d_i_r argument to _m_e_m_p___o_p_e_n, as
            described in _d_b___a_p_p_i_n_i_t(3).

       TMPDIR
            If the _d_b_e_n_v argument to _m_e_m_p___o_p_e_n was  NULL  or  not
            initialized  using  _d_b___a_p_p_i_n_i_t, the environment vari-
            able TMPDIR may be used as the directory in which  to
            create the memory pool, as described in the _m_e_m_p___o_p_e_n
            section above.

EERRRROORRSS
       The _m_e_m_p___o_p_e_n function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: DBmemp->pgin(3), DBmemp->pgout(3), close(2),
       db_version(3), fcntl(2), fflush(3), fsync(2), log_com-
       pare(3), log_flush(3), lseek(2), malloc(3), memcmp(3),
       memcpy(3), memp_close(3), memp_unlink(3), memset(3),
       mmap(2), munmap(2), open(2), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), time(3), unlink(2), and write(2).

       In addition, the _m_e_m_p___o_p_e_n function may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            The  shared memory region was locked and (repeatedly)
            unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_THREAD flag was specified  and  spinlocks  are
            not implemented for this architecture.

            A   NULL   pathname   was   specified   without   the
            DB_MPOOL_PRIVATE flag.

            The specified cache size was impossibly small.

       The _m_e_m_p___c_l_o_s_e function may fail and return _e_r_r_n_o for  any
       of  the  errors specified for the following DB and library
       functions: close(2), fcntl(2), fflush(3), memp_fclose(3),
       munmap(2), and strerror(3).

       The  _m_e_m_p___f_o_p_e_n function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: DBmemp->pgin(3), DBmemp->pgout(3), close(2),
       fcntl(2), fflush(3), fsync(2), log_compare(3),
       log_flush(3), lseek(2), malloc(3), memcmp(3), memcpy(3),
       memset(3), mmap(2), open(2), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), time(3), unlink(2), and write(2).

       In addition, the _m_e_m_p___f_o_p_e_n function may fail  and  return
       _e_r_r_n_o for the following conditions:


       [EINVAL]
            An invalid flag value or parameter was specified.

            The  file has already been entered into the pool, and
            the _p_a_g_e_s_i_z_e value is not the same as when  the  file
            was  entered into the pool, or the length of the file
            is not zero or a multiple of the _p_a_g_e_s_i_z_e.

            The DB_RDONLY flag was  specified  for  an  in-memory
            pool.

       The _m_e_m_p___f_c_l_o_s_e function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: close(2), fcntl(2), fflush(3), munmap(2), and
       strerror(3).

       The _m_e_m_p___f_g_e_t function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: DBmemp->pgin(3), DBmemp->pgout(3), close(2),
       fcntl(2), fflush(3), fsync(2), log_compare(3),
       log_flush(3), lseek(2), malloc(3), memcmp(3), memcpy(3),
       memset(3), mmap(2), open(2), read(2), sigfillset(3), sig-
       procmask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), time(3), unlink(2), and write(2).

       In  addition,  the  _m_e_m_p___f_g_e_t function may fail and return
       _e_r_r_n_o for the following conditions:

       [EAGAIN]
            The  page  reference  count  has  overflowed.   (This
            should  never  happen  unless  there's  a  bug in the
            application.)

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_MPOOL_NEW flag was set and the source file was
            not opened for writing.

            The requested page does not exist and DB_MPOOL_CREATE
            was not set.

            More than one of DB_MPOOL_CREATE,  DB_MPOOL_LAST  and
            DB_MPOOL_NEW was set.

       [ENOMEM]
            The  cache  is full and no more pages will fit in the
            pool.

       The _m_e_m_p___f_p_u_t function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: DBmemp->pgin(3), DBmemp->pgout(3), close(2),
       fcntl(2), fflush(3), fsync(2), log_compare(3),
       log_flush(3), lseek(2), malloc(3), memcmp(3), memcpy(3),
       memset(3), mmap(2), open(2), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), time(3), unlink(2), and write(2).

       In  addition,  the  _m_e_m_p___f_p_u_t function may fail and return
       _e_r_r_n_o for the following conditions:

       [EACCES]
            The DB_MPOOL_DIRTY flag was set and the  source  file
            was not opened for writing.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The  _p_g_a_d_d_r  parameter  does  not  reference  a  page
            returned by _m_e_m_p___f_g_e_t.

            More than one of  DB_MPOOL_CLEAN  and  DB_MPOOL_DIRTY
            was set.

       The  _m_e_m_p___f_s_e_t  function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: fcntl(2), and fflush(3).

       In  addition,  the  _m_e_m_p___f_s_e_t function may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _m_e_m_p___f_s_y_n_c function may fail and return _e_r_r_n_o for  any
       of  the  errors specified for the following DB and library
       functions: DBmemp->pgin(3), DBmemp->pgout(3), close(2),
       fcntl(2), fflush(3), fsync(2), log_compare(3),
       log_flush(3), lseek(2), malloc(3), memcpy(3), memset(3),
       open(2), qsort(3), realloc(3), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), unlink(2), and write(2).

       The _m_e_m_p___u_n_l_i_n_k function may fail and return _e_r_r_n_o for any
       of the errors specified for the following DB  and  library
       functions: close(2), fcntl(2), fflush(3), malloc(3), mem-
       cpy(3), memset(3), mmap(2), munmap(2), open(2), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3), strlen(3), and unlink(2).

       In addition, the _m_e_m_p___u_n_l_i_n_k function may fail and  return
       _e_r_r_n_o for the following conditions:

       [EBUSY]
            The  shared  memory  region  was in use and the force
            flag was not set.

       The _m_e_m_p___r_e_g_i_s_t_e_r function may fail and return  _e_r_r_n_o  for
       any  of  the  errors  specified  for  the following DB and
       library functions: fcntl(2), and malloc(3).

       The _m_e_m_p___t_r_i_c_k_l_e function may fail and  return  _e_r_r_n_o  for
       any  of  the  errors  specified  for  the following DB and
       library functions: DBmemp->pgin(3), DBmemp->pgout(3),
       close(2), fcntl(2), fflush(3), fsync(2), log_compare(3),
       log_flush(3), lseek(2), malloc(3), memcmp(3), memcpy(3),
       memset(3), mmap(2), open(2), sigfillset(3), sigproc-
       mask(2), stat(2), strcpy(3), strdup(3), strerror(3),
       strlen(3), time(3), unlink(2), and write(2).

       In addition, the _m_e_m_p___t_r_i_c_k_l_e function may fail and return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _m_e_m_p___s_y_n_c function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: DBmemp->pgin(3), DBmemp->pgout(3), close(2),
       fcntl(2), fflush(3), fsync(2), log_compare(3),
       log_flush(3), lseek(2), malloc(3), memcmp(3), memcpy(3),
       memset(3), mmap(2), open(2), qsort(3), realloc(3), sig-
       fillset(3), sigprocmask(2), stat(2), strcpy(3), strdup(3),
       strerror(3),  strlen(3), time(3), unlink(2), and write(2).

       In addition, the _m_e_m_p___s_y_n_c function may  fail  and  return
       _e_r_r_n_o for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The  _m_e_m_p___s_y_n_c  function  was  called without logging
            having been initialized in the environment.

       The _m_e_m_p___s_t_a_t function may fail and return _e_r_r_n_o  for  any
       of  the  errors specified for the following DB and library
       functions: fcntl(2), malloc(3), memcpy(3), and  strlen(3).

SSEEEE AALLSSOO
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___a_p_p_i_n_i_t(3), _d_b___c_u_r_s_o_r(3), _d_b___d_b_m(3), _d_b___i_n_t_e_r_n_a_l(3),
       _d_b___l_o_c_k(3), _d_b___l_o_g(3), _d_b___m_p_o_o_l(3), _d_b___o_p_e_n(3), _d_b___t_h_r_e_a_d(3),
       _d_b___t_x_n(3)
