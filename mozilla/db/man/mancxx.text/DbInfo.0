

NNAAMMEE
       DbInfo - informational parameters for database open

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb__ccxxxx..hh>>

       DDbbIInnffoo::::DDbbIInnffoo(());;
       DDbbIInnffoo::::~~DDbbIInnffoo(());;
       DDbbIInnffoo::::DDbbIInnffoo((ccoonnsstt DDbbIInnffoo &&));;
       DDbbIInnffoo::::DDbbIInnffoo &&ooppeerraattoorr == ((ccoonnsstt DDbbIInnffoo &&));;

       iinntt DDbbIInnffoo::::ggeett__lloorrddeerr(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__lloorrddeerr((iinntt));;

       ssiizzee__tt DDbbIInnffoo::::ggeett__ccaacchheessiizzee(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__ccaacchheessiizzee((ssiizzee__tt));;

       ssiizzee__tt DDbbIInnffoo::::ggeett__ppaaggeessiizzee(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__ppaaggeessiizzee((ssiizzee__tt));;

       ttyyppeeddeeff vvooiidd **((**ddbb__mmaalllloocc__ffccnn))((ssiizzee__tt));;
       DDbbIInnffoo::::ddbb__mmaalllloocc__ffccnn DDbbIInnffoo::::ggeett__mmaalllloocc(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__mmaalllloocc((ddbb__mmaalllloocc__ffccnn));;

       uu__iinntt3322__tt DDbbIInnffoo::::ggeett__bbtt__mmiinnkkeeyy(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__bbtt__mmiinnkkeeyy((uu__iinntt3322__tt));;

       ttyyppeeddeeff iinntt ((**bbtt__ccoommppaarree__ffccnn))((ccoonnsstt DDBBTT **,, ccoonnsstt DDBBTT **));;
       bbtt__ccoommppaarree__ffccnn DDbbIInnffoo::::ggeett__bbtt__ccoommppaarree(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__bbtt__ccoommppaarree((bbtt__ccoommppaarree__ffccnn));;

       ttyyppeeddeeff ssiizzee__tt ((**bbtt__pprreeffiixx__ffccnn))((ccoonnsstt DDBBTT **,, ccoonnsstt DDBBTT **));;
       bbtt__pprreeffiixx__ffccnn DDbbIInnffoo::::ggeett__bbtt__pprreeffiixx(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__bbtt__pprreeffiixx((bbtt__pprreeffiixx__ffccnn));;

       uu__iinntt3322__tt DDbbIInnffoo::::ggeett__hh__ffffaaccttoorr(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__hh__ffffaaccttoorr((uu__iinntt3322__tt));;

       uu__iinntt3322__tt DDbbIInnffoo::::ggeett__hh__nneelleemm(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__hh__nneelleemm((uu__iinntt3322__tt));;

       ttyyppeeddeeff uu__iinntt3322__tt ((**hh__hhaasshh__ffccnn))((ccoonnsstt vvooiidd **,, uu__iinntt3322__tt));;
       hh__hhaasshh__ffccnn DDbbIInnffoo::::ggeett__hh__hhaasshh(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__hh__hhaasshh((hh__hhaasshh__ffccnn));;

       iinntt DDbbIInnffoo::::ggeett__rree__ppaadd(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__rree__ppaadd((iinntt));;

       iinntt DDbbIInnffoo::::ggeett__rree__ddeelliimm(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__rree__ddeelliimm((iinntt));;

       uu__iinntt3322__tt DDbbIInnffoo::::ggeett__rree__lleenn(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__rree__lleenn((uu__iinntt3322__tt));;

       cchhaarr DDbbIInnffoo::::**ggeett__rree__ssoouurrccee(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__rree__ssoouurrccee((cchhaarr **));;

       uu__iinntt3322__tt DDbbIInnffoo::::ggeett__ffllaaggss(()) ccoonnsstt;;
       vvooiidd DDbbIInnffoo::::sseett__ffllaaggss((uu__iinntt3322__tt));;

DDEESSCCRRIIPPTTIIOONN
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see _d_b___i_n_t_r_o(3).

       This manual page describes the  DbInfo  class.   A  DbInfo
       object  is  used  in  conjunction with the _D_b_:_:_o_p_e_n method
       (see _D_b(3)) to specify  particular  configuration  options
       for  the open.  The DbInfo class provides simple access to
       an underlying data structure, whose elements can be  exam-
       ined  or  changed  using  the  _s_e_t__  or _g_e_t__ methods.  The
       remainder of the manual  page  refers  to  these  accesses
       using  the  underlying  name,  e.g.,  _c_a_c_h_e_s_i_z_e instead of
       _g_e_t___c_a_c_h_e_s_i_z_e and _s_e_t___c_a_c_h_e_s_i_z_e.  The default  constructor
       sets  all  elements  of  the underlying structure to zero.
       Some of the fields are specific to a type of  file  format
       (one  of  btree, hashed and recno) and are thus named with
       an underscore separated string, ``bt'', ``h'' and  ``re'',
       respectively.   For example, the method _s_e_t___b_t___m_i_n_k_e_y sets
       the underlying _b_t___m_i_n_k_e_y field, and  this  field  is  only
       used when opening a btree file.

       The  fields  that  are  common  to  all access methods are
       listed here; those specific to an individual access method
       are described below.  No reference to the DbInfo object is
       maintained by Db, so it is possible to discard it as  soon
       as the _D_b_:_:_o_p_e_n call returns.

       If  possible, defaults appropriate for the system are used
       for the DbInfo fields if _d_b_i_n_f_o is NULL or any  fields  of
       the  DbInfo  object are not explicitly set.  The following
       DbInfo fields may be initialized before calling _D_b_:_:_o_p_e_n:

       size_t cachesize;
            A suggested maximum size of the memory pool cache, in
            bytes.  If _c_a_c_h_e_s_i_z_e is not explicitly set, an appro-
            priate default is used.  It is an  error  to  specify
            both the _m_p___i_n_f_o field and a non-zero _d_b___c_a_c_h_e_s_i_z_e.

            NNoottee,, tthhee mmiinniimmuumm nnuummbbeerr ooff ppaaggeess iinn tthhee ccaacchhee sshhoouulldd
            bbee nnoo lleessss tthhaann 1100,, aanndd tthhee aacccceessss mmeetthhooddss wwiillll  ffaaiill
            iiff  aann  iinnssuuffffiicciieennttllyy  llaarrggee ccaacchhee iiss ssppeecciiffiieedd..  In
            addition, for applications that exhibit strong local-
            ity  in  their  data  access patterns, increasing the
            size  of  the   cache   can   significantly   improve
            application performance.

       int lorder;
            The  byte  order  for integers in the stored database
            metadata.  The number should represent the  order  as
            an integer, for example, big endian order is the num-
            ber 4,321, and little  endian  order  is  the  number
            1,234.   If  _l_o_r_d_e_r  is  not explicitly set, the host
            order of the machine where the Db  library  was  com-
            piled is used.

            The  value of _l_o_r_d_e_r is ignored except when databases
            are being created.  If a database already exists, the
            byte  order  it  uses  is determined when the file is
            read.

            TThhee aacccceessss mmeetthhooddss pprroovviiddee nnoo  gguuaarraanntteeeess  aabboouutt  tthhee
            bbyyttee  oorrddeerriinngg  ooff tthhee aapppplliiccaattiioonn ddaattaa ssttoorreedd iinn tthhee
            ddaattaabbaassee,, aanndd aapppplliiccaattiioonnss aarree rreessppoonnssiibbllee ffoorr  mmaaiinn--
            ttaaiinniinngg aannyy nneecceessssaarryy oorrddeerriinngg..

       size_t pagesize;
            The  size  of  the  pages  used  to hold items in the
            database, in bytes.  The minimum  page  size  is  512
            bytes  and  the  maximum  page size is 64K bytes.  If
            _p_a_g_e_s_i_z_e is  not  explicitly  set,  a  page  size  is
            selected based on the underlying filesystem I/O block
            size.  The selected size has a  lower  limit  of  512
            bytes and an upper limit of 16K bytes.

       void *(*malloc)(size_t);
            The  flag  DB_DBT_MALLOC,  when  specified in the Dbt
            object, will cause the Db library to allocate  memory
            which  then becomes the responsibility of the calling
            application.  See _D_b_t(3) for more information.

            On systems where there may be multiple  library  ver-
            sions  of malloc (notably Windows NT), specifying the
            DB_DBT_MALLOC flag will fail because the  Db  library
            will  allocate  memory from a different heap than the
            application will use to free it.  To avoid this prob-
            lem,  the  _m_a_l_l_o_c  function should be set to point to
            the application's allocation routine.  If  _m_a_l_l_o_c  is
            not  explicitly  set, it will be used to allocate the
            memory returned when the DB_DBT_MALLOC flag  is  set.
            The  _m_a_l_l_o_c method must match the calling conventions
            of the _m_a_l_l_o_c(3) library routine.

BBTTRREEEE
       The btree data structure is a sorted, balanced tree struc-
       ture  storing associated key/data pairs.  Searches, inser-
       tions, and deletions in the btree will all complete  in  O
       (lg  base  N) where base is the average number of keys per
       page.  Often, inserting ordered data into  btrees  results
       in pages that are half-full.  This implementation has been
       modified to make ordered (or  inverse  ordered)  insertion
       the best case, resulting in nearly perfect page space uti-
       lization.

       Space freed by deleting key/data pairs from  the  database
       is  never  reclaimed  from  the filesystem, although it is
       reused where possible.  This means that the btree  storage
       structure  is  grow-only.   If  sufficiently many keys are
       deleted from a tree that shrinking the underlying database
       file  is desirable, this can be accomplished by creating a
       new tree from a scan of the existing one.

       The following additional fields and flags may be  initial-
       ized  in  the  DbInfo object before calling _D_b_:_:_o_p_e_n, when
       using the btree access method:

       int (*bt_compare)(const Dbt *, const Dbt *);
            The _b_t___c_o_m_p_a_r_e function is the key comparison method.
            It  must  return  an  integer less than, equal to, or
            greater than zero if the first key argument  is  con-
            sidered  to  be  respectively less than, equal to, or
            greater than the second key argument.  The same  com-
            parison  method  must  be  used on a given tree every
            time it is opened.

            The _d_a_t_a and _s_i_z_e fields of  the  DBT  are  the  only
            fields that may be used for the purposes of this com-
            parison.

            If _b_t___c_o_m_p_a_r_e is NULL, the keys  are  compared  lexi-
            cally,  with  shorter  keys  collating  before longer
            keys.

       u_int32_t bt_minkey;
            The minimum number of keys that will be stored on any
            single  page.   This value is used to determine which
            keys will be stored on overflow pages, i.e. if a  key
            or  data  item is larger than the pagesize divided by
            the _b_t___m_i_n_k_e_y value, it will be  stored  on  overflow
            pages  instead  of in the page itself.  The _b_t___m_i_n_k_e_y
            value specified must be at least 2; if  _b_t___m_i_n_k_e_y  is
            not explicitly set, a value of 2 is used.

       size_t (*bt_prefix)(const Dbt *, const Dbt *);
            The  _b_t___p_r_e_f_i_x  function  is  the  prefix  comparison
            method.  If specified, this method  must  return  the
            number  of  bytes of the second key argument that are
            necessary to determine that it is  greater  than  the
            first  key  argument.  If the keys are equal, the key
            length should be returned.

            The _d_a_t_a and _s_i_z_e fields of  the  DBT  are  the  only
            fields  that  may  be  used  for the purposes of this
            comparison.

            This is used to compress the keys stored on the btree
            internal  pages.   The  usefulness  of  this  is data
            dependent, but in some data sets can produce signifi-
            cantly  reduced  tree  sizes  and  search  times.  If
            _b_t___p_r_e_f_i_x is not explicitly set,  and  no  comparison
            method  is  specified,  a  default lexical comparison
            method is used.  If _b_t___p_r_e_f_i_x is NULL and a  compari-
            son  method  is  specified,  no  prefix comparison is
            done.

       unsigned long flags;
            The following additional flags may be specified:

            DB_DUP
                 Permit duplicate keys in the tree,  i.e.  inser-
                 tion  when  the  key  of the key/data pair being
                 inserted already exists in the tree will be suc-
                 cessful.  The ordering of duplicates in the tree
                 is determined by the order of insertion,  unless
                 the  ordering is otherwise specified by use of a
                 cursor (see _D_b_c(3) for more information.)  It is
                 an error to specify both DB_DUP and DB_RECNUM.


            DB_RECNUM
                 Support  retrieval from btrees using record num-
                 bers.    For   more   information,    see    the
                 DB_GET_RECNO flag to the _d_b_-_>_g_e_t method (below),
                 and the cursor _D_b_c_:_:_g_e_t method (in _D_b_c(3)).

                 Logical record numbers in btrees are mutable  in
                 the  face  of record insertion or deletion.  See
                 the DB_RENUMBER flag in the RECNO section  below
                 for further discussion.

                 Maintaining  record counts within a btree intro-
                 duces a serious point of contention, namely  the
                 page  locations  where  the  record  counts  are
                 stored.  In addition, the entire  tree  must  be
                 locked  during  both  insertions  and deletions,
                 effectively single-threading the tree for  those
                 operations.   Specifying DB_RECNUM can result in
                 serious performance degradation for some  appli-
                 cations and data sets.

                 It  is  an  error  to  specify  both  DB_DUP and
                 DB_RECNUM.

HHAASSHH
       The hash data structure is an extensible, dynamic  hashing
       scheme.   Backward  compatible interfaces to the functions
       described in _d_b_m(3), _n_d_b_m(3) and _h_s_e_a_r_c_h(3) are  provided,
       however  these interfaces are not compatible with previous
       file formats.

       The following additional fields and flags may be  initial-
       ized  in  the  DbInfo object before calling _D_b_:_:_o_p_e_n, when
       using the hash access method:


       u_int32_t h_ffactor;
            The desired density within the hash table.  It is  an
            approximation  of the number of keys allowed to accu-
            mulate in any one bucket, determining when  the  hash
            table  grows  or  shrinks.   The  default value is 0,
            indicating that the  fill  factor  will  be  selected
            dynamically as pages are filled.

       u_int32_t (*h_hash)(const void *, u_int32_t);
            The  _h___h_a_s_h  field  is a user defined hash method; if
            _h___h_a_s_h is NULL, a default hash method is used.  Since
            no  hash method performs equally well on all possible
            data, the user may find that the built-in hash method
            performs  poorly  with  a  particular data set.  User
            specified hash functions must take  a  pointer  to  a
            byte  string  and  a length as arguments and return a
            u_int32_t value.

            If a hash method is specified, _h_a_s_h___o_p_e_n will attempt
            to determine if the hash method specified is the same
            as the one with which the database was  created,  and
            will fail if it detects that it is not.

       u_int32_t h_nelem;
            An  estimate of the final size of the hash table.  If
            not set or set  too  low,  hash  tables  will  expand
            gracefully  as  keys  are  entered, although a slight
            performance degradation may be noticed.  The  default
            value is 1.

       unsigned long flags;
            The  following  additional  flags may be specified by
            oorr'ing together one or more of the following values:

            DB_DUP
                 Permit duplicate keys in the tree,  i.e.  inser-
                 tion  when  the  key  of the key/data pair being
                 inserted already exists in the tree will be suc-
                 cessful.  The ordering of duplicates in the tree
                 is determined by the order of insertion,  unless
                 the  ordering is otherwise specified by use of a
                 cursor (see _D_b_c(3) for more information.)

RREECCNNOO
       The recno access method provides  support  for  fixed  and
       variable  length records, optionally backed by a flat text
       (byte  stream)  file.   Both  fixed  and  variable  length
       records are accessed by their logical record number.

       It is valid to create a record whose record number is more
       than one greater than the last  record  currently  in  the
       database.   For  example, the creation of record number 8,
       when records 6 and 7 do not yet exist, is  not  an  error.
       However,  any  attempt  to  retrieve  such  records (e.g.,
       records 6 and 7) will return DB_KEYEMPTY.

       Deleting a record will not, by default,  renumber  records
       following  the  deleted  record (see DB_RENUMBER below for
       more  information).   Any  attempt  to  retrieve   deleted
       records will return DB_KEYEMPTY.

       The  following additional fields and flags may be initial-
       ized in the DbInfo object before  calling  _D_b_:_:_o_p_e_n,  when
       using the recno access method:

       int re_delim;
            For variable length records, if the _r_e___s_o_u_r_c_e file is
            specified and  the  DB_DELIMITER  flag  is  set,  the
            delimiting  byte  used to mark the end of a record in
            the source file.  If the _r_e___s_o_u_r_c_e file is  specified
            and the DB_DELIMITER flag is not set, <newline> char-
            acters (i.e. ``\n'', 0x0a) are interpreted as end-of-
            record markers.

       u_int32_t re_len;
            The length of a fixed-length record.

       int re_pad;
            For  fixed length records, if the DB_PAD flag is set,
            the pad character for short records.  If  the  DB_PAD
            flag is not explicitly set, <space> characters (i.e.,
            0x20) are used for padding.

       char *re_source;
            The purpose of the _r_e___s_o_u_r_c_e field is to provide fast
            access  and  modification  to databases that are nor-
            mally stored as flat text files.

            If the _r_e___s_o_u_r_c_e field is explicitly set,  it  speci-
            fies  an  underlying  flat text database file that is
            read to initialize a transient record  number  index.
            In  the  case of variable length records, the records
            are separated by the byte value _r_e___d_e_l_i_m.  For  exam-
            ple,  standard  UNIX  byte stream files can be inter-
            preted as a sequence of variable length records sepa-
            rated by <newline> characters.

            In addition, when cached data would normally be writ-
            ten back to the underlying database file  (e.g.,  the
            _c_l_o_s_e  or  _s_y_n_c  functions are called), the in-memory
            copy of the database will  be  written  back  to  the
            _r_e___s_o_u_r_c_e file.

            By  default,  the backing source file is read lazily,
            i.e., records are not read from the file  until  they
            are  requested  by the application.  IIff mmuullttiippllee pprroo--
            cceesssseess ((nnoott tthhrreeaaddss)) aarree aacccceessssiinngg aa  rreeccnnoo  ddaattaabbaassee
            ccoonnccuurrrreennttllyy   aanndd   eeiitthheerr   iinnsseerrttiinngg  oorr  ddeelleettiinngg
            rreeccoorrddss,, tthhee bbaacckkiinngg ssoouurrccee ffiillee mmuusstt bbee rreeaadd iinn  iittss
            eennttiirreettyy  bbeeffoorree  mmoorree tthhaann aa ssiinnggllee pprroocceessss aacccceesssseess
            tthhee ddaattaabbaassee,, aanndd oonnllyy tthhaatt  pprroocceessss  sshhoouulldd  ssppeecciiffyy
            tthhee bbaacckkiinngg ssoouurrccee ffiillee aass ppaarrtt ooff tthhee _D_b_:_:_o_p_e_n call.
            See the DB_SNAPSHOT flag below for more  information.

            RReeaaddiinngg aanndd wwrriittiinngg tthhee bbaacckkiinngg ssoouurrccee ffiillee ssppeecciiffiieedd
            bbyy  rree__ssoouurrccee  ccaannnnoott  bbee  ttrraannssaaccttiioonnaallllyy  pprrootteecctteedd
            bbeeccaauussee  iitt  iinnvvoollvveess  ffiilleessyysstteemm ooppeerraattiioonnss tthhaatt aarree
            nnoott ppaarrtt ooff tthhee DDbb ttrraannssaaccttiioonn mmeetthhooddoollooggyy..  For this
            reason,  if  a temporary database is used to hold the
            records, i.e., a NULL was specified as the _f_i_l_e argu-
            ment to _D_b_:_:_o_p_e_n, it is possible to lose the contents
            of the _r_e___s_o_u_r_c_e file, e.g., if the system crashes at
            the  right  instant.   If  a file is used to hold the
            database, i.e., a file name was specified as the _f_i_l_e
            argument  to  _D_b_:_:_o_p_e_n,  normal  database recovery on
            that file can be used to  prevent  information  loss,
            although  it  is  still possible that the contents of
            _r_e___s_o_u_r_c_e will be lost if the system crashes.

            The _r_e___s_o_u_r_c_e file must already  exist  (but  may  be
            zero-length) when _D_b_:_:_o_p_e_n is called.

            For  all of the above reasons, the _r_e___s_o_u_r_c_e field is
            generally used to specify databases  that  are  read-
            only  for Db applications, and that are either gener-
            ated on the fly by software tools, or modified  using
            a different mechanism, e.g., a text editor.

       unsigned long flags;
            The  following  additional  flags may be specified by
            oorr'ing together one or more of the following values:


            DB_DELIMITER
                 The _r_e___d_e_l_i_m field is set.


            DB_FIXEDLEN
                 The records are fixed-length,  not  byte  delim-
                 ited.   The _r_e___l_e_n value specifies the length of
                 the record, and the _r_e___p_a_d value is used as  the
                 pad character.

                 Any  records added to the database that are less
                 than _r_e___l_e_n bytes long are automatically padded.
                 Any  attempt to insert records into the database
                 that are greater than  _r_e___l_e_n  bytes  long  will
                 cause the call to fail immediately and return an
                 error.


            DB_PAD
                 The _r_e___p_a_d field is set.


            DB_RENUMBER
                 Specifying the DB_RENUMBER flag causes the logi-
                 cal  record numbers to be mutable, and change as
                 records  are  added  to  and  deleted  from  the
                 database.   For  example, the deletion of record
                 number 4 causes records numbered 5  and  greater
                 to be renumbered downward by 1.  If a cursor was
                 positioned to record number 4 before  the  dele-
                 tion, it will reference the new record number 4,
                 if any such record exists, after  the  deletion.
                 If a cursor was positioned after record number 4
                 before the deletion, it will be shifted downward
                 1  logical  record,  continuing to reference the
                 same record as it did before.

                 Using the _D_b_c_:_:_p_u_t or _p_u_t interfaces  to  create
                 new  records will cause the creation of multiple
                 records if the record number is  more  than  one
                 greater than the largest record currently in the
                 database.  For example, creating record 28, when
                 record  25 was previously the last record in the
                 database, will create records 26 and 27 as  well
                 as  28.   Attempts to retrieve records that were
                 created in this manner will result in  an  error
                 return of DB_KEYEMPTY.

                 If  a  created  record  is not at the end of the
                 database, all records following the  new  record
                 will  be  automatically  renumbered upward by 1.
                 For example, the creation of a new  record  num-
                 bered 8 causes records numbered 8 and greater to
                 be renumbered upward by  1.   If  a  cursor  was
                 positioned  to record number 8 or greater before
                 the insertion, it will be shifted upward 1 logi-
                 cal  record,  continuing  to  reference the same
                 record as it did before.

                 For these reasons, concurrent access to a  recno
                 database with the DB_RENUMBER flag specified may
                 be largely  meaningless,  although  it  is  sup-
                 ported.


            DB_SNAPSHOT
                 This flag specifies that any specified _r_e___s_o_u_r_c_e
                 file be read in its entirety  when  _D_b_:_:_o_p_e_n  is
                 called.   If  this  flag  is  not specified, the
                 _r_e___s_o_u_r_c_e file may be read lazily.


SSEEEE AALLSSOO
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___i_n_t_e_r_n_a_l(3), _d_b___t_h_r_e_a_d(3), _D_b(3), _D_b_c(3), _D_b_E_n_v(3),
       _D_b_E_x_c_e_p_t_i_o_n(3), _D_b_I_n_f_o(3), _D_b_L_o_c_k(3), _D_b_L_o_c_k_T_a_b(3), _D_b_L_o_g(3),
       _D_b_L_s_n(3), _D_b_M_p_o_o_l(3), _D_b_M_p_o_o_l_F_i_l_e(3), _D_b_t(3), _D_b_T_x_n(3),
       _D_b_T_x_n_M_g_r(3)
