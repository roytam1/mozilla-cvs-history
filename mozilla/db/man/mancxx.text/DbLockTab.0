

NNAAMMEE
       DbLockTab - lock manager

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb__ccxxxx..hh>>

       ssttaattiicc iinntt
       DDbbLLoocckkTTaabb::::ooppeenn((ccoonnsstt cchhaarr **ddiirr,,
            uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,, DDbbEEnnvv **ddbbeennvv,, DDbbLLoocckkTTaabb ****rreeggiioonnpp));;

       iinntt
       DDbbLLoocckkTTaabb::::iidd((uu__iinntt3322__tt **iiddpp));;

       iinntt
       DDbbLLoocckkTTaabb::::vveecc((uu__iinntt3322__tt lloocckkeerr,, uu__iinntt3322__tt ffllaaggss,,
            DDBB__LLOOCCKKRREEQQ lliisstt[[]],, iinntt nnlliisstt,, DDBB__LLOOCCKKRREEQQ ****eelliissttpp));;

       iinntt
       DDbbLLoocckkTTaabb::::ggeett((uu__iinntt3322__tt lloocckkeerr,, uu__iinntt3322__tt ffllaaggss,,
            ccoonnsstt DDbbtt **oobbjj,, ccoonnsstt ddbb__lloocckkmmooddee__tt lloocckk__mmooddee,, DDBB__LLOOCCKK **lloocckk));;

       iinntt
       DDbbLLoocckkTTaabb::::cclloossee(());;

       ssttaattiicc iinntt
       DDbbLLoocckkTTaabb::::uunnlliinnkk((ccoonnsstt cchhaarr **ddiirr,, iinntt ffoorrccee,, DDbbEEnnvv **ddbbeennvv));;

       iinntt
       DDbbLLoocckkTTaabb::::ddeetteecctt((uu__iinntt3322__tt ffllaaggss,, uu__iinntt3322__tt aattyyppee));;

DDEESSCCRRIIPPTTIIOONN
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see _d_b___i_n_t_r_o(3).

       This manual page describes the  specific  details  of  the
       locking interface.

       The _D_b_L_o_c_k_T_a_b class is intended to provide general-purpose
       locking.   While  designed  to  work  with  the  other  Db
       classes,  this class is also useful for more general lock-
       ing purposes.  Locks can be shared between processes.   In
       most  cases,  when  multiple treads or processes are using
       locking, the deadlock detector, _d_b___d_e_a_d_l_o_c_k(1), should  be
       run.

  _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n
       The  _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n  method copies a pointer, to the lock
       table identified by the ddiirreeccttoorryy  _d_i_r,  into  the  memory
       location referenced by _r_e_g_i_o_n_p.


       If  the  _d_b_e_n_v argument to _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n was initialized
       using _D_b_E_n_v_:_:_a_p_p_i_n_i_t, _d_i_r is interpreted as  described  by
       _D_b_E_n_v(3).

       Otherwise,  if _d_i_r is not NULL, it is interpreted relative
       to the current working directory of the process.   If  _d_i_r
       is  NULL,  the following environment variables are checked
       in order: ``TMPDIR'', ``TEMP'', and ``TMP''.   If  one  of
       them  is set, lock table files are created relative to the
       directory it specifies.  If none  of  them  are  set,  the
       first  possible  one of the following directories is used:
       _/_v_a_r_/_t_m_p, _/_u_s_r_/_t_m_p, _/_t_e_m_p, _/_t_m_p, _C_:_/_t_e_m_p and _C_:_/_t_m_p.

       All files associated with the lock table  are  created  in
       this  directory.   This  directory must already exist when
       DbLockTab::open is called.   If  the  lock  table  already
       exists, the process must have permission to read and write
       the existing files.  If the lock table  does  not  already
       exist, it is optionally created and initialized.

       The  _f_l_a_g_s  and  _m_o_d_e  arguments specify how files will be
       opened and/or created when they don't already exist.   The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create any underlying files, as  necessary.   If  the
            files  do not already exist and the DB_CREATE flag is
            not specified, the call will fail.


       DB_THREAD
            Cause the DbLockTab handle returned  by  the  _D_b_L_o_c_k_-
            _T_a_b_:_:_o_p_e_n  method  to  be useable by multiple threads
            within a single address space, i.e.,  to  be  ``free-
            threaded''.

       All  files  created by the lock subsystem are created with
       mode _m_o_d_e (as described in _c_h_m_o_d(2)) and modified  by  the
       process'   umask  value  at  the  time  of  creation  (see
       _u_m_a_s_k(2)).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

       The locking subsystem is configured  based  on  which  set
       methods  have been used.  It is expected that applications
       will use a single DbEnv object as the argument to  all  of
       the subsystems in the DB package.  The fields of the DbEnv
       object used by _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n are  described  below.   As
       references  to  the  DbEnv  object  may  be  maintained by
       _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n, it is necessary that the DbEnv object and
       memory   it  references  be  valid  until  the  object  is
       destroyed.  Any of the DbEnv fields that are  not  explic-
       itly set will default to appropriate values.

       The  following  fields in the DbEnv object may be initial-
       ized, using the appropriate  set  method,  before  calling
       _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n:


       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       class ostream *db_error_stream;
       int db_verbose;
            The error fields of the DbEnv behave as described for
            _D_b_E_n_v(3).

       const u_int8_t lk_conflicts[][];
            A _l_k___m_o_d_e_s by _l_k___m_o_d_e_s array.  A non-0 value for  the
            array element:

                 lk_conflicts[requested_mode][held_mode]

            indicates that requested_mode and held_mode conflict.
            The ``not-granted'' mode must be  represented  by  0.
            If   _l_k___c_o_n_f_l_i_c_t_s   is   NULL,  the  conflicts  array
            _d_b___r_w___c_o_n_f_l_i_c_t_s is used; see the section below  enti-
            tled  ``STANDARD  LOCK  MODES''  for a description of
            that array.

       u_int32_t lk_detect;
            If non-0, specifies that the deadlock detector be run
            whenever  a lock conflict occurs, and specifies which
            transaction should be aborted in the case of a  dead-
            lock.   The _l_k___d_e_t_e_c_t field must be set to one of the
            following values.


            DB_LOCK_DEFAULT
                 Use the  default  policy  as  specified  in  the
                 _d_b___d_e_a_d_l_o_c_k(1) man page.


            DB_LOCK_OLDEST
                 Abort the oldest transaction.


            DB_LOCK_RANDOM
                 Abort a random transaction involved in the dead-
                 lock.


            DB_LOCK_YOUNGEST
                 Abort the youngest transaction.

       u_int32_t lk_max;
            The maximum number of locks to be held  or  requested
            in  the table.  This value is used by _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n
            to estimate how much space to  allocate  for  various
            lock-table data structures.  If _l_k___m_a_x is not explic-
            itly set, a default value is used.

       u_int32_t lk_modes;

       The number of lock modes to  be  recognized  by  the  lock
            table (including
            the ``not-granted'' mode).  If  _l_k___m_o_d_e_s  is  0,  the
            value  DB_LOCK_RW_N is used; see below for a descrip-
            tion of that value.

       The _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_L_o_c_k_T_a_b_:_:_i_d
       The  _D_b_L_o_c_k_T_a_b_:_:_i_d  method  copies  a  locker ID, which is
       guaranteed to be unique in the specified lock table,  into
       the memory location referenced by _i_d_p.

       The  access  methods  (see  _D_b_:_:_o_p_e_n in _D_b(3)), generate a
       unique locker ID for each file that is opened  with  lock-
       ing.   During  Db  access method operation, this locker ID
       will be used for all lock calls unless a transaction iden-
       tifier  was  specified  for  the  call,  in which case the
       transaction ID specified is used for locking.

       The  _D_b_L_o_c_k_T_a_b_:_:_i_d  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)   or
       returns the value of _e_r_r_n_o on failure and 0 on success.


  _D_b_L_o_c_k_T_a_b_:_:_v_e_c
       The  _D_b_L_o_c_k_T_a_b_:_:_v_e_c method atomically obtains and releases
       one or more locks from the specified table.   The  _D_b_L_o_c_k_-
       _T_a_b_:_:_v_e_c  method  is  intended  to  support acquisition or
       trading of multiple locks under one lock table  semaphore,
       as  is  needed  for  lock  coupling or in multigranularity
       locking for lock escalation.

       The _l_o_c_k_e_r argument  specified  to  _D_b_L_o_c_k_T_a_b_:_:_v_e_c  is  an
       unsigned  32-bit  integer  quantity.   It  represents  the
       entity requesting or releasing the lock.

       The _f_l_a_g_s value must be set to 0 or the following value:


       DB_LOCK_NOWAIT
            If a lock cannot be  granted  because  the  requested
            lock  conflicts with an existing lock, return immedi-
            ately instead of  waiting  for  the  lock  to  become
            available.

       The  _l_i_s_t array provided to _D_b_L_o_c_k_T_a_b_:_:_v_e_c is typedef'd in
       <db_cxx.h> as DB_LOCKREQ.  A DB_LOCKREQ structure  has  at
       least  the  following  fields,  which  must be initialized
       before calling _D_b_L_o_c_k_T_a_b_:_:_v_e_c:

       lockop_t op;
            The operation to be performed, which must be  set  to
            one of the following values:


            DB_LOCK_GET
                 Get  a lock, as defined by the values of _l_o_c_k_e_r,
                 _o_b_j and _m_o_d_e.  Upon return from  _D_b_L_o_c_k_T_a_b_:_:_v_e_c,
                 if  the  _l_o_c_k  field is non-NULL, a reference to
                 the acquired lock is stored there.  (This refer-
                 ence  is  invalidated  by  any  call  to _D_b_L_o_c_k_-
                 _T_a_b_:_:_v_e_c or _D_b_L_o_c_k_:_:_p_u_t that releases the lock.)
                 See _D_b_L_o_c_k(3).


            DB_LOCK_PUT
                 The  lock referenced by the contents of the _l_o_c_k
                 field is released.


            DB_LOCK_PUT_ALL
                 All locks held by the _l_o_c_k_e_r are released.  (Any
                 locks  acquired as a part of the current call to
                 _D_b_L_o_c_k_T_a_b_:_:_v_e_c    that    appear    after    the
                 DB_LOCK_PUT_ALL  entry  are  not  considered for
                 this operation).


            DB_LOCK_PUT_OBJ
                 All locks held by the _l_o_c_k_e_r, on the object _o_b_j,
                 with   the  mode  specified  by  _l_o_c_k___m_o_d_e,  are
                 released.  A _l_o_c_k___m_o_d_e of  DB_LOCK_NG  indicates
                 that all locks on the object should be released.
                 Note that any locks acquired as a  part  of  the
                 current call to _D_b_L_o_c_k_T_a_b_:_:_v_e_c that occur before
                 the DB_LOCK_PUT_OBJ will also be released; those
                 acquired afterwards will not be released.

       const Dbt obj;
            An  untyped  byte string that specifies the object to
            be locked or released.

       const lockmode_t mode;
            The lock mode, used as an index  into  object's  con-
            flict array.

       DB_LOCK lock;
            A lock reference.

       The _n_l_i_s_t argument specifies the number of elements in the
       _l_i_s_t array.

       If any of the requested locks cannot be acquired,  or  any
       of the locks to be released cannot be released, the opera-
       tions before the failing operation are guaranteed to  have
       completed  successfully, and _D_b_L_o_c_k_T_a_b_:_:_v_e_c returns a non-
       zero value.  In addition, if _e_l_i_s_t_p is not NULL, it is set
       to  point to the DB_LOCKREQ entry that was being processed
       when the error occurred.

       In the case of an error, _D_b_L_o_c_k_T_a_b_:_:_v_e_c may return one  of
       the following values:


       DB_LOCK_DEADLOCK
            The  specified  _l_o_c_k_e_r  was  selected  as a victim in
            order to resolve a deadlock.


       DB_LOCK_NOTHELD
            The lock cannot be released, as it was  not  held  by
            the _l_o_c_k_e_r.


       DB_LOCK_NOTGRANTED
            A  lock  was  requested that could not be granted and
            the _f_l_a_g parameter was  set  to  DB_LOCK_NOWAIT.   In
            this case, if non-NULL, _e_l_i_s_t_p identifies the request
            that was granted.

       Otherwise, the _D_b_L_o_c_k_T_a_b_:_:_v_e_c  method  throws  a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)  or returns the value of _e_r_r_n_o on failure and 0 on
       success.


  _D_b_L_o_c_k_T_a_b_:_:_g_e_t
       The _D_b_L_o_c_k_T_a_b_:_:_g_e_t method is a simple interface to the

       _D_b_L_o_c_k_T_a_b_:_:_v_e_c functionality, and is equivalent to calling
       the

       _D_b_L_o_c_k_T_a_b_:_:_v_e_c method with the _l_o_c_k_e_r argument, _e_l_i_s_t_p and
       _c_o_n_f_l_i_c_t arguments, and a single element _l_i_s_t  array,  for
       which  the _o_p field is DB_LOCK_GET, and the _o_b_j, _l_o_c_k___m_o_d_e
       and _l_o_c_k fields are represented by the  arguments  of  the
       same  name.   Note  that  the  type of the _o_b_j argument to
       _D_b_L_o_c_k_T_a_b_:_:_g_e_t is different from the _o_b_j element found  in
       the   DB_LOCKREQ  structure.   The  _D_b_L_o_c_k_T_a_b_:_:_g_e_t  method
       returns success and failure as described for the

       _D_b_L_o_c_k_T_a_b_:_:_v_e_c method.

  _D_b_L_o_c_k_T_a_b_:_:_c_l_o_s_e
       The _D_b_L_o_c_k_T_a_b_:_:_c_l_o_s_e method disassociates the calling pro-
       cess  from  the lock table.  The object should not be used
       after a call to close.  Note  that  _D_b_L_o_c_k_T_a_b_:_:_c_l_o_s_e  does
       not  release  any locks still held by the closing process.
       (This provides functionality for long-lived locks.)

       Processes that wish to have all their locks  released  can
       do so by issuing the appropriate _D_b_L_o_c_k_T_a_b_:_:_v_e_c call.

       In  addition,  if  the _d_i_r argument to _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n was
       NULL and _d_b_e_n_v was not initialized  using  _D_b_E_n_v_:_:_a_p_p_i_n_i_t,
       all  files created for this shared region will be removed,
       as if _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k were called.

       When multiple threads are using the DbLockTab object  con-
       currently,  only  a  single  thread  may  call the _D_b_L_o_c_k_-
       _T_a_b_:_:_c_l_o_s_e method.

       The _D_b_L_o_c_k_T_a_b_:_:_c_l_o_s_e method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.


  _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k
       The _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k method destroys the lock table iden-
       tified by the directory _d_i_r, removing all  files  used  to
       implement  the  lock  table.   (The  directory  _d_i_r is not
       removed.)  If there are processes that have called _D_b_L_o_c_k_-
       _T_a_b_:_:_o_p_e_n  without  calling  _D_b_L_o_c_k_T_a_b_:_:_c_l_o_s_e (i.e., there
       are processes currently using  the  lock  table),  _D_b_L_o_c_k_-
       _T_a_b_:_:_u_n_l_i_n_k  will  fail without further action, unless the
       force flag is set, in which  case  _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k  will
       attempt  to  remove the lock table files regardless of any
       processes still using the lock table.

       The result of attempting to forcibly  destroy  the  region
       when  a  process has the region open is unspecified.  Pro-
       cesses using a shared memory region maintain an open  file
       descriptor  for  it.   On UNIX systems, the region removal
       should succeed and processes that have already joined  the
       region  should  continue  to  run  in  the  region without
       change, however processes  attempting  to  join  the  lock
       table  will either fail or attempt to create a new region.
       On other systems, e.g., WNT, where  the  _u_n_l_i_n_k(2)  system
       call  will fail if any process has an open file descriptor
       for the file, the region removal will fail.

       In the case of catastrophic or  system  failure,  database
       recovery  must  be  performed  (see  _d_b___r_e_c_o_v_e_r(1)  or the
       DB_RECOVER     and     DB_RECOVER_FATAL      flags      to
       _D_b_E_n_v_:_:_a_p_p_i_n_i_t(3)).   Alternatively,  if  recovery  is not
       required because no database state  is  maintained  across
       failures,  it  is  possible  to  clean  up a lock table by
       removing all of the files in the  directory  specified  to
       the  _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n method, as lock table files are never
       created in any directory other than the one  specified  to
       _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n.   Note, however, that this has the poten-
       tial to remove files created by the other DB subsystems in
       this database environment.

       The  _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k  method  throws a _D_b_E_x_c_e_p_t_i_o_n(3) or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_L_o_c_k_T_a_b_:_:_d_e_t_e_c_t
       The _D_b_L_o_c_k_T_a_b_:_:_d_e_t_e_c_t method runs  one  iteration  of  the
       deadlock detector on the current lock table.  The deadlock
       detector traverses the lock table, detects deadlocks,  and
       if  it  finds one, marks one of the participating transac-
       tions for abort and then returns.

       The flags value is specified by  oorr'ing  together  one  or
       more of the following values:



       DB_LOCK_CONFLICT
            Only run the deadlock detector if a lock conflict has
            occurred since the last time that the deadlock detec-
            tor was run.

       The  _a_t_y_p_e  parameter specifies which transaction to abort
       in the case of deadlock.  It must be set to one of  values
       described  above  for  the  _l_k___d_e_t_e_c_t  field  of the _D_b_E_n_v
       object.

       The _D_b_L_o_c_k_T_a_b_:_:_d_e_t_e_c_t method throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.

       The _D_b_L_o_c_k_T_a_b_:_:_d_e_t_e_c_t method is based on the C _l_o_c_k___d_e_t_e_c_t
       function, which is the underlying  function  used  by  the
       _d_b___d_e_a_d_l_o_c_k(1)  utility.   See  the  source  code  for the
       _d_b___d_e_a_d_l_o_c_k utility for an example of using _l_o_c_k___d_e_t_e_c_t in
       a UNIX environment.

EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The  following  environment variables affect the execution
       of _d_b___l_o_c_k:

       DB_HOME
            If the _d_b_e_n_v argument to _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n was initial-
            ized   using  _d_b___a_p_p_i_n_i_t,  the  environment  variable
            DB_HOME may be used as the path of the database  home
            for the interpretation of the _d_i_r argument to _D_b_L_o_c_k_-
            _T_a_b_:_:_o_p_e_n, as described in _d_b___a_p_p_i_n_i_t(3).

       TMPDIR
            If the _d_b_e_n_v argument to _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n was NULL  or
            not  initialized  using  _d_b___a_p_p_i_n_i_t,  the environment
            variable TMPDIR may be used as the directory in which
            to create the lock table, as described in the _D_b_L_o_c_k_-
            _T_a_b_:_:_o_p_e_n section above.

SSTTAANNDDAARRDD LLOOCCKK MMOODDEESS
       The include file <db_cxx.h>  declares  two  commonly  used
       conflict arrays:

       const u_int8_t db_lock_rw_conflicts[];
            This  is  a  conflict array for a simple scheme using
            shared and exclusive lock modes.

       const u_int8_t db_lock_riw_conflicts[];
            This is a conflict array that involves various intent
            lock  modes  (e.g.,  intent shared) that are used for
            multigranularity locking.

       Their associated sizes are DB_LOCK_RW_N and DB_LOCK_RIW_N.


       In  addition, the include file <db_cxx.h> defines the type
       _d_b___l_o_c_k_m_o_d_e___t, which is the type of the  lock  modes  used
       with the standard tables above:


              DB_LOCK_NG
                   not granted (always 0)


              DB_LOCK_READ
                   read (shared)


              DB_LOCK_WRITE
                   write (exclusive)

EERRRROORRSS
       Methods  marked as returning _e_r_r_n_o will, by default, throw
       an exception that encapsulates the error information.  The
       default error behavior can be changed, see _D_b_E_x_c_e_p_t_i_o_n(3).

       The _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n method may fail and throw  a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: DbLock::unlink(3),
       close(2), db_version(3), fcntl(2), fflush(3), lseek(2),
       malloc(3), memcpy(3), memset(3), mmap(2), munmap(2),
       open(2), sigfillset(3), sigprocmask(2), stat(2), str-
       cpy(3), strdup(3), strerror(3), strlen(3), unlink(2), and
       write(2).

       In addition, the _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n method may fail and throw
       a _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for the following  condi-
       tions:

       [EAGAIN]
            The  shared memory region was locked and (repeatedly)
            unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_THREAD flag was specified  and  spinlocks  are
            not implemented for this architecture.


       The  _D_b_L_o_c_k_T_a_b_:_:_v_e_c  method  may fail and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or return _e_r_r_n_o for any of the errors  specified  for  the
       following DB and library functions: DbLock::detect(3),
       fcntl(2), fflush(3), lseek(2), memcpy(3), memset(3),
       mmap(2), munmap(2), strerror(3), and write(2).

       In  addition, the _D_b_L_o_c_k_T_a_b_:_:_v_e_c method may fail and throw
       a _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for the following  condi-
       tions:

       [EACCES]
            An  attempt  was made to release lock held by another
            locker.

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _D_b_L_o_c_k_T_a_b_:_:_g_e_t method may fail and  throw  a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: DbLock::detect(3),
       fcntl(2), fflush(3), lseek(2), memcpy(3), memset(3),
       mmap(2), munmap(2), strerror(3), and write(2).

       In addition, the _D_b_L_o_c_k_T_a_b_:_:_g_e_t method may fail and  throw
       a  _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for the following condi-
       tions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _D_b_L_o_c_k_T_a_b_:_:_c_l_o_s_e method may fail and throw a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: close(2), fcntl(2),
       fflush(3), munmap(2), and strerror(3).

       The _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k method may fail and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or return _e_r_r_n_o for any of the errors  specified  for  the
       following DB and library functions: close(2), fcntl(2),
       fflush(3), malloc(3), memcpy(3), memset(3), mmap(2), mun-
       map(2), open(2), sigfillset(3), sigprocmask(2), stat(2),
       strcpy(3), strdup(3), strerror(3), strlen(3), and
       unlink(2).

       In  addition,  the  _D_b_L_o_c_k_T_a_b_:_:_u_n_l_i_n_k  method may fail and
       throw a _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for  the  following
       conditions:

       [EBUSY]
            The  shared  memory  region  was in use and the force
            flag was not set.

       The _D_b_L_o_c_k_T_a_b_:_:_d_e_t_e_c_t method may fail and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: calloc(3), fcntl(2),
       fflush(3), lseek(2), malloc(3), memcpy(3), memset(3),
       mmap(2), munmap(2), strerror(3), and write(2).

BBUUGGSS
       If a process dies while holding locks, those locks  remain
       held  and are nneevveerr released.  In this case, all processes
       should exit as quickly as possible, so that _d_b___r_e_c_o_v_e_r can
       be run.

SSEEEE AALLSSOO
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___i_n_t_e_r_n_a_l(3), _d_b___t_h_r_e_a_d(3), _D_b(3), _D_b_c(3), _D_b_E_n_v(3),
       _D_b_E_x_c_e_p_t_i_o_n(3), _D_b_I_n_f_o(3), _D_b_L_o_c_k(3), _D_b_L_o_c_k_T_a_b(3), _D_b_L_o_g(3),
       _D_b_L_s_n(3), _D_b_M_p_o_o_l(3), _D_b_M_p_o_o_l_F_i_l_e(3), _D_b_t(3), _D_b_T_x_n(3),
       _D_b_T_x_n_M_g_r(3)
