

NNAAMMEE
       DbTxn - Db transaction management

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb__ccxxxx..hh>>

       iinntt
       DDbbTTxxnn::::pprreeppaarree(());;

       iinntt
       DDbbTTxxnn::::ccoommmmiitt(());;

       iinntt
       DDbbTTxxnn::::aabboorrtt(());;

       uu__iinntt3322__tt
       DDbbTTxxnn::::iidd(());;

DDEESSCCRRIIPPTTIIOONN
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see _d_b___i_n_t_r_o(3).

       This manual page describes the specific details of the  Db
       transaction  support.  The DbTxn class is used in conjunc-
       tion with _D_b_T_x_n_M_g_r(3) to  provide  transaction  semantics.
       Full  transaction  support  is provided by a collection of
       modules that provide interfaces to the  services  required
       for  transaction  processing.  These services are recovery
       (see _D_b_L_o_g(3)), concurrency  control  (see  _D_b_L_o_c_k(3)  and
       _D_b_L_o_c_k_T_a_b(3)), and the management of shared data (see _D_b_M_-
       _p_o_o_l(3) and _D_b_M_p_o_o_l_F_i_l_e(3)).  Transaction semantics can be
       applied  to  the access methods described in _D_b(3) through
       method call parameters.

       The model intended for transactional use (and the one that
       is used by the access methods) is write-ahead logging pro-
       vided by _D_b_L_o_g(3) to record both before- and after-images.
       Locking follows a two-phase protocol, with all locks being
       released at transaction commit.

  _D_b_T_x_n_:_:_p_r_e_p_a_r_e
       The _D_b_T_x_n_:_:_p_r_e_p_a_r_e method initiates the beginning of a two
       phase  commit.   In a distributed transaction environment,
       _d_b can be used as a local transaction  manager.   In  this
       case,  the  distributed transaction manager must send _p_r_e_-
       _p_a_r_e messages to each local manager.   The  local  manager
       must  then issue a _D_b_T_x_n_:_:_p_r_e_p_a_r_e and await its successful
       return before responding to  the  distributed  transaction
       manager.   Only  after the distributed transaction manager
       receives successful responses  from  all  of  its  _p_r_e_p_a_r_e
       messages should it issue any _c_o_m_m_i_t messages.

       The  _D_b_T_x_n_:_:_p_r_e_p_a_r_e  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_T_x_n_:_:_c_o_m_m_i_t
       The _D_b_T_x_n_:_:_c_o_m_m_i_t method ends the  transaction  associated
       with  the  DbTxn.   If  DB_TXN_NOSYNC was not specified, a
       commit log record is written and flushed to disk,  as  are
       all previously written log records.  If the transaction is
       nested, its locks are acquired by the parent  transaction,
       otherwise  its  locks are released.  Any applications that
       require strict two-phase  locking  must  not  release  any
       locks  explicitly,  leaving  them  all  to  be released by
       _D_b_T_x_n_:_:_c_o_m_m_i_t.

       The  _D_b_T_x_n_:_:_c_o_m_m_i_t  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)   or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_T_x_n_:_:_a_b_o_r_t
       The  _D_b_T_x_n_:_:_a_b_o_r_t method causes an abnormal termination of
       the transaction.  The log is played backwards and any nec-
       essary  recovery  operations  are  initiated  through  the
       _r_e_c_o_v_e_r method specified to _D_b_T_x_n_M_g_r_:_:_o_p_e_n.  After  recov-
       ery  is  completed,  all locks held by the transaction are
       acquired by the parent transaction in the case of a nested
       transaction or released in the case of a non-nested trans-
       action.  As is the case  for  _D_b_T_x_n_:_:_c_o_m_m_i_t,  applications
       that  require  strict two phase locking should not explic-
       itly release any locks.

       The _D_b_T_x_n_:_:_a_b_o_r_t method throws a _D_b_E_x_c_e_p_t_i_o_n(3) or returns
       the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_T_x_n_:_:_i_d
       The  _D_b_T_x_n_:_:_i_d  method  returns  the unique transaction id
       associated with the specified transaction.  Locking  calls
       made  on  behalf  of this transaction should use the value
       returned from _D_b_T_x_n_:_:_i_d as the  locker  parameter  to  the
       _D_b_L_o_c_k_T_a_b_:_:_g_e_t or _D_b_L_o_c_k_T_a_b_:_:_v_e_c calls.


TTRRAANNSSAACCTTIIOONNSS
       Creating  transaction  protected applications using the Db
       access methods requires little system  customization.   In
       most  cases,  the  default parameters to the locking, log-
       ging, memory pool, and transaction  subsystems  will  suf-
       fice.   Applications can use _D_b_E_n_v_:_:_a_p_p_i_n_i_t (see _D_b_E_n_v(3))
       to perform this initialization, or they may do it  explic-
       itly.

       Each database operation (i.e., any call to a method under-
       lying the handles  returned  by  _D_b_:_:_o_p_e_n  and  _D_b_:_:_c_u_r_s_o_r
       described  in  _D_b(3)) is normally performed on behalf of a
       unique locker.  If multiple calls on behalf  of  the  same
       locker are desired, then transactions must be used.

       Once  the  application  has  initialized the Db subsystems
       that it is  using,  it  may  open  the  Db  access  method
       databases.   For applications performing transactions, the
       databases must be opened after  subsystem  initialization,
       and  cannot  be opened as part of a transaction.  Once the
       databases are opened, the application can  group  sets  of
       operations  into  transactions,  by surrounding the opera-
       tions with the appropriate _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n,  _D_b_T_x_n_:_:_c_o_m_m_i_t
       and  _D_b_T_x_n_:_:_a_b_o_r_t calls.  Databases accessed by a transac-
       tion must not be closed during the transaction.  Note,  it
       is not necessary to transaction protect read-only transac-
       tions, unless those transactions require repeatable reads.

       The Db access methods will make the appropriate calls into
       the lock, log and memory pool subsystems in order to guar-
       antee  that  transaction  semantics are applied.  When the
       application is ready to exit, all outstanding transactions
       should have been committed or aborted.  At this point, all
       open Db files should be  closed.   Once  the  Db  database
       files  are  closed,  the  Db  subsystems should be closed,
       either explicitly or by destroying the _D_b_E_n_v(3) object.

       It is also possible to use the locking, logging and trans-
       action  subsystems  of Db to provide transaction semantics
       to objects other than those described  by  the  Db  access
       methods.   In  these cases, the application will need more
       explicit customization of the subsystems as  well  as  the
       development  of appropriate data-structure-specific recov-
       ery functions.

       For example, consider an application that provides  trans-
       action  semantics  to  data  stored  in  plain  UNIX files
       accessed using the _r_e_a_d(2) and _w_r_i_t_e(2) system calls.  The
       operations for which transaction protection is desired are
       bracketed by calls to _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n and _D_b_T_x_n_:_:_c_o_m_m_i_t.

       Before data are referenced, the application  must  make  a
       call  to  the  lock  manager, _D_b_L_o_c_k(3), for a lock of the
       appropriate type (e.g., read) on the object being  locked.
       The object might be a page in the file, a byte, a range of
       bytes, or some key.  It is up to the application to ensure
       that  appropriate  locks  are acquired.  Before a write is
       performed, the application should acquire a write lock  on
       the object, by making an appropriate call to the lock man-
       ager, _D_b_L_o_c_k(3)_.  Then, the application should make a call
       to the log manager, _D_b_L_o_g, to record enough information to
       redo the operation in case of failure after commit and  to
       undo  the operation in case of abort.  As discussed in the
       _D_b_L_o_g(3) manual page, the application is  responsible  for
       providing  any necessary structure to the log record.  For
       example, the application must understand what part of  the
       log  record is an operation code, what part identifies the
       file being modified, what part is  redo  information,  and
       what part is undo information.

       After  the  log  message  is  written, the application may
       issue the write  system  call.   After  all  requests  are
       issued,  the  application  may  call  _D_b_T_x_n_:_:_c_o_m_m_i_t.  When
       _D_b_T_x_n_:_:_c_o_m_m_i_t returns, the caller is guaranteed  that  all
       necessary log writes have been written to disk.

       At  any time, the application may call _D_b_T_x_n_:_:_a_b_o_r_t, which
       will result in the appropriate calls to the _r_e_c_o_v_e_r method
       to  restore  the ``database'' to a consistent pre-transac-
       tion state.  (The recover method must be  able  to  either
       re-apply  or undo the update depending on the context, for
       each different type of log record.)

       If the application should crash, the recovery process uses
       the  _D_b_L_o_g  interface to read the log and call the _r_e_c_o_v_e_r
       method to restore the database to a consistent state.

       The _D_b_T_x_n_:_:_p_r_e_p_a_r_e method provides the core  functionality
       to  implement  distributed  transactions,  but it does not
       manage the notification of  distributed  transaction  man-
       agers.   The caller is responsible for issuing _D_b_T_x_n_:_:_p_r_e_-
       _p_a_r_e calls to all sites participating in the  transaction.
       If  all  responses  are  positive,  the caller can issue a
       _D_b_T_x_n_:_:_c_o_m_m_i_t.  If any of the responses are negative,  the
       caller  should  issue  a  _D_b_T_x_n_:_:_a_b_o_r_t.   In  general, the
       _D_b_T_x_n_:_:_p_r_e_p_a_r_e call requires that the transaction  log  be
       flushed to disk.

TTRRAANNSSAACCTTIIOONN IIDD LLIIMMIITTSS
       The transaction ID space in Berkeley DB is 2^31, or 2 bil-
       lion entries.  It is possible that some  environments  may
       need to be aware of this limitation.  Consider an applica-
       tion performing 600 transactions a second for 15  hours  a
       day.   The transaction ID space will run out in roughly 66
       days:

              2^31 / (600 * 15 * 60 * 60) = 66

       Doing only 100 transactions a second exhausts the transac-
       tion ID space in roughly one year.

       The  transaction  ID  space is reset each time recovery is
       run.  If you reach the end of your transaction  ID  space,
       shut down your applications and restart them after running
       recovery (see _d_b___r_e_c_o_v_e_r(1) for  more  information).   The
       most    recently   allocated   transaction   ID   is   the
       _s_t___l_a_s_t___t_x_n_i_d value in the transaction statistics informa-
       tion, and is displayed by the _d_b___s_t_a_t(1) utility.


EERRRROORRSS
       Methods  marked as returning _e_r_r_n_o will, by default, throw
       an exception that encapsulates the error information.  The
       default error behavior can be changed, see _D_b_E_x_c_e_p_t_i_o_n(3).

       The _D_b_T_x_n_:_:_p_r_e_p_a_r_e method may fail and  throw  a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: DbLog::flush(3),
       fcntl(2), fflush(3), and strerror(3).

       The  _D_b_T_x_n_:_:_c_o_m_m_i_t  method  may  fail and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or return _e_r_r_n_o for any of the errors  specified  for  the
       following DB and library functions: DbLockTab::vec(3),
       DbLog::put(3), fcntl(2), fflush(3), malloc(3), memcpy(3),
       and strerror(3).

       In addition, the _D_b_T_x_n_:_:_c_o_m_m_i_t method may fail and throw a
       _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for  the  following  condi-
       tions:

       [EINVAL]
            The transaction was aborted.

       The  _D_b_T_x_n_:_:_a_b_o_r_t  method  may  fail  and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or return _e_r_r_n_o for any of the errors  specified  for  the
       following DB and library functions: DBenv->tx_recover(3),
       DbLockTab::vec(3), DbLog::get(3), fcntl(2), fflush(3),
       memset(3), and strerror(3).

       [EINVAL]
            The transaction was already aborted.

SSEEEE AALLSSOO
       _L_I_B_T_P_:  _P_o_r_t_a_b_l_e_,  _M_o_d_u_l_a_r  _T_r_a_n_s_a_c_t_i_o_n_s  _f_o_r  _U_N_I_X, Margo
       Seltzer, Michael Olson, USENIX proceedings, Winter 1992.

BBUUGGSS
       Nested transactions are not yet implemented.

       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___i_n_t_e_r_n_a_l(3), _d_b___t_h_r_e_a_d(3), _D_b(3), _D_b_c(3), _D_b_E_n_v(3),
       _D_b_E_x_c_e_p_t_i_o_n(3), _D_b_I_n_f_o(3), _D_b_L_o_c_k(3), _D_b_L_o_c_k_T_a_b(3), _D_b_L_o_g(3),
       _D_b_L_s_n(3), _D_b_M_p_o_o_l(3), _D_b_M_p_o_o_l_F_i_l_e(3), _D_b_t(3), _D_b_T_x_n(3),
       _D_b_T_x_n_M_g_r(3)
