

NNAAMMEE
       DbTxnMgr - Db transaction management

SSYYNNOOPPSSIISS
       ##iinncclluuddee <<ddbb__ccxxxx..hh>>

       ssttaattiicc iinntt
       DDbbTTxxnnMMggrr::::ooppeenn((ccoonnsstt cchhaarr **ddiirr,,
            uu__iinntt3322__tt ffllaaggss,, iinntt mmooddee,, DDbbEEnnvv **ddbbeennvv,, DDbbTTxxnnMMggrr ****rreeggiioonnpp));;

       iinntt
       DDbbTTxxnnMMggrr::::bbeeggiinn((DDbbTTxxnn **ppiidd,, DDbbTTxxnn ****ttiidd));;

       iinntt
       DDbbTTxxnnMMggrr::::cchheecckkppooiinntt((uu__iinntt3322__tt kkbbyyttee,, uu__iinntt3322__tt mmiinn)) ccoonnsstt;;

       iinntt
       DDbbTTxxnnMMggrr::::cclloossee(());;

       ssttaattiicc iinntt
       DDbbTTxxnnMMggrr::::uunnlliinnkk((ccoonnsstt cchhaarr **ddiirr,, iinntt ffoorrccee,, DDbbEEnnvv **ddbbeennvv));;

       iinntt
       DDbbTTxxnnMMggrr::::ssttaatt((DDBB__TTXXNN__SSTTAATT ****ssttaattpp,, vvooiidd **((**ddbb__mmaalllloocc))((ssiizzee__tt))));;

DDEESSCCRRIIPPTTIIOONN
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see _d_b___i_n_t_r_o(3).

       This manual page describes the specific details of the  Db
       transaction  support.   The DbTxnMgr class is used in con-
       junction with _D_b_T_x_n(3) to provide  transaction  semantics.
       Full  transaction  support  is provided by a collection of
       modules that provide interfaces to the  services  required
       for  transaction  processing.  These services are recovery
       (see _D_b_L_o_g(3)), concurrency  control  (see  _D_b_L_o_c_k(3)  and
       _D_b_L_o_c_k_T_a_b(3)), and the management of shared data (see _D_b_M_-
       _p_o_o_l(3) and _D_b_M_p_o_o_l_F_i_l_e(3)).  Transaction semantics can be
       applied  to  the access methods described in _D_b(3) through
       method call parameters.

       The model intended for transactional use (and that is used
       by the access methods) is that write-ahead logging is pro-
       vided by _D_b_L_o_g(3) to record both before-  and  after-image
       logging.   Locking follows a two-phase protocol (i.e., all
       locks are released at transaction commit).

  _D_b_T_x_n_M_g_r_:_:_o_p_e_n
       The _D_b_T_x_n_M_g_r_:_:_o_p_e_n method copies a pointer, to the  trans-
       action  region  identified  by the ddiirreeccttoorryy _d_i_r, into the
       memory location referenced by _r_e_g_i_o_n_p.

       If the _d_b_e_n_v argument to  _D_b_T_x_n_M_g_r_:_:_o_p_e_n  was  initialized
       using  _D_b_E_n_v_:_:_a_p_p_i_n_i_t,  _d_i_r is interpreted as described by
       _D_b_E_n_v(3).

       Otherwise, if _d_i_r is not NULL, it is interpreted  relative
       to  the  current working directory of the process.  If _d_i_r
       is NULL, the following environment variables  are  checked
       in  order:  ``TMPDIR'',  ``TEMP'', and ``TMP''.  If one of
       them is set, transaction region files are created relative
       to  the  directory it specifies.  If none of them are set,
       the first possible one of  the  following  directories  is
       used: _/_v_a_r_/_t_m_p, _/_u_s_r_/_t_m_p, _/_t_e_m_p, _/_t_m_p, _C_:_/_t_e_m_p and _C_:_/_t_m_p.

       All files associated with the transaction region are  cre-
       ated in this directory.  This directory must already exist
       when DbTxnMgr::open is called.  If the transaction  region
       already  exists,  the process must have permission to read
       and write the existing files.  If the  transaction  region
       does  not already exist, it is optionally created and ini-
       tialized.

       The _f_l_a_g_s and _m_o_d_e arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by oorr'ing together one or more of
       the following values:

       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.


       DB_THREAD
            Cause  the  DbTxnMgr  handle  returned  by the _D_b_T_x_n_-
            _M_g_r_:_:_o_p_e_n method to be useable  by  multiple  threads
            within  a  single  address space, i.e., to be ``free-
            threaded''.


       DB_TXN_NOSYNC
            On transaction commit, do not synchronously flush the
            log.   This  means  that transactions exhibit the ACI
            (atomicity, consistency  and  isolation)  properties,
            but not D (durability), i.e., database integrity will
            be maintained but it is possible that some number  of
            the  most  recently  committed  transactions  may  be
            undone during recovery instead of being redone.

            The number of transactions that  are  potentially  at
            risk is governed by how often the log is checkpointed
            (see _d_b___c_h_e_c_k_p_o_i_n_t(1)) and how many log  updates  can
            fit on a single log page.

       All files created by the transaction subsystem are created
       with mode _m_o_d_e (as described in _c_h_m_o_d(2)) and modified  by
       the  process'  umask  value  at  the time of creation (see
       _u_m_a_s_k(2)).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

       The transaction subsystem is configured based on which set
       methods  have been used.  It is expected that applications
       will use a single DbEnv object as the argument to  all  of
       the subsystems in the DB package.  The fields of the DbEnv
       object used by _D_b_T_x_n_M_g_r_:_:_o_p_e_n  are  described  below.   As
       references to the DbEnv object may be maintained by _D_b_T_x_n_-
       _M_g_r_:_:_o_p_e_n, it is necessary that the DbEnv object and  mem-
       ory  it references be valid until the object is destroyed.
       Any of the DbEnv fields that are not explicitly  set  will
       default to appropriate values.

       The  following  fields in the DbEnv object may be initial-
       ized, using the appropriate  set  method,  before  calling
       _D_b_T_x_n_M_g_r_:_:_o_p_e_n:


       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       class ostream *db_error_stream;
       int db_verbose;
            The error fields of the DbEnv behave as described for
            _D_b_E_n_v(3).

       DbLog *lg_info;
             The logging region  that  is  being  used  for  this
            transaction  environment.  The _l_g___i_n_f_o field contains
            a return value from the method _D_b_L_o_g_:_:_o_p_e_n.   LLooggggiinngg
            iiss  rreeqquuiirreedd  ffoorr ttrraannssaaccttiioonn eennvviirroonnmmeennttss,, aanndd iitt iiss
            aann eerrrroorr ttoo nnoott ssppeecciiffyy aa llooggggiinngg rreeggiioonn..

       DbLockTab *lk_info;
             The locking region  that  is  being  used  for  this
            transaction  environment.  The _l_k___i_n_f_o field contains
            a return value from the method  _D_b_L_o_c_k_T_a_b_:_:_o_p_e_n.   If
            _l_k___i_n_f_o  is NULL, no locking is done in this transac-
            tion environment.

       u_int32_t tx_max;
            The maximum number of simultaneous transactions  that
            are supported.  This bounds the size of backing files
            and is used to derive limits for the size of the lock
            region and logfiles.  When there are more than _t_x___m_a_x
            concurrent transactions, calls to _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n may
            cause  backing  files  to  grow.   If  _t_x___m_a_x is 0, a
            default value is used.

       int DbTxnMgr::recover(DbLog *logp, Dbt *DbLog::rec,
                 DbLsn *lsnp, int redo, void *info);
            A method that is called by _D_b_T_x_n_:_:_a_b_o_r_t during trans-
            action abort.  This method takes five arguments:

            logp A pointer to the transaction log (DbLog *).

            DbLog::rec
                 A log record.

            lsnp A pointer to a log sequence number (DbLsn *).

            redo An  integer value that is set to one of the fol-
                 lowing values:


                 DB_TXN_BACKWARD_ROLL
                      The log is being read backward to determine
                      which  transactions have been committed and
                      which transactions  were  not  (and  should
                      therefore be aborted during recovery).


                 DB_TXN_FORWARD_ROLL
                      The log is being played forward, any trans-
                      action ids encountered that have  not  been
                      entered  into  the  list referenced by _i_n_f_o
                      should be ignored.


                 DB_TXN_OPENFILES
                      The log is being read to open all the files
                      required to perform recovery.


                 DB_TXN_REDO
                      Redo  the  operation  described  by the log
                      record.


                 DB_TXN_UNDO
                      Undo the operation  described  by  the  log
                      record.

            info An  opaque pointer used to reference the list of
                 transaction IDs encountered during recovery.

            If _r_e_c_o_v_e_r is NULL,  the  default  is  that  only  Db
            access  method  operations are transaction protected,
            and the default recover method will be used.

       The  _D_b_T_x_n_M_g_r_:_:_o_p_e_n  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n
       The  _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n  method  creates a new transaction in
       the transaction manager, copying a pointer to a DbTxn that
       uniquely  identifies it into the memory referenced by _t_i_d.
       If the _p_i_d argument is non-NULL, the new transaction is  a
       nested  transaction  with the transaction indicated by _p_i_d
       as its parent.

       Transactions may not span threads, i.e., each  transaction
       must  begin  and end in the same thread, and each transac-
       tion may only be used by a single thread.

       The _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_T_x_n_M_g_r_:_:_c_l_o_s_e
       The  _D_b_T_x_n_M_g_r_:_:_c_l_o_s_e  method  detaches  a process from the
       transaction environment specified by the DbTxnMgr  object.
       All   mapped   regions  are  unmapped  and  any  allocated
       resources are freed.   Any  uncommitted  transactions  are
       aborted.

       In  addition,  if  the  _d_i_r argument to _D_b_T_x_n_M_g_r_:_:_o_p_e_n was
       NULL and _d_b_e_n_v was not initialized  using  _D_b_E_n_v_:_:_a_p_p_i_n_i_t,
       all  files created for this shared region will be removed,
       as if _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k were called.

       When multiple threads are using the DbTxnMgr  handle  con-
       currently,  only  a  single  thread  may  call  the _D_b_T_x_n_-
       _M_g_r_:_:_c_l_o_s_e method.

       The _D_b_T_x_n_M_g_r_:_:_c_l_o_s_e  method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.


  _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k
       The   _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k  method  destroys  the  transaction
       region identified by the directory _d_i_r, removing all files
       used  to implement the transaction region.  (The directory
       _d_i_r is not removed.)  If there  are  processes  that  have
       called   _D_b_T_x_n_M_g_r_:_:_o_p_e_n  without  calling  _D_b_T_x_n_M_g_r_:_:_c_l_o_s_e
       (i.e., there are processes currently using the transaction
       region),   _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k   will  fail  without  further
       action, unless the force flag is set, in which case _D_b_T_x_n_-
       _M_g_r_:_:_u_n_l_i_n_k  will attempt to remove the transaction region
       files regardless of any processes still using the transac-
       tion region.

       The  result  of  attempting to forcibly destroy the region
       when a process has the region open is  unspecified.   Pro-
       cesses  using a shared memory region maintain an open file
       descriptor for it.  On UNIX systems,  the  region  removal
       should  succeed and processes that have already joined the
       region should  continue  to  run  in  the  region  without
       change,  however processes attempting to join the transac-
       tion region will either fail or attempt to  create  a  new
       region.   On other systems, e.g., WNT, where the _u_n_l_i_n_k(2)
       system call will fail if any  process  has  an  open  file
       descriptor for the file, the region removal will fail.

       In  the  case  of catastrophic or system failure, database
       recovery must  be  performed  (see  _d_b___r_e_c_o_v_e_r(1)  or  the
       DB_RECOVER      and      DB_RECOVER_FATAL     flags     to
       _D_b_E_n_v_:_:_a_p_p_i_n_i_t(3)).  Alternatively,  if  recovery  is  not
       required  because  no  database state is maintained across
       failures, it is possible to clean up a transaction  region
       by removing all of the files in the directory specified to
       the _D_b_T_x_n_M_g_r_:_:_o_p_e_n method, as transaction region files are
       never  created  in any directory other than the one speci-
       fied to _D_b_T_x_n_M_g_r_:_:_o_p_e_n.  Note, however, that this has  the
       potential  to remove files created by the other DB subsys-
       tems in this database environment.

       The _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k method  throws  a  _D_b_E_x_c_e_p_t_i_o_n(3)  or
       returns the value of _e_r_r_n_o on failure and 0 on success.

  _D_b_T_x_n_M_g_r_:_:_c_h_e_c_k_p_o_i_n_t
       The  _D_b_T_x_n_M_g_r_:_:_c_h_e_c_k_p_o_i_n_t method syncs the underlying mem-
       ory pool, writes a checkpoint record to the log  and  then
       flushes the log.

       If either _k_b_y_t_e or _m_i_n is non-zero, the checkpoint is only
       done if more than _m_i_n minutes have passed since  the  last
       checkpoint,  or  if  more than _k_b_y_t_e kilobytes of log data
       have been written since the last checkpoint.

       The _D_b_T_x_n_M_g_r_:_:_c_h_e_c_k_p_o_i_n_t method throws a _D_b_E_x_c_e_p_t_i_o_n(3) or
       returns  the  value of _e_r_r_n_o on failure, 0 on success, and
       DB_INCOMPLETE if there were pages that needed to be  writ-
       ten  but  that  _D_b_M_p_o_o_l_:_:_s_y_n_c  _(_3_)  (see  _D_b_M_p_o_o_l _(_3_)_) was
       unable to write immediately.  In  this  case,  the  _D_b_T_x_n_-
       _M_g_r_:_:_c_h_e_c_k_p_o_i_n_t call should be retried.

       The   _D_b_T_x_n_M_g_r_:_:_c_h_e_c_k_p_o_i_n_t   method  is  based  on  the  C
       _t_x_n___c_h_e_c_k_p_o_i_n_t function, which is the underlying  function
       used by the _d_b___c_h_e_c_k_p_o_i_n_t(1) utility.  See the source code
       for the _d_b___c_h_e_c_k_p_o_i_n_t utility  for  an  example  of  using
       _t_x_n___c_h_e_c_k_p_o_i_n_t in a UNIX environment.

  _D_b_T_x_n_M_g_r_:_:_s_t_a_t
       The _D_b_T_x_n_M_g_r_:_:_s_t_a_t

       method creates a statistical structure and copies pointers
       to it into user-specified memory locations.

       Statistical structures are created  in  allocated  memory.
       If  _d_b___m_a_l_l_o_c  is  non-NULL,  it is called to allocate the
       memory, otherwise, the library function _m_a_l_l_o_c(3) is used.

       The  function _d_b___m_a_l_l_o_c must match the calling conventions
       of the _m_a_l_l_o_c(3) library routine.  Regardless, the  caller
       is  responsible  for deallocating the returned memory.  To
       deallocate the returned memory, free each returned  memory
       pointer;  pointers  inside  the  memory  do not need to be
       individually freed.


       The transaction region statistics are stored in  a  struc-
       ture  of  type DB_TXN_STAT (typedef'd in <db_cxx.h>).  The
       following DB_TXN_STAT fields will be filled in:

       DbLsn st_last_ckp;
            The LSN of the last checkpoint.
       DbLsn st_pending_ckp;
            The LSN  of  any  checkpoint  that  is  currently  in
            progress.    If   _s_t___p_e_n_d_i_n_g___c_k_p   is   the  same  as
            _s_t___l_a_s_t___c_k_p there is no checkpoint in progress.
       time_t st_time_ckp;
            The time the last completed checkpoint  finished  (as
            returned by _t_i_m_e(2)).
       u_int32_t st_last_txnid;
            The last transaction ID allocated.
       u_int32_t st_maxtxns;
            The  maximum  number of active transactions supported
            by the region.
       u_int32_t st_naborts;
            The number of transactions that have aborted.
       u_int32_t st_nactive;
            The number of transactions that are currently active.
       u_int32_t st_nbegins;
            The number of transactions that have begun.
       u_int32_t st_ncommits;
            The number of transactions that have committed.
       u_int32_t ;
            The  number  of  times  that  a thread of control was
            forced to wait before obtaining the region lock.
       u_int32_t ;
            The number of times that a thread of control was able
            to obtain the region lock without waiting.

       DB_TXN_ACTIVE *st_txnarray;
            A  pointer  to  an  array of _s_t___n_a_c_t_i_v_e DB_TXN_ACTIVE
            structures, describing the currently active  transac-
            tions.   The  following  fields  of the DB_TXN_ACTIVE
            structure (typedef'd in <db_cxx.h>)  will  be  filled
            in:


            u_int32_t txnid;
                 The   transaction   ID  as  returned  by  _D_b_T_x_n_-
                 _M_g_r_:_:_b_e_g_i_n(3).
            DbLsn lsn;
                 The LSN of the transaction-begin record.
EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS
       The following environment variables affect  the  execution
       of _d_b___t_x_n:

       DB_HOME
            If  the _d_b_e_n_v argument to _D_b_T_x_n_M_g_r_:_:_o_p_e_n was initial-
            ized  using  _d_b___a_p_p_i_n_i_t,  the  environment   variable
            DB_HOME  may be used as the path of the database home
            for the interpretation of the _d_i_r argument to  _D_b_T_x_n_-
            _M_g_r_:_:_o_p_e_n, as described in _d_b___a_p_p_i_n_i_t(3).

       TMPDIR
            If  the  _d_b_e_n_v argument to _D_b_T_x_n_M_g_r_:_:_o_p_e_n was NULL or
            not initialized  using  _d_b___a_p_p_i_n_i_t,  the  environment
            variable TMPDIR may be used as the directory in which
            to create the transaction region, as described in the
            _D_b_T_x_n_M_g_r_:_:_o_p_e_n section above.

EERRRROORRSS
       Methods  marked as returning _e_r_r_n_o will, by default, throw
       an exception that encapsulates the error information.  The
       default error behavior can be changed, see _D_b_E_x_c_e_p_t_i_o_n(3).

       The _D_b_T_x_n_M_g_r_:_:_o_p_e_n method may fail and  throw  a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: DbTxnMgr::unlink(3),
       close(2), db_version(3), fcntl(2), fflush(3), lseek(2),
       malloc(3), memcpy(3), memset(3), mmap(2), munmap(2),
       open(2), sigfillset(3), sigprocmask(2), stat(2), str-
       cpy(3), strdup(3), strerror(3), strlen(3), time(3),
       unlink(2), and write(2).

       In  addition, the _D_b_T_x_n_M_g_r_:_:_o_p_e_n method may fail and throw
       a _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for the following  condi-
       tions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The  DB_THREAD  flag  was specified and spinlocks are
            not implemented for this architecture.

            The _d_b_e_n_v parameter was NULL.

       [EAGAIN]
            The shared memory region was locked and  (repeatedly)
            unavailable.

       The  _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n  method may fail and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or return _e_r_r_n_o for any of the errors  specified  for  the
       following DB and library functions: DbLog::put(3),
       fcntl(2), fflush(3), lseek(2), malloc(3), memcpy(3), mem-
       set(3), mmap(2), munmap(2), strerror(3), and write(2).

       In addition, the _D_b_T_x_n_M_g_r_:_:_b_e_g_i_n method may fail and throw
       a _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for the following  condi-
       tions:

       [ENOSPC]
            The  maximum  number  of  concurrent transactions has
            been reached.

       The _D_b_T_x_n_M_g_r_:_:_c_h_e_c_k_p_o_i_n_t method may fail and throw a _D_b_E_x_-
       _c_e_p_t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: DbLog::compare(3),
       DbLog::put(3), DbMpool::sync(3), fcntl(2), fflush(3), mal-
       loc(3), memcpy(3), memset(3), strerror(3), and time(3).

       [EINVAL]
            An invalid flag value or parameter was specified.

       The _D_b_T_x_n_M_g_r_:_:_c_l_o_s_e method may fail and throw  a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: DbLog::flush(3),
       DbTxn::abort(3), close(2), fcntl(2), fflush(3), munmap(2),
       and strerror(3).

       The _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k method may fail and throw a  _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or  return  _e_r_r_n_o  for any of the errors specified for the
       following DB and library functions: close(2), fcntl(2),
       fflush(3), malloc(3), memcpy(3), memset(3), mmap(2), mun-
       map(2), open(2), sigfillset(3), sigprocmask(2), stat(2),
       strcpy(3), strdup(3), strerror(3), strlen(3), and
       unlink(2).

       In addition, the  _D_b_T_x_n_M_g_r_:_:_u_n_l_i_n_k  method  may  fail  and
       throw  a  _D_b_E_x_c_e_p_t_i_o_n(3) or return _e_r_r_n_o for the following
       conditions:

       [EBUSY]
            The shared memory region was in  use  and  the  force
            flag was not set.

       The  _D_b_T_x_n_M_g_r_:_:_s_t_a_t  method  may fail and throw a _D_b_E_x_c_e_p_-
       _t_i_o_n(3)

       or return _e_r_r_n_o for any of the errors  specified  for  the
       following DB and library functions: fcntl(2), and
       malloc(3).

SSEEEE AALLSSOO
       _L_I_B_T_P_: _P_o_r_t_a_b_l_e_,  _M_o_d_u_l_a_r  _T_r_a_n_s_a_c_t_i_o_n_s  _f_o_r  _U_N_I_X,  Margo
       Seltzer, Michael Olson, USENIX proceedings, Winter 1992.

BBUUGGSS
       Nested transactions are not yet implemented.

       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___i_n_t_e_r_n_a_l(3), _d_b___t_h_r_e_a_d(3), _D_b(3), _D_b_c(3), _D_b_E_n_v(3),
       _D_b_E_x_c_e_p_t_i_o_n(3), _D_b_I_n_f_o(3), _D_b_L_o_c_k(3), _D_b_L_o_c_k_T_a_b(3), _D_b_L_o_g(3),
       _D_b_L_s_n(3), _D_b_M_p_o_o_l(3), _D_b_M_p_o_o_l_F_i_l_e(3), _D_b_t(3), _D_b_T_x_n(3),
       _D_b_T_x_n_M_g_r(3)
