

NNAAMMEE
       Dbt - Db key/data class

SSYYNNOOPPSSIISS
       vvooiidd **DDbbtt::::ggeett__ddaattaa(()) ccoonnsstt;;
       vvooiidd DDbbtt::::sseett__ddaattaa((vvooiidd **));;

       uu__iinntt3322__tt DDbbtt::::ggeett__ssiizzee(()) ccoonnsstt;;
       vvooiidd DDbbtt::::sseett__ssiizzee((uu__iinntt3322__tt));;

       uu__iinntt3322__tt DDbbtt::::ggeett__uulleenn(()) ccoonnsstt;;
       vvooiidd DDbbtt::::sseett__uulleenn((uu__iinntt3322__tt));;

       uu__iinntt3322__tt DDbbtt::::ggeett__ddlleenn(()) ccoonnsstt;;
       vvooiidd DDbbtt::::sseett__ddlleenn((uu__iinntt3322__tt));;

       uu__iinntt3322__tt DDbbtt::::ggeett__ddooffff(()) ccoonnsstt;;
       vvooiidd DDbbtt::::sseett__ddooffff((uu__iinntt3322__tt));;

       uu__iinntt3322__tt DDbbtt::::ggeett__ffllaaggss(()) ccoonnsstt;;
       vvooiidd DDbbtt::::sseett__ffllaaggss((uu__iinntt3322__tt));;

       DDbbtt::::DDbbtt((vvooiidd **ddaattaa,, ssiizzee__tt ssiizzee));;
       DDbbtt::::DDbbtt(());;
       DDbbtt::::~~DDbbtt(());;
       DDbbtt::::DDbbtt((ccoonnsstt DDbbtt &&));;
       DDbbtt::::DDbbtt &&ooppeerraattoorr == ((ccoonnsstt DDbbtt &&));;

DDEESSCCRRIIPPTTIIOONN
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see _d_b___i_n_t_r_o(3).  This manual page describes the spe-
       cific  details  of  the _D_b_t class, used to encode keys and
       data items in a database.


KKEEYY//DDAATTAA PPAAIIRRSS
       Storage and retrieval for the Db access methods are  based
       on  key/data  pairs.   Both  key and data items are repre-
       sented by Dbt objects.

       Key and data byte strings may reference strings of  essen-
       tially  unlimited  length,  although any two keys must fit
       into available memory at the same time so that they may be
       compared,  and  any  one data item must fit into available
       memory so that it may be returned.

       The Dbt class provides simple access to an underlying data
       structure, whose elements can be examined or changed using
       the _s_e_t__ or _g_e_t__ methods.  The  remainder  of  the  manual
       page   sometimes   refers  to  these  accesses  using  the
       underlying name, e.g., simply _u_l_e_n instead of _g_e_t___u_l_e_n and
       _s_e_t___u_l_e_n.  The constructors set all elements of the under-
       lying structure to zero.  The constructor with  two  argu-
       ments  has  the  effect  of  setting  all elements to zero
       except for the specified _d_a_t_a and _s_i_z_e elements.   In  the
       case  where  the  _f_l_a_g_s structure element is 0, when being
       provided a key or data item by  the  application,  the  DB
       package  expects the _d_a_t_a object to point to a byte string
       of _s_i_z_e bytes.  When returning  a  key/data  item  to  the
       application,  the  DB  package  will  store  into the _d_a_t_a
       object a pointer to a  byte  string  of  _s_i_z_e  bytes.   BByy
       ddeeffaauulltt,,  tthhee  mmeemmoorryy rreeffeerreenncceedd bbyy tthhiiss ssttoorreedd ppooiinntteerr iiss
       oonnllyy vvaalliidd uunnttiill tthhee nneexxtt ccaallll ttoo tthhee DDBB ppaacckkaaggee uussiinngg tthhee
       DDbb hhaannddllee rreettuurrnneedd bbyy _D_b_:_:_o_p_e_n.

       TThhee aacccceessss mmeetthhooddss pprroovviiddee nnoo gguuaarraanntteeeess aabboouutt bbyyttee ssttrriinngg
       aalliiggnnmmeenntt,, aanndd aapppplliiccaattiioonnss aarree rreessppoonnssiibbllee ffoorr  mmaaiinnttaaiinn--
       iinngg  aannyy nneecceessssaarryy aalliiggnnmmeenntt..  Use the DB_DBT_USERMEM flag
       to cause returned items to be placed in  memory  of  arbi-
       trary  alignment.  Although Java normally maintains proper
       alignment of byte arrays, the  set_offset  method  can  be
       used  to  specify  unaligned addresses.  Unaligned address
       accesses that are not supported by the underlying hardware
       may  be  reported as an exception, or may stop the running
       Java program.

       The elements of the structure underlying the Dbt class are
       defined as follows:

       void *data;
            A pointer to a byte string.  This element is accessed
            using _g_e_t___d_a_t_a and _s_e_t___d_a_t_a, and may  be  initialized
            using one of the constructors.

       int offset;
            The  number  of  bytes  offset into the _d_a_t_a array to
            determine the portion of  the  array  actually  used.
            This   element   is  accessed  using  _g_e_t___o_f_f_s_e_t  and
            _s_e_t___o_f_f_s_e_t.

       u_int32_t size;
            The length  of  _d_a_t_a,  in  bytes.   This  element  is
            accessed using _g_e_t___s_i_z_e and _s_e_t___s_i_z_e, and may be ini-
            tialized using the constructor with two arguments.

       u_int32_t ulen;
            The size of the user's buffer (referenced  by  _d_a_t_a),
            in  bytes.   This  location  is not written by the Db
            functions.  See  the  DB_DBT_USERMEM  flag  for  more
            information.  This element is accessed using _g_e_t___u_l_e_n
            and _s_e_t___u_l_e_n.

       u_int32_t dlen;
            The length  of  the  partial  record  being  read  or
            written  by  the  application,  in  bytes.   See  the
            DB_DBT_PARTIAL flag for more information.  This  ele-
            ment is accessed using _g_e_t___d_l_e_n and _s_e_t___d_l_e_n.

       u_int32_t doff;
            The  offset of the partial record being read or writ-
            ten  by  the  application,   in   bytes.    See   the
            DB_DBT_PARTIAL  flag for more information.  This ele-
            ment is accessed using _g_e_t___d_o_f_f and _s_e_t___d_o_f_f.

       u_int32_t flags;
            This  element  is  accessed   using   _g_e_t___f_l_a_g_s   and
            _s_e_t___f_l_a_g_s.   The  flags  value is specified by oorr'ing
            together one or more of the following values:


            DB_DBT_MALLOC
                 Ignored except when retrieving information  from
                 a  database,  e.g.,  a _D_b_:_:_g_e_t or _D_b_c_:_:_g_e_t call.
                 This flag causes Db to allocate memory  for  the
                 returned  key  or data item (using _m_a_l_l_o_c(3), or
                 the user-specified malloc method) and  return  a
                 pointer  to  it  in the _d_a_t_a field of the key or
                 data Dbt object.  The allocated  memory  becomes
                 the  responsibility  of the calling application.
                 It is an error to specify both DB_DBT_MALLOC and
                 DB_DBT_USERMEM.


            DB_DBT_USERMEM
                 Ignored  except when retrieving information from
                 a database, e.g., a _D_b_:_:_g_e_t  or  _D_b_c_:_:_g_e_t  call.
                 The  _d_a_t_a  field  of the key or data object must
                 reference memory that is at least _u_l_e_n bytes  in
                 length.   If the length of the requested item is
                 less than or equal to that number of bytes,  the
                 item is copied into the memory referenced by the
                 _d_a_t_a field.  Otherwise, an  error  is  returned,
                 the  _s_i_z_e  field is set to the length needed for
                 the requested item, and the  _e_r_r_n_o  variable  is
                 set  to  ENOMEM.  It is an error to specify both
                 DB_DBT_MALLOC and DB_DBT_USERMEM.


            DB_DBT_PARTIAL
                 Ignored except when specified for a data parame-
                 ter,   where   this   flag  causes  the  partial
                 retrieval or storage of an item.  If the calling
                 application  is  doing  a  get,  the  _d_l_e_n bytes
                 starting _d_o_f_f bytes from the  beginning  of  the
                 retrieved  data  record  are returned as if they
                 comprised the entire record.  If any or  all  of
                 the  specified bytes do not exist in the record,
                 the get is successful and the existing bytes  or
                 0 bytes are returned.

                 For  example, if the data portion of a retrieved
                 record was 100 bytes, and  a  partial  retrieval
                 was  done  using a Dbt having a _d_l_e_n field of 20
                 and a _d_o_f_f field of 85, the get call would  suc-
                 ceed, the _d_a_t_a field would reference the last 15
                 bytes of the record, and the _s_i_z_e field would be
                 set to 15.

                 If  the  calling application is doing a put, the
                 _d_l_e_n bytes starting _d_o_f_f bytes from  the  begin-
                 ning  of  the  specified  key's  data record are
                 replaced by the data specified by the  _d_a_t_a  and
                 _s_i_z_e objects.  If _d_l_e_n is smaller than _s_i_z_e, the
                 record will grow, and if  _d_l_e_n  is  larger  than
                 _s_i_z_e,  the record will shrink.  If the specified
                 bytes do not exist, the record will be  extended
                 using  nul  bytes as necessary, and the put call
                 will succeed.

                 It is an error to attempt a  partial  put  using
                 the  _D_b_:_:_p_u_t  method in a database that supports
                 duplicate records.  Partial  puts  in  databases
                 supporting  duplicate records must be done using
                 a _D_b_:_:_c_u_r_s_o_r method.  It is an error to  attempt
                 a  partial put with differing _d_l_e_n and _s_i_z_e val-
                 ues  in  a  recno  database  with   fixed-length
                 records.

                 For  example, if the data portion of a retrieved
                 record was 100 bytes, and a partial put was done
                 using  a  Dbt  having a _d_l_e_n field of 20, a _d_o_f_f
                 field of 85, and a _s_i_z_e field of 30, the result-
                 ing  record  would be 115 bytes in length, where
                 the last 30 bytes would be  those  specified  by
                 the put call.

       The  default algorithm of associating returned key or data
       items with the Db  handle  returned  by  _D_b_:_:_o_p_e_n(3)  will
       obviously  not work when Db handles are being used concur-
       rently by multiple threads within  a  process,  i.e,  when
       DB_THREAD  was  specified  to  _D_b_:_:_o_p_e_n(3).  WWhheenn mmuullttiippllee
       tthhrreeaaddss aarree uussiinngg tthhee  rreettuurrnneedd  DDbb  hhaannddllee  ccoonnccuurrrreennttllyy,,
       eeiitthheerr  tthhee  DDBB__DDBBTT__MMAALLLLOOCC oorr DDBB__DDBBTT__UUSSEERRMMEEMM ffllaaggss mmuusstt bbee
       ssppeecciiffiieedd ffoorr aannyy DDbbtt uusseedd ffoorr kkeeyy oorr ddaattaa rreettrriieevvaall..

LLOOGGIICCAALL RREECCOORRDD NNUUMMBBEERRSS
       In all cases for the recno access method, and when calling
       the  _D_b_:_:_g_e_t  and _D_b_c_:_:_g_e_t functions with the DB_GET_RECNO
       flag specified, the _d_a_t_a

       field of the key must be a pointer to a memory location of
       type  _d_b___r_e_c_n_o___t,  as  typedef'd in the <db_cxx.h> include
       file.  This type is a 32-bit unsigned type, (which  limits
       the number of logical records in a recno database, and the
       maximum logical record which  may  be  directly  retrieved
       from  a btree database, to 4,294,967,296).  The _s_i_z_e field
       of the key should be the size of that type, e.g.,

       in the C programming language, ``sizeof(db_recno_t)''.

       Logical record numbers are 1-based, not 0-based, i.e., the
       first record in the database is record number 1.

BBUUGGSS
       The  Db  access  methods  provide no guarantees about byte
       string alignment, and  applications  are  responsible  for
       maintaining any necessary alignment.

       The  name  Dbt  is a mnemonic for ``data base thang'', and
       was used because noone could think of  a  reasonable  name
       that wasn't already in use somewhere else.

SSEEEE AALLSSOO
       _d_b___a_r_c_h_i_v_e(1), _d_b___c_h_e_c_k_p_o_i_n_t(1), _d_b___d_e_a_d_l_o_c_k(1), _d_b___d_u_m_p(1),
       _d_b___l_o_a_d(1), _d_b___r_e_c_o_v_e_r(1), _d_b___s_t_a_t(1), _d_b___i_n_t_r_o(3),
       _d_b___i_n_t_e_r_n_a_l(3), _d_b___t_h_r_e_a_d(3), _D_b(3), _D_b_c(3), _D_b_E_n_v(3),
       _D_b_E_x_c_e_p_t_i_o_n(3), _D_b_I_n_f_o(3), _D_b_L_o_c_k(3), _D_b_L_o_c_k_T_a_b(3), _D_b_L_o_g(3),
       _D_b_L_s_n(3), _D_b_M_p_o_o_l(3), _D_b_M_p_o_o_l_F_i_l_e(3), _D_b_t(3), _D_b_T_x_n(3),
       _D_b_T_x_n_M_g_r(3)
