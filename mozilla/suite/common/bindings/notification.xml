<?xml version="1.0"?>

<!DOCTYPE bindings [
<!ENTITY % notificationDTD SYSTEM "chrome://global/locale/notification.dtd">
%notificationDTD;
]>

<bindings id="browserNotificationBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="browser-notificationbox"
           extends="chrome://global/content/bindings/notification.xml#notificationbox">
    <implementation implements="nsIObserver, nsIWebProgressListener, nsIDOMEventListener">
      <field name="_stringBundle" readonly="true">
        <![CDATA[
          Components.classes["@mozilla.org/intl/stringbundle;1"]
                    .getService(Components.interfaces.nsIStringBundleService)
                    .createBundle("chrome://communicator/locale/notification.properties");
        ]]>
      </field>

      <field name="_brandStringBundle" readonly="true">
        <![CDATA[
          Components.classes["@mozilla.org/intl/stringbundle;1"]
                    .getService(Components.interfaces.nsIStringBundleService)
                    .createBundle("chrome://branding/locale/brand.properties");
        ]]>
      </field>

      <field name="_prefs" readonly="true">
        <![CDATA[
          Components.classes['@mozilla.org/preferences-service;1']
                    .getService(Components.interfaces.nsIPrefBranch2);
        ]]>
      </field>

      <field name="_activeBrowser">null</field>

      <property name="activeBrowser" readonly="true">
        <getter>
          <![CDATA[
            if (!this._activeBrowser) {
              const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
              var browsers = this.getElementsByTagNameNS(XUL_NS, "browser");
              if (browsers.length == 1) {
                this._activeBrowser = browsers.item(0);
              } else if (browsers.length) {
                for (var i = 0; i < browsers.length; i++) {
                  if (browsers.item(i).docShell) {
                    this._activeBrowser = browsers.item(i);
                    break;
                  }
                }
              }
            }
            return this._activeBrowser;
          ]]>
        </getter>
      </property>

      <field name="_addedProgressListener">false</field>

      <method name="addProgressListener">
        <body>
          <![CDATA[
            if (this.activeBrowser && !this._addedProgressListener) {
              this.activeBrowser.webProgress.addProgressListener(this, Components.interfaces.nsIWebProgress.NOTIFY_LOCATION);
              this._addedProgressListener = true;
            }
          ]]>
        </body>
      </method>

      <method name="onLocationChange">
        <parameter name="aWebProgress" />
        <parameter name="aRequest" />
        <parameter name="aLocation" />
        <body>
          <![CDATA[
            var errorPage = aRequest && !Components.isSuccessCode(aRequest.status);
            if (aWebProgress.DOMWindow == this.activeBrowser.contentWindow &&
                (aWebProgress.isLoadingDocument || errorPage)) {
              this.missingPlugins = {};
              // XXX should be: removeAllNotifications(true) once bug 303327 is fixed
              this.removeAllNotifications(false);
            }
          ]]>
        </body>  
      </method>

      <method name="observe">
        <parameter name="aSubject" />
        <parameter name="aTopic" />
        <parameter name="aData" />
        <body>
          <![CDATA[
            var browser = this.activeBrowser;

            // inactive sidebar panel:
            if (!browser || !browser.docShell)
              return;

            switch (aTopic) {
              case "xpinstall-install-blocked":
                var installInfo = aSubject.QueryInterface(Components.interfaces.nsIXPIInstallInfo);
                if (installInfo.originatingWindow.top != browser.contentWindow)
                  return;

                var notificationName, messageString, buttons, host;
                try {
                  // this fails with nsSimpleURIs like data: URIs
                  host = installInfo.originatingURI.host;
                } catch (ex) {
                  host = this._stringBundle.GetStringFromName("xpinstallHostNotAvailable");
                }

                if (!this._prefs.getBoolPref("xpinstall.enabled")) {
                  notificationName = "xpinstall-disabled";
                  if (this._prefs.prefIsLocked("xpinstall.enabled")) {
                    messageString = this._stringBundle.GetStringFromName("xpinstallDisabledMessageLocked");
                    buttons = [];
                  } else {
                    var prefBranch = this._prefs;
                    messageString = this._stringBundle.GetStringFromName("xpinstallDisabledMessage");
                    buttons = [{
                      label: this._stringBundle.GetStringFromName("xpinstallDisabledButton"),
                      accessKey: this._stringBundle.GetStringFromName("xpinstallDisabledButton.accesskey"),
                      popup: null,
                      callback: function editPrefs() {
                        prefBranch.setBoolPref("xpinstall.enabled", true);
                        return false;
                      }
                    }];
                  }
                } else {
                  notificationName = "xpinstall";
                  var brandShortName = this._brandStringBundle.GetStringFromName("brandShortName");
                  messageString = this._stringBundle.formatStringFromName("xpinstallPromptWarning",
                                                                          [brandShortName, host], 2);
                  buttons = [{
                    label: this._stringBundle.GetStringFromName("xpinstallPromptInstallButton"),
                    accessKey: this._stringBundle.GetStringFromName("xpinstallPromptInstallButton.accesskey"),
                    popup: null,
                    callback: function allowInstall() { 
                      var mgr = Components.classes["@mozilla.org/xpinstall/install-manager;1"]
                                          .createInstance(Components.interfaces.nsIXPInstallManager);
                      mgr.initManagerWithInstallInfo(installInfo);

                      return false;
                    }
                  }];
                }

                if (!this.getNotificationWithValue(notificationName)) {
                  const priority = this.PRIORITY_WARNING_MEDIUM;
                  const iconURL = "chrome://mozapps/skin/xpinstall/xpinstallItemGeneric.png";
                  this.appendNotification(messageString, notificationName,
                                          iconURL, priority, buttons);
                }
                break;

              case "nsPref:changed":
                if (aData == "plugins.hide_infobar_for_missing_plugin") {
                  if (!this._prefs.getBoolPref(aData))
                    return;

                  var pluginNotification = this.getNotificationWithValue("missing-plugins");
                  if (pluginNotification)
                    this.removeNotification(pluginNotification);
                }
                break;
            }
          ]]>
        </body>
      </method>

      <field name="missingPlugins">{}</field>

      <method name="getPluginInfo">
        <parameter name="pluginElement"/>
        <body>
          <![CDATA[
            var mimetype;
            var pluginsPage;
            if (pluginElement instanceof HTMLAppletElement) {
              mimetype = "application/x-java-vm";
            } else {
              if (pluginElement instanceof HTMLObjectElement) {
                pluginsPage = pluginElement.codebase;
              } else {
                pluginsPage = pluginElement.getAttribute("pluginspage");
                if (pluginsPage) {
                  var doc = pluginElement.ownerDocument;
                  var ioService = Components.classes["@mozilla.org/network/io-service;1"]
                                            .getService(Components.interfaces.nsIIOService);
                  pluginsPage = ioService.newURI(pluginsPage, doc.characterSet, doc.documentURIObject).spec;
                }
              }

              mimetype = pluginElement.QueryInterface(Components.interfaces.nsIObjectLoadingContent)
                                      .actualType;

              if (!mimetype) {
                mimetype = pluginElement.type;
              }
            }

            return {mimetype: mimetype, pluginsPage: pluginsPage};
          ]]>
        </body>
      </method>

      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body>
          <![CDATA[
            var missingPlugins = {};
            var pluginInfo = this.getPluginInfo(aEvent.target);
            missingPlugins[pluginInfo.mimetype] = pluginInfo;

            window.openDialog("chrome://mozapps/content/plugins/pluginInstallerWizard.xul",
                              "", "chrome,resizable=yes",
                              {plugins: missingPlugins, browser: this.activeBrowser});
            aEvent.preventDefault();
          ]]>
        </body>
      </method>

      <constructor>
        <![CDATA[
          var os = Components.classes["@mozilla.org/observer-service;1"]
                             .getService(Components.interfaces.nsIObserverService);
          os.addObserver(this, "xpinstall-install-blocked", false);

          this._prefs.addObserver("plugins.hide_infobar_for_missing_plugin", this, false);

          this.addProgressListener();
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          this.destroy();
        ]]>
      </destructor>

      <field name="mDestroyed">false</field>

      <!-- This is necessary because the destructor doesn't always get called when
            we are removed from a tabbrowser. This will be explicitly called by tabbrowser -->
      <method name="destroy">
        <body>
          <![CDATA[
            if (this.mDestroyed)
              return;
            this.mDestroyed = true;

            if (this._addedProgressListener) {
              this.activeBrowser.webProgress.removeProgressListener(this);
              this._addedProgressListener = false;
            }

            this._activeBrowser = null;
            var os = Components.classes["@mozilla.org/observer-service;1"]
                                .getService(Components.interfaces.nsIObserverService);
            try {
              os.removeObserver(this, "xpinstall-install-blocked");
            } catch (ex) {}

            try {
              this._prefs.removeObserver("plugins.hide_infobar_for_missing_plugin", this);
            } catch (ex) {}
          ]]>
        </body>
      </method>
    </implementation>

    <handlers>
      <handler event="PluginNotFound">
        <![CDATA[
          // Since we are expecting also untrusted events, make sure
          // that the target is a plugin
          if (!(event.target instanceof Components.interfaces.nsIObjectLoadingContent))
            return;

          // For broken non-object plugin tags, register a click handler so
          // that the user can click the plugin replacement to get the new
          // plugin. Object tags can, and often do, deal with that themselves,
          // so don't stomp on the page developers toes.

          if (!(event.target instanceof HTMLObjectElement))
            event.target.addEventListener("click", this, false);

          if (this._prefs.getBoolPref("plugins.hide_infobar_for_missing_plugin"))
            return;

          var pluginInfo = this.getPluginInfo(event.target);

          this.missingPlugins[pluginInfo.mimetype] = pluginInfo;

          if (!this.getNotificationWithValue("missing-plugins")) {
            var self = this;
            var messageString = this._stringBundle.GetStringFromName("missingpluginsMessage.title");
            var buttons = [{
              label: this._stringBundle.GetStringFromName("missingpluginsMessage.button.label"),
              accessKey: this._stringBundle.GetStringFromName("missingpluginsMessage.button.accesskey"),
              popup: null,
              callback: function openPluginInstallerWizard() {
                window.openDialog("chrome://mozapps/content/plugins/pluginInstallerWizard.xul",
                                  "", "chrome,resizable=yes",
                                  {plugins: self.missingPlugins, browser: self.activeBrowser});
              }
            }];

            const priority = this.PRIORITY_WARNING_MEDIUM;
            const iconURL = "chrome://mozapps/skin/plugins/pluginGeneric.png";
            this.appendNotification(messageString, "missing-plugins",
                                    iconURL, priority, buttons);
          }
        ]]>
      </handler>

      <handler event="NewPluginInstalled">
        <![CDATA[
          this.missingPlugins = {};

          // clean up the UI after a new plugin has been installed.
          var notification = this.getNotificationWithValue("missing-plugins");
          if (notification)
            this.removeNotification(notification);

          // reload the browser to make the new plugin show.
          this.activeBrowser.reload();
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="sidebar-notification"
           extends="chrome://global/content/bindings/notification.xml#notification">
    <content>
      <xul:vbox class="notification-inner outset" flex="1" xbl:inherits="type">
        <xul:hbox align="center">
          <xul:image anonid="messageImage" class="messageImage" xbl:inherits="src=image"/>
          <xul:spacer flex="1"/>
          <xul:toolbarbutton ondblclick="event.stopPropagation();"
                             class="messageCloseButton tabbable"
                             xbl:inherits="hidden=hideclose"
                             tooltiptext="&closeNotification.tooltip;"
                             oncommand="document.getBindingParent(this).close();"/>
        </xul:hbox>
        <xul:description anonid="messageText" class="messageText" flex="1" xbl:inherits="xbl:text=label"/>
        <xul:hbox anonid="details"
                  oncommand="document.getBindingParent(this)._doButtonCommand(event);">
          <xul:spacer flex="1"/>
          <children/>
        </xul:hbox>
      </xul:vbox>
    </content>
  </binding>
</bindings>
