<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is SeaMonkey prefwindow code.
   -
   - The Initial Developer of the Original Code is the SeaMonkey project.
   - Portions created by the Initial Developer are Copyright (C) 2007
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   Karsten DÃ¼sterloh <mnyromyr@tprac.de>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!--
    SeaMonkey Extended Preferences Window Framework

    The binding implemented here mostly works like its toolkit ancestor, with
    one important difference: the <prefwindow> recognizes the first <tree> in
    its content and assumes that this is the navigation tree:

      <prefwindow>
        <tree>
          ...
          <treeitem id="prefTreeItemA" prefpane="prefPaneA">
          ...
        </tree>
        <prefpane id="prefPaneB">...</prefpane>
        <prefpane id="prefPaneA">
      </prefwindow>

    The <tree> structure defines the hierarchical layout of the preference
    window's navigation tree. A <treeitem>'s "prefpane" attribute references
    one of the <prefpane>s given on the <prefwindow>'s main level.
    All <prefpane>s not referenced by a <treeitem> will be appended to the
    navigation tree's top level. <treeitem>s can be nested as needed, but
    <treeitem>s without a related <prefpane> will be hidden.

    <prefwindow> users who want to share the very same file between SeaMonkey
    and other toolkit apps should hide the <tree> (set <tree>.hidden=true);
    this binding will then unhide the <tree> if necessary, ie more than just
    one <prefpane> exists.
    Also, the <tree> will get the class "prefnavtree" added, so that it may be
    prestyled by the SeaMonkey themes.
    Setting <prefwindow xpfe="false"> will enforce the application of just the
    basic toolkit <prefwindow> even in SeaMonkey.
-->

<!DOCTYPE bindings [
  <!ENTITY % dtd1 SYSTEM "chrome://communicator/locale/pref/pref.dtd"> %dtd1;
  <!ENTITY % dtd2 SYSTEM "chrome://communicator-platform/locale/pref/platformPrefOverlay.dtd"> %dtd2;
  <!ENTITY % dtd3 SYSTEM "chrome://global/locale/preferences.dtd"> %dtd3;
]>

<bindings id="prefwindowBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="prefwindow"
           extends="chrome://global/content/bindings/preferences.xml#prefwindow">

    <!-- The only difference between the following <content> and its toolkit
         ancestor is the 'navTrees' <vbox> before the 'paneDeck'! -->
    <content dlgbuttons="accept,cancel" persist="lastSelected screenX screenY"
             closebuttonlabel="&preferencesCloseButton.label;"
             closebuttonaccesskey="&preferencesCloseButton.accesskey;"
             xmlns:xhtml="http://www.w3.org/1999/xhtml"
             xhtml:role="dialog"
#ifdef XP_WIN
             title="&preferencesDefaultTitleWin.title;"
#else
             title="&preferencesDefaultTitleMac.title;"
#endif
    >
      <xul:radiogroup anonid="selector" orient="horizontal" class="paneSelector chromeclass-toolbar"
                      xhtml:role="listbox"/> <!-- Expose to accessibility APIs as a listbox -->
      <xul:hbox flex="1" class="paneDeckContainer">
        <xul:vbox anonid="navTrees">
          <children includes="tree"/>
        </xul:vbox>
        <xul:vbox flex="1">
          <xul:dialogheader anonid="paneHeader"/>
          <xul:deck anonid="paneDeck" flex="1">
            <children includes="prefpane"/>
          </xul:deck>
        </xul:vbox>
      </xul:hbox>
      <xul:hbox anonid="dlg-buttons" class="prefWindow-dlgbuttons">
#ifdef XP_UNIX
        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
        <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
        <xul:spacer anonid="spacer" flex="1"/>
        <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
        <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
#else
        <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
        <xul:spacer anonid="spacer" flex="1"/>
        <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
        <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
        <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
        <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
        <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
#endif
      </xul:hbox>
      <xul:hbox>
        <children/>
      </xul:hbox>
    </content>

    <implementation>

      <constructor>
        <![CDATA[
          // grab the first child tree and try to tie it to the prefpanes
          var tree = this.getElementsByTagName('tree')[0];
          this.initNavigationTree(tree);
          // hide the toolkit pref strip if we have a tree
          if (this._navigationTree)
            this._selector.hidden = true;
        ]]>
      </constructor>

      <field name="_navigationTree">null</field>

      <!-- <prefwindow> users can call this method to exchange the <tree> -->
      <method name="initNavigationTree">
        <parameter name="aTreeElement"/>
        <body>
        <![CDATA[
          this._navigationTree = null;
          if (!aTreeElement)
            return;

          // don't grab trees in prefpanes etc.
          if (aTreeElement.parentNode != this)
            return;

          // don't bother with a navigation tree if we only have one prefpane
          aTreeElement.hidden = (this.preferencePanes.length < 2);
          if (aTreeElement.hidden)
            return;
          this._navigationTree = aTreeElement;

          // add the class "prefnavtree", so that themes can set defaults
          this._navigationTree.className += ' prefnavtree';

          // tie the <treeitem>s to the corresponding <prefpane>s
          var treeitems = this._navigationTree.getElementsByTagName('treeitem');
          for (var i = 0; i < treeitems.length; ++i)
          {
            var node = treeitems[i];
            var pane = document.getElementById(node.getAttribute('prefpane'));
            node.prefpane = pane;
            if (pane)
              pane.preftreeitem = node;
            // hide unused treeitems
            node.hidden = !pane;
          }

          // ensure that we have a tree body (before checking for columns)
          if (!this._navigationTree.body)
            this._navigationTree.appendChild(document.createElement('treechildren'));

          // ensure that we have a tree column
          if (!this._navigationTree.columns.count)
          {
            var navcols = document.createElement('treecols');
            var navcol  = document.createElement('treecol');
            navcol.setAttribute('id', 'navtreecol');
            navcol.setAttribute('primary', true);
            navcol.setAttribute('flex', 1);
            navcol.setAttribute('hideheader', true);
            navcols.appendChild(navcol);
            this._navigationTree.appendChild(navcols);
            this._navigationTree.setAttribute('hidecolumnpicker', true);
          }

          // append any still unreferenced <prefpane>s to the tree's top level
          for (var i = 0; i < this.preferencePanes.length; ++i)
          {
            // toolkit believes in fancy pane resizing - we don't
            var pane = this.preferencePanes[i];
            pane.setAttribute('flex', 1);
            if (!("preftreeitem" in pane))
            {
              var treeitem = document.createElement('treeitem');
              var treerow  = document.createElement('treerow');
              var treecell = document.createElement('treecell');
              var label = pane.getAttribute('label');
              if (!label)
                label = pane.getAttribute('id');
              treecell.setAttribute('label', label);
              treerow.appendChild(treecell);
              treeitem.appendChild(treerow);
              this._navigationTree.body.appendChild(treeitem);
              treeitem.prefpane = pane;
              pane.preftreeitem = treeitem;
            }
          }

          // some of the toolkit base binding's select events fire before we
          // get here, so we may need to sync the tree manually now
          if (this.currentPane && this.currentPane.loaded)
            this.syncTreeWithPane(this.currentPane);
        ]]>
        </body>
      </method>

      <!-- don't do any fancy animations -->
      <property name="_shouldAnimate" onget="return false;"/>

      <method name="setPaneTitle">
        <parameter name="aPaneElement"/>
        <body>
        <![CDATA[
          // show pane title, if given
          var paneHeader = document.getAnonymousElementByAttribute(this, 'anonid', 'paneHeader');
          var paneHeaderLabel = '';
          if (aPaneElement)
            paneHeaderLabel = aPaneElement.getAttribute('label');
          paneHeader.hidden = !paneHeaderLabel;
          if (!paneHeader.hidden)
            paneHeader.setAttribute('title', paneHeaderLabel);
        ]]>
        </body>
      </method>

      <method name="syncPaneWithTree">
        <parameter name="aTreeIndex"/>
        <body>
        <![CDATA[
          var pane = null;
          if ((this._navigationTree) && (aTreeIndex >= 0))
          {
            // load the prefpane associated with this treeitem
            var treeitem = this._navigationTree.contentView
                               .getItemAtIndex(aTreeIndex);
            if ('prefpane' in treeitem)
            {
              pane = treeitem.prefpane;
              this.showPane(pane);
            }
          }
          this.setPaneTitle(pane);
        ]]>
        </body>
      </method>

      <method name="syncTreeWithPane">
        <parameter name="aPane"/>
        <body>
        <![CDATA[
          if (this._navigationTree && aPane)
          {
            if ('preftreeitem' in aPane)
            {
              // make sure the treeitem is visible
              var container = aPane.preftreeitem.parentNode.parentNode;
              while (container != this._navigationTree)
              {
                container.setAttribute('open', true);
                container = container.parentNode.parentNode;
              }

              // mark selected pane in navigation tree
              var index = this._navigationTree.contentView
                              .getIndexOfItem(aPane.preftreeitem);
              this._navigationTree.view.selection.select(index);
            }
          }
          this.setPaneTitle(aPane);
        ]]>
        </body>
      </method>

    </implementation>

    <handlers>

      <handler event="select">
      <![CDATA[
        // navigation tree select or deck change?
        var target = event.originalTarget;
        if (target == this._navigationTree)
        {
          this.syncPaneWithTree(target.currentIndex);
        }
        else if (target == this._paneDeck)
        {
          // deck.selectedIndex is a string!
          var pane = this.preferencePanes[Number(target.selectedIndex)];
          this.syncTreeWithPane(pane);
        }
      ]]>
      </handler>

      <handler event="paneload">
      <![CDATA[
        // panes may load asynchronously,
        // so we have to "late-sync" those to our navigation tree
        this.syncTreeWithPane(event.originalTarget);
      ]]>
      </handler>

    </handlers>

  </binding>
</bindings>
