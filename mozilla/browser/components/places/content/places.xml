<?xml version="1.0"?>

<bindings id="placesBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
  
  <!-- XXXben - replace this upon checkin by allowing generic textboxes to show
                arbitrary content before the html:input itself using a 
                <children/> -->
  <binding id="textbox-timed-arbitrary" 
           extends="chrome://global/content/bindings/textbox.xml#timed-textbox">
    <content>
      <children/>
      <xul:hbox class="textbox-input-box" flex="1" xbl:inherits="context">
        <html:input class="textbox-input" flex="1" anonid="input"
                    xbl:inherits="onfocus,onblur,value,type,maxlength,disabled,size,readonly,tabindex,accesskey"/>
      </xul:hbox>
    </content>
  </binding>
  
  <binding id="places-tree" extends="chrome://global/content/bindings/tree.xml#tree">
    <implementation implements="nsINavHistoryResultViewObserver">
      <constructor><![CDATA[
        this._places = 
          Cc["@mozilla.org/browser/nav-history;1"].
          getService(Ci.nsINavHistory);
        
        // Let's all do the happy QI/IRQ dance. 
        // Go from window->docshell->window.
        window.QueryInterface(Ci.nsIInterfaceRequestor);
        var shell = window.getInterface(Ci.nsIWebNavigation);
        shell.QueryInterface(Ci.nsIDocShell);
        var item = shell.QueryInterface(Ci.nsIDocShellTreeItem);
        while (item.parent)
          item = item.parent;
        item.QueryInterface(Ci.nsIInterfaceRequestor);
        this._browserWindow = item.getInterface(Ci.nsIDOMWindowInternal);
        
        this._bms = 
          Cc["@mozilla.org/browser/nav-bookmarks-service;1"].
          getService(Ci.nsINavBookmarksService);
        this._bms.addObserver(this._bookmarkObserver);
      ]]></constructor>
      
      <destructor><![CDATA[ 
        this._bms.removeObserver(this._bookmarkObserver);
      ]]></destructor>
      
      <method name="_fireEvent">
        <parameter name="name"/>
        <body><![CDATA[ 
          var event = document.createEvent("events");
          event.initEvent("placestree-" + name, false, true);
          
          var canceled = !this.dispatchEvent(event);
          
          var handler = this.getAttribute("onplacestree" + name);
          if (handler != "") {
            var fn = new Function("event", handler);
            if (!fn(event))
              canceled = true;
          }
          return !canceled;
        ]]></body>
      </method>
      
      <!-- AVI Method -->
      <method name="getResult">
        <body><![CDATA[
          try {
            return this.view.QueryInterface(Ci.nsINavHistoryResult);
          }
          catch (e) {
          }
        ]]></body>
      </method>
      
      <!-- overriding -->
      <property name="view">
        <getter><![CDATA[
          return this.treeBoxObject.view;
        ]]></getter>
        <setter><![CDATA[ 
          // Make sure the last result doesn't hold a reference to us anymore
          var result = this.getResult();
          if (result)
            result.removeObserver(this._viewObserver);
          this.treeBoxObject.view = val;
          this.getResult().addObserver(this._viewObserver);          
        ]]></setter>        
      </property>
      
      <method name="getBestOptions">
        <body><![CDATA[
          // Get the best set of grouping options to use, either reuse the 
          // existing ones or create new ones. 
          var options = this.getResult().sourceQueryOptions;
          if (!options)
            options = this._places.getNewQueryOptions();
          return options;
        ]]></body>
      </method>
      
      <property name="filterString">
        <getter><![CDATA[
          var queries = this.getResult().getSourceQueries({ });
          if (queries[i].hasSearchTerms)
            return queries[i].searchTerms;
          return null;
        ]]></getter>
        <setter><![CDATA[
          var query = this._places.getNewQuery();
          query.searchTerms = val;
          
          this.load([query], this.getBestOptions());
          return val;
        ]]></setter>
      </property>
      
      <method name="applyFilter">
        <parameter name="filterString"/>
        <parameter name="onlyBookmarks"/>
        <parameter name="folderRestrict"/>
        <body><![CDATA[ 
          // preserve grouping
          var options = this.getResult().sourceQueryOptions;
          if (!options)
            options = this._places.getNewQueryOptions();
          
          var query = this._places.getNewQuery();
          query.searchTerms = filterString;
          query.onlyBookmarked = onlyBookmarks;
          //if (onlyBookmarks)
          //  query.setFolders(folderRestrict, folderRestrict.length);
          this.load([query], this.getBestOptions());
        ]]></body>
      </method>
    
      <property name="queryString">
        <getter><![CDATA[
          var result = this.getResult();
          var queries = result.getSourceQueries({ });
          var options = result.sourceQueryOptions;

          const NH = Ci.nsINavHistory;
          return this._places.queriesToQueryString(queries, queries.length,
                                                  options);
        ]]></getter>
        <setter><![CDATA[
          var queries = { }, options = { };
          this._places.queryStringToQueries(val, queries, { }, options);
          if (!queries.value.length) 
            queries.value = [this._places.getNewQuery()];
          this.load(queries.value, options.value);
          return val;
        ]]></setter>
      </property>
      
      <method name="loadFolder">
        <parameter name="folderId"/>
        <parameter name="filterOptions"/>
        <body><![CDATA[ 
          var filterOptions = filterOptions || this._bms.ALL_CHILDREN;
          var result = this._bms.getFolderChildren(folderId, filterOptions);
          result.QueryInterface(Ci.nsITreeView);
          this.view = result;
          this._lastFilterOptions = filterOptions;
          this._fireEvent("reloaded");
        ]]></body>
      </method>
      
      <method name="load">
        <parameter name="queries"/>
        <parameter name="options"/>
        <body><![CDATA[ 
          var result = this._places.executeQueries(queries, queries.length, 
                                                   options);
          result.QueryInterface(Ci.nsITreeView);
          this.view = result;
          this._fireEvent("reloaded");
        ]]></body>
      </method>
    
      <!-- AVI Method -->
      <property name="hasSelection">
        <getter><![CDATA[
          return this.view.selection.count >= 1;
        ]]></getter>
      </property>
      
      <!-- AVI Method -->
      <property name="hasSingleSelection">
        <getter><![CDATA[
          return this.view.selection.count == 1;
        ]]></getter>
      </property>
      
      <!-- AVI Method -->
      <method name="getSelectionNodes">
        <body><![CDATA[ 
          var selection = this.view.selection;
          var rc = selection.getRangeCount();
          var nodes = [];
          var result = this.getResult();
          for (var i = 0; i < rc; ++i) {
            var min = { }, max = { };
            selection.getRangeAt(i, min, max);
            
            for (var j = min.value; j <= max.value; ++j)
              nodes.push(result.nodeForTreeIndex(j));
          }
          return nodes;
        ]]></body>
      </method>
      
      <!-- AVI Method -->
      <method name="getCopyableSelection">
        <body><![CDATA[ 
          // XXXben implement me!
          return this.getSelectionNodes();
        ]]></body>
      </method>
      
      <!-- AVI Method -->
      <property name="selectedNode">
        <getter><![CDATA[
          var view = this.view;
          var selection = view.selection;
          var rc = selection.getRangeCount();
          if (rc != 1) 
            return null;
          var min = { }, max = { };
          selection.getRangeAt(0, min, max);
          
          return this.getResult().nodeForTreeIndex(min.value);
        ]]></getter>
      </property>
      
      <!-- AVI Method -->
      <property name="selectedURLNode">
        <getter><![CDATA[
          var view = this.view;
          var selection = view.selection;
          var rc = selection.getRangeCount();
          if (rc != 1) 
            return null;
          var min = { }, max = { };
          selection.getRangeAt(0, min, max);
          
          // Cannot load containers
          if (view.isContainer(min.value) || view.isSeparator(min.value))
            return null;
            
          return this.getResult().nodeForTreeIndex(min.value);
        ]]></getter>
      </property>
      
      <!-- AVI Method -->
      <property name="insertionPoint">
        <getter><![CDATA[ 
          var view = this.view;
          var selection = view.selection;
          var rc = selection.getRangeCount();
          var min = { }, max = { };
          selection.getRangeAt(rc - 1, min, max);

          var result = this.getResult();
          var container = result;
          // When there's no selection, assume the container is the container
          // the view is populated from (i.e. the result's folderId).
          if (max.value != -1) {
            var lastSelected = result.nodeForTreeIndex(max.value);
            if (view.isContainer(max.value) && view.isContainerOpen(max.value)) {
              // If the last selected item is an open container, append _into_
              // it, rather than insert adjacent to it. 
              container = lastSelected;
              max.value = -1;
            }
            else {
              // Any visible selected item will always have a parent. The parent of
              // an item at the root is the result itself, which can be QI'ed to 
              // nsINavHistoryResult
              container = lastSelected.parent;
              for (var i = 0; 
                   i < container.childCount && container.getChild(i) != lastSelected;
                   ++i);
              max.value = i < container.childCount ? i + 1 : i;
            }
          }
          return { container: container.folderId, index: max.value };
        ]]></getter>
      </property>
      
      <!-- AVI Method -->
      <property name="browserWindow" onget="return this._browserWindow"/>
      
      <!-- AVI Method -->
      <field name="supportedDropTypes">null</field>
      
      <!-- AVI Method -->
      <field name="supportedDropOnTypes">null</field>
      
      <!-- AVI Method -->
      <method name="selectAll">
        <body><![CDATA[ 
          this.view.selection.selectAll();
        ]]></body>
      </method>
      
      <field name="_DNDObserver"><![CDATA[({
        // XXXben ew.
        _self: this,
        onDragStart: function TV_DO_onDragStart(event, xferData, dragAction) {
          if (this._self.getAttribute("sortActive") == "true")
            throw Components.results.NS_OK;
          xferData.data = PlacesController.getTransferData();
          // XXXben - the drag wrapper should do this automatically. 
          if (event.ctrlKey)
            dragAction.action = Ci.nsIDragService.DRAGDROP_ACTION_COPY;
        },
        canDrop: function TV_DO_canDrop(event, session) {
          return this._self._viewObserver.canDrop(-1, -1);
        },
        onDragOver: function TV_DO_onDragOver(event, flavor, session) {
        },
        getSupportedFlavours: function TV_DO_getSupportedFlavours() {
          var flavorSet = new FlavourSet();
          for (var i = 0; i < this._self.supportedDropTypes.length; ++i)
            flavorSet.appendFlavour(this._self.supportedDropTypes[i]);
          return flavorSet;
        },
      })]]></field>
      
      <field name="_viewObserver"><![CDATA[({
        _self: this,
        
        canDrop: function VO_canDrop(index, orientation) {
          return PlacesControllerDragHelper.canDrop(this._self, orientation);
        },
        
        onDrop: function VO_onDrop(index, orientation) {
          LOG("VO: onDrop: " + index + ", orientation: " + orientation);
          
          // We are responsible for translating the |index| and |orientation| 
          // parameters into a container id and index within the container, 
          // since this information is specific to the tree view. 
          const NHRVO = Ci.nsINavHistoryResultViewObserver;
          var result = this._self.getResult();
          var view = this._self.view;
          var node = index != -1 ? result.nodeForTreeIndex(index) : null;
          var destContainer = null;
          var destIndex = -1;
          if (!node) {
            // Dropping in some blank area of the view, just use the result as
            // the container.
            destContainer = result.folderId;
          }
          else if (view.isContainer(index) && orientation == NHRVO.DROP_ON) {
            // If we're dropping _on_ a container, the container is the 
            // container we dropped on, otherwise it's the parent of the drop 
            // target. 
            destContainer = node.folderId;
          }
          else {
            var destIndex = PlacesController.getIndexOfNode(node);
            // For non leaves, or when not dropping _on_ a container, drop after
            // by default (i.e. when dropping after a container, or ON AND AFTER
            // a leaf node).
            if (orientation != NHRVO.DROP_BEFORE)
              ++destIndex;
            destContainer = node.parent.folderId;
          }
          PlacesControllerDragHelper.onDrop(this._self, destContainer, 
                                            destIndex, orientation);
        },
        
        // XXXben we will probably have to implement this to refresh Live 
        //        Bookmarks.
        onToggleOpenState: function VO_onToggleOpenState(index) { },
        onCycleHeader: function VO_onCycleHeader(column) { },
        onCycleCell: function VO_onCycleCell(row, column) { },
        onSelectionChanged: function VO_onSelectionChanged() { },
        onPerformAction: function VO_onPerformAction(action) { },
        onPerformActionOnRow: function VO_onPerformActionOnRow(action, row) { },
        onPerformActionOnCell: function VO_onPerformActionOnCell(action, row, column) { },      
      })]]></field>
      
      <method name="_reloadView">
        <body><![CDATA[ 
          var result = this.getResult();
          if (PlacesController.nodeIsFolder(result))
            this.loadFolder(result.folderId, this._lastFilterOptions);
          else
            this.load(result.getSourceQueries({ }), result.sourceQueryOptions);
        ]]></body>
      </method>
      
      <!-- nsINavBookmarkObserver -->
      <field name="_bookmarkObserver"><![CDATA[({
        _numBatches: 0,
        _self: this,
        onBeginUpdateBatch: function PT_O_onBeginUpdateBatch() {
          ++this._numBatches;
        },
        onEndUpdateBatch: function PT_O_onEndUpdateBatch() {
          if (!--this._numBatches)
            this._self._reloadView();
        },
        get wantAllDetails() { 
          return false;
        },
        onItemAdded: function PT_O_onItemAdded(bookmark, folder, index) {
          this._self._reloadView();
        },
        onItemRemoved: function PT_O_onItemRemoved(bookmark, folder, index) {
          this._self._reloadView();
        },
        onItemMoved: function PT_O_onItemMoved(bookmark, folder, oldIndex, newIndex) {
          this._self._reloadView();
        },
        onItemChanged: function PT_O_onItemChanged(bookmark, property) {
          this._self._reloadView();
        },
        onFolderAdded: function PT_O_onFolderAdded(folder, parent, index) {
          this._self._reloadView();
        },
        onFolderRemoved: function PT_O_onFolderRemoved(folder, parent, index) {
          this._self._reloadView();
        },
        onFolderMoved: function PT_O_onFolderMoved(folder, oldParent, oldIndex, newParent, newIndex) {
          this._self._reloadView();
        },
        onFolderChanged: function PT_O_onFolderChanged(folder, property) {
          this._self._reloadView();
        },
      })]]></field>
      
    </implementation>
    <handlers>
      <handler event="focus"><![CDATA[
        PlacesController.activeView = this;
        document.commandDispatcher.updateCommands("focus");
      ]]></handler>
      <handler event="select"><![CDATA[
        document.commandDispatcher.updateCommands("select");
      ]]></handler>
      <handler event="click"><![CDATA[
        if (this.getAttribute("singleclick") == "true") {
          var view = this.view;
          var selection = view.selection;
          var rc = selection.getRangeCount();
          if (rc != 1) 
            return null;
          var min = { };
          selection.getRangeAt(0, min, { });
          if (!view.isContainerEmpty(min.value))
            view.toggleOpenState(min.value);
        }
      ]]></handler>
      <handler event="draggesture"><![CDATA[
        // XXXben ew.
        if (event.target.localName == "treechildren")
          nsDragAndDrop.startDrag(event, this._DNDObserver);
      ]]></handler>
      <handler event="dragover"><![CDATA[
        if (event.target.localName == "treechildren")
          nsDragAndDrop.dragOver(event, this._DNDObserver);
      ]]></handler>
    </handlers>
  </binding>
  
  <binding id="command-button" extends="chrome://global/content/bindings/button.xml#button">
    <implementation>
      <method name="updateActiveView">
        <body><![CDATA[ 
          if (this.hasAttribute("view"))
            PlacesController.activeView = document.getElementById(this.getAttribute("view"));
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="click" button="0" action="this.updateActiveView();"/>
      <handler event="keypress" keycode="VK_SPACE" action="this.updateActiveView();"/>
    </handlers>
  </binding>
  
  <binding id="filter-button" extends="chrome://global/content/bindings/button.xml#menu">
    <handlers>
      <handler event="command"><![CDATA[
        PlacesPage.setFilterCollection(event.target.getAttribute("value"));
      ]]></handler>
    </handlers>
  </binding>

  <binding id="calendar">
    <content>
      <xul:vbox class="calendar-box">
        <xul:hbox class="calendar-header">
          <xul:label anonid="prevmonth" class="calendar-month-jump">&#xab;</xul:label>
          <xul:label anonid="monthtitle" class="calendar-month-title" flex="1"/>
          <xul:label anonid="nextmonth" class="calendar-month-jump">&#xbb;</xul:label>
        </xul:hbox>
        <xul:tooltip anonid="calendartooltip">
          <!-- FIXME -->
        </xul:tooltip>
        <xul:grid anonid="calendargrid" class="calendar-grid">
         <xul:columns><xul:column flex="1"/><xul:column flex="1"/><xul:column flex="1"/><xul:column flex="1"/><xul:column flex="1"/><xul:column flex="1"/><xul:column flex="1"/></xul:columns>
          <xul:rows>
            <xul:row class="calendar-day-header">
              <xul:label anonid="calendarhead0"></xul:label>
              <xul:label anonid="calendarhead1"></xul:label>
              <xul:label anonid="calendarhead2"></xul:label>
              <xul:label anonid="calendarhead3"></xul:label>
              <xul:label anonid="calendarhead4"></xul:label>
              <xul:label anonid="calendarhead5"></xul:label>
              <xul:label anonid="calendarhead6"></xul:label>
            </xul:row>
            <!-- The "00" is so that the table has the correct dimensions (most
                 numbers are the same width) when it is first displayed. The
                 default definition for "calendar-day" should have the same color
                 fore- and background so you won't see this. -->
            <xul:row>
              <xul:label anonid="calendar0" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar1" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar2" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar3" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar4" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar5" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar6" class="calendar-day" tooltip="calendartooltip">00</xul:label>
            </xul:row>
            <xul:row>
              <xul:label anonid="calendar7" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar8" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar9" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar10" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar11" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar12" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar13" class="calendar-day" tooltip="calendartooltip">00</xul:label>
            </xul:row>
            <xul:row>
              <xul:label anonid="calendar14" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar15" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar16" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar17" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar18" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar19" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar20" class="calendar-day" tooltip="calendartooltip">00</xul:label>
            </xul:row>
            <xul:row>
              <xul:label anonid="calendar21" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar22" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar23" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar24" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar25" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar26" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar27" class="calendar-day" tooltip="calendartooltip">00</xul:label>
            </xul:row>
            <xul:row>
              <xul:label anonid="calendar28" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar29" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar30" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar31" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar32" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar33" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar34" class="calendar-day" tooltip="calendartooltip">00</xul:label>
            </xul:row>
            <xul:row>
              <xul:label anonid="calendar35" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar36" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar37" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar38" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar39" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar40" class="calendar-day" tooltip="calendartooltip">00</xul:label>
              <xul:label anonid="calendar41" class="calendar-day" tooltip="calendartooltip">00</xul:label>
            </xul:row>
          </xul:rows>
        </xul:grid>
      </xul:vbox>
    </content>
    <implementation>
      <constructor><![CDATA[
        var grid = document.getAnonymousElementByAttribute(this, "anonid",
                                                           "calendargrid");
        this._numCells = 42; // max number of cells displayable in the calendar
        this._cellPrefix = "calendar"; // value before the number in the ID of cells

        this._currentMonth = -1;
        this._currentYear = -1;
        this._cell0Date = null; // date for top left of calendar
        this._selectBegin = null;
        this._selectEnd = null;

        // localized stuff, FIXME: move somewhere else
        this._pref_firstDayOfWeek = 0; // 0 = Sunday, 1 = Monday
        this._pref_dayHeaders = ["S", "M", "T", "W", "T", "F", "S"];
        this._pref_shortMonthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        // day headers
        for (var i = 0; i < 7; i ++) {
          var cell = document.getAnonymousElementByAttribute(this, "anonid",
                                                             "calendarhead" + i);
          cell.value = this._pref_dayHeaders[i];
        }

        // cell item
        var calendargrid = document.getAnonymousElementByAttribute(this, "anonid", "calendargrid");
        this._days = new Array(this._numCells);
        this._selected = new Array(this._numCells);
        for (var i = 0; i < this._numCells; i ++) {
          this._days[i] = document.getAnonymousElementByAttribute(this, "anonid", this._cellPrefix + i);
          this._selected[i] = false;
        }

        // month navigation hooks
        var myself = this;
        document.getAnonymousElementByAttribute(this, "anonid", "prevmonth").
          addEventListener("click", function() { myself.jumpMonth(-1); }, false);
        document.getAnonymousElementByAttribute(this, "anonid", "nextmonth").
          addEventListener("click", function() { myself.jumpMonth(1); }, false);

        // day selection hooks
        calendargrid.addEventListener("mousedown", function(event) { myself.mouseDown(event); }, false);
        calendargrid.addEventListener("mouseup", function(event) { myself.mouseUp(event); }, false);
        calendargrid.addEventListener("mousemove", function(event) { myself.mouseMove(event); }, false);

        this.visibleMonth = new Date(); // today
      ]]></constructor>

      <property name="visibleMonth">
        <getter>
          return new Date(this._visibleMonth);
        </getter>
        <setter>
          this._visibleMonth = new Date(val.getFullYear(), val.getMonth(), 1);
          this.drawMonth();
        </setter>
      </property>

      <property name="beginrange">
        <getter>
          if (! this._selectBegin)
            return null;
          else
            return new Date(this._selectBegin);
        </getter>
        <setter>
          this._selectBegin = val;
          updateSelection();
          fireRangeEvent();
        </setter>
      </property>
      <property name="endrange">
        <getter>
          if (! this._selectEnd)
            return null;
          else
            return new Date(this._selectEnd);
        </getter>
        <setter>
          this._selectEnd = val;
          updateSelection();
          fireRangeEvent();
        </setter>
      </property>

      <!--===== jumpMonth =====-->
      <method name="jumpMonth">
        <parameter name="relative"/>
        <body><![CDATA[
          var newMonth = this._visibleMonth.getMonth() + relative;
          var newYear = this._visibleMonth.getFullYear() + Math.floor(newMonth / 12);
          newMonth = (newMonth + 12) % 12;
          this._visibleMonth = new Date(newYear, newMonth, 1);
          this.drawMonth();
        ]]></body>
      </method>

      <!--===== mouseDown =====-->
      <method name="mouseDown">
        <parameter name="event"/>
        <body><![CDATA[
          var date = this.cellToDate(event.target.getAttribute("anonid"));
          if (! date)
            return;
          this._dragging = true;
          this._mouseDownOn = date;
          this.updateSelection(date, date);
        ]]></body>
      </method>

      <!--===== mouseUp =====-->
      <method name="mouseUp">
        <parameter name="event"/>
        <body><![CDATA[
          this._dragging = false;
          this.fireRangeEvent();
        ]]></body>
      </method>

      <!--===== mouseMove =====-->
      <method name="mouseMove">
        <parameter name="event"/>
        <body><![CDATA[
          if (! this._dragging)
            return;
          var date = this.cellToDate(event.target.getAttribute("anonid"));
          if (! date)
            return;
          this.updateSelection(this._mouseDownOn, date);
        ]]></body>
      </method>

      <!--===== updateSelection =====-->
      <method name="updateSelection">
        <parameter name="begin"/>
        <parameter name="end"/>
        <body><![CDATA[
          var realBegin = begin;
          var realEnd = end;
          if (begin && end && begin.getTime() > end.getTime()) {
            this._selectBegin = end;
            this._selectEnd = begin;
          } else {
            this._selectBegin = begin;
            this._selectEnd = end;
          }
          this.drawSelection();
        ]]></body>
      </method>

      <!--===== daysBetweenDates =====-->
      <method name="daysBetweenDates">
        <parameter name="a"/>
        <parameter name="b"/>
        <body>
          var msDiff = a.getTime() - b.getTime();
          return Math.floor(msDiff / 86400000); // 1000ms/s * 60s/m * 60m/h * 24h/d = 86400000ms/d
        </body>
      </method>

      <!--===== fireRangeEvent =====-->
      <method name="fireRangeEvent"><body><![CDATA[
        var event = document.createEvent("Events");
        event.initEvent("selectionchanged", false, true);

        // handle dom event handlers
        var noCancel = this.dispatchEvent(event);

        // handle any xml attribute event handlers
        var handler = this.getAttribute("onselectionchanged");
        if (handler != "") {
          var fn = new Function("event", handler);
          var returned = fn(event);
          if (returned == false)
            noCancel = false;
        }
        return noCancel;
      ]]></body></method>

      <!--===== drawSelection =====-->
      <method name="drawSelection"><body><![CDATA[
        var beginIndex;
        if (! this._selectBegin) {
          beginIndex = 0;
        } else {
          beginIndex = this.daysBetweenDates(this._selectBegin, this._cell0Date);
        }
        var endIndex;
        if (! this._selectEnd) {
          endIndex = this._numCells - 1;
        } else {
          endIndex = this.daysBetweenDates(this._selectEnd, this._cell0Date);
        }

        for (var i = 0; i < this._numCells; i ++) {
          var sel = (i >= beginIndex && i <= endIndex);
          if (sel != this._selected[i]) {
            this._days[i].setAttribute("selected", sel ? "true" : "");
            this._selected[i] = sel;
          }
        }
      ]]></body></method>

      <!--===== cellToDate =====-->
      <method name="cellToDate">
        <parameter name="cellName"/>
        <body><![CDATA[
          if (! cellName)
            return null;
          var tail = cellName.substring(this._cellPrefix.length);
          if (tail[0] < "0" || tail[0] > '9') {
            return null;
          }
          var cellNumber = Number(tail);
          var d = new Date(this._cell0Date);
          d.setDate(d.getDate() + cellNumber);
          return d;
        ]]></body>
      </method>

      <!--===== drawMonth =====-->
      <method name="drawMonth"><body><![CDATA[

        var curCell = 0;
        var monthIndex = this._visibleMonth.getMonth();
        var yearNumber = this._visibleMonth.getFullYear();
        var firstOfMonth = new Date(yearNumber, monthIndex, 1);

        // update title
        document.getAnonymousElementByAttribute(this, "anonid", "monthtitle").value =
          this._pref_shortMonthNames[monthIndex] + " " + yearNumber;

        // first, fill in any days of the previous month in the first week
        var numPrefixDays = firstOfMonth.getDay() - this._pref_firstDayOfWeek;
        var curDay = firstOfMonth;
        curDay.setDate(firstOfMonth.getDate() - numPrefixDays);
        this._cell0Date = new Date(curDay); // save the first cell
        for (var i = 0; i < numPrefixDays; i ++) {
          var cell = document.getAnonymousElementByAttribute(this, "anonid", this._cellPrefix + curCell);
          cell.setAttribute("month", "other");
          cell.value = curDay.getDate();
          curCell ++;
          curDay.setDate(curDay.getDate() + 1);
        }

        // now fill in the rest of this month
        while (curDay.getMonth() == monthIndex) {
          var cell = document.getAnonymousElementByAttribute(this, "anonid", this._cellPrefix + curCell);
          cell.setAttribute("month", "this");
          cell.value = curDay.getDate();
          curCell ++;
          curDay.setDate(curDay.getDate() + 1);
        }

        // fill out the end of this week with next month
        while (curDay.getDay() != this._pref_firstDayOfWeek) {
          var cell = document.getAnonymousElementByAttribute(this, "anonid", this._cellPrefix + curCell);
          cell.setAttribute("month", "other");
          cell.value = curDay.getDate();
          curCell ++;
          curDay.setDate(curDay.getDate() + 1);
        }

        // fill the bottom row with days from the next month
        while (curCell < this._numCells) {
          var cell = document.getAnonymousElementByAttribute(this, "anonid", this._cellPrefix + curCell);
          cell.setAttribute("month", "other");
          cell.value = curDay.getDate();
          curCell ++;
          curDay.setDate(curDay.getDate() + 1);
        }

        this.drawSelection();
      ]]></body></method>

    </implementation>
  </binding> <!-- end calendar -->

  
</bindings>
