/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 *
 * The contents of this file are subject to the Netscape Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is mozilla.org code.
 *
 * The Initial Developer of the Original Code is Netscape
 * Communications Corporation.  Portions created by Netscape are
 * Copyright (C) 1998 Netscape Communications Corporation. All
 * Rights Reserved.
 *
 * Contributor(s): 
 */
 
#include "nsISupports.idl"
#include "nsIFolder.idl"
#include "nsIMsgThread.idl"
#include "nsIMsgIncomingServer.idl"
#include "nsIFileSpec.idl"
#include "nsISupportsArray.idl"
#include "nsIMsgCopyServiceListener.idl"
#include "nsIUrlListener.idl"
#include "nsIEnumerator.idl"

%{ C++
#include "nsIMsgDatabase.h"
#include "nsMsgKeyArray.h"
%}

interface nsIMessage;
interface nsIMsgWindow;
interface nsIMsgDatabase;
interface nsIDBFolderInfo;
interface nsMsgKeyArray;
interface nsIMsgFilterList;

interface nsIMsgFolderCacheElement;
interface nsAutoString;
interface nsIFileChannel;

typedef long nsMsgBiffState;
// enumerated type for determining if a message has been replied to, forwarded, etc.
typedef long nsMsgDispositionState;

[scriptable, uuid(85e39ff0-b248-11d2-b7ef-00805f05ffa5)]
interface nsIMsgFolder : nsIFolder {

const nsMsgBiffState nsMsgBiffState_NewMail = 0; // User has new mail waiting.
const nsMsgBiffState nsMsgBiffState_NoMail =  1; // No new mail is waiting.
const nsMsgBiffState nsMsgBiffState_Unknown = 2; // We dunno whether there is new mail.


  /* already exists in nsIFolder */
  /*	readonly attribute string name;   */
  /*	void SetName(in string name); */


  /* XXX should these 2 go on nsIFolder or nsICollection? */
  void AddUnique(in nsISupports element);
  void ReplaceElement(in nsISupports element, in nsISupports newElement);
  
  nsISimpleEnumerator getMessages(in nsIMsgWindow aMsgWindow);
  nsISimpleEnumerator getThreadsOfType(in nsIMsgWindow aMsgWindow, in unsigned long viewType);
  boolean hasThreads(in nsIMsgWindow aMsgWindow);
  boolean hasMessagesOfType(in nsIMsgWindow aMsgWindow, in unsigned long viewType);
  
  void startFolderLoading();
  void endFolderLoading();
  
	/* get new headers for db */
	void updateFolder(in nsIMsgWindow aWindow);
  
	nsIMsgThread getThreadForMessage(in nsIMessage message);
	boolean hasMessage(in nsIMessage message);
  
  nsIEnumerator getVisibleSubFolders();
	readonly attribute wstring prettiestName;

  /**
   * URL for this folder
   */
  readonly attribute string folderURL;

  /**
   * should probably move to the server
   */
	attribute boolean deleteIsMoveToTrash;
  
  /**
   * should probably move to the server
   */
	readonly attribute boolean showDeletedMessages;

  /**
   * this folder's parent server
   */
  readonly attribute nsIMsgIncomingServer server;

  /**
   * is this folder the "phantom" server folder?
   */
  readonly attribute boolean isServer;
  readonly attribute boolean canSubscribe;
  readonly attribute boolean canFileMessages;
  readonly attribute boolean noSelect;

  /**
   * does this folder allow subfolders?
   * for example, newsgroups cannot have subfolders, and the INBOX
   * on some IMAP servers cannot have subfolders
   */
  readonly attribute boolean canCreateSubfolders;

  /**
   * can you change the name of this folder?
   * for example, newsgroups
   * and some special folders can't be renamed
   */
  readonly attribute boolean canRename;

  /**
   * the phantom server folder
   */
	readonly attribute nsIMsgFolder rootFolder;

  /* filter for this folder */
  readonly attribute nsIMsgFilterList filterList;
  
	void ForceDBClosed ();
	void Delete ();

	void deleteSubFolders(in nsISupportsArray folders, in nsIMsgWindow msgWindow);
	void propagateDelete(in nsIMsgFolder folder, in boolean deleteStorage);
	void recursiveDelete(in boolean deleteStorage);

	void createSubfolder(in wstring folderName, in nsIMsgWindow msgWindow);
  [noscript] nsIMsgFolder addSubfolder(in nsAutoString folderName);
	/* this method ensures the storage for the folder exists.
		For local folders, it creates the berkeley mailbox if missing.
		For imap folders, it subscribes to the folder if it exists,
		or creates it if it doesn't exist
	*/
	void createStorageIfMissing(in nsIUrlListener urlListener);
  
  void compact(in nsIUrlListener aListener);
  void emptyTrash(in nsIMsgWindow aMsgWindow, in nsIUrlListener aListener);

  /**
   * change the name of the folder
   *
   * @param name the new name of the folder
   */
	void rename(in wstring name, in nsIMsgWindow msgWindow);
	void adopt(in nsIMsgFolder srcFolder, out unsigned long outPos);

  /**
   * looks in immediate children of this folder for the given name
   *
   * @param name the name of the target subfolder
   */
	boolean containsChildNamed(in string name);
	boolean isAncestorOf(in nsIMsgFolder folder);

	string generateUniqueSubfolderName(in string prefix,
                                     in nsIMsgFolder otherFolder);

	void updateSummaryTotals(in boolean force);
	void summaryChanged();
  /**
   * get the total number of unread messages in this folder,
   * or in all subfolders
   *
   * @param deep if true, descends into all subfolders and gets a grand total
   */  
	long getNumUnread(in boolean deep);

  /**
   * get the total number of messages in this folder,
   * or in all subfolders
   *
   * @param deep if true, descends into all subfolders and gets a grand total
   */  
	long getTotalMessages(in boolean deep);

 /**
  * does this folder have new messages
  *
  */
	//boolean hasNewMessages();
	attribute boolean hasNewMessages;

  /**
   * return the first new message in the folder
   *
   */
    readonly attribute nsIMessage firstNewMessage;

  /**
   * clear new status flag of all of the new messages
   *
   */
    void clearNewMessages();

	readonly attribute unsigned long expungedBytes;


  /**
   * can this folder be deleted?
   * for example, special folders cannot be deleted
   */
	readonly attribute boolean deletable;

  /**
   * should we be displaying recipients instead of the sender?
   * for example, in the Sent folder, recipients are more relevant
   * than the sender
   */
	readonly attribute boolean displayRecipients;

  /**
   * used to determine if it will take a long time to download all
   * the headers in this folder - so that we can do folder notifications
   * synchronously instead of asynchronously
   */
	boolean manyHeadersToDownload();

	readonly attribute boolean requiresCleanup;
	void clearRequiresCleanup();

  /**
   * this should go into a news-specific interface
   */
	readonly attribute boolean knowsSearchNntpExtension;
  
  /**
   * this should go into a news-specific interface
   */
	readonly attribute boolean allowsPosting;

	readonly attribute string relativePathName;

  /**
   * size of this folder (including headers??) on disk
   */
	readonly attribute unsigned long sizeOnDisk;

  /**
   * set the password for this folder (what is this used for?)
   */
	void rememberPassword(in string password);
	readonly attribute string rememberedPassword;
	boolean userNeedsToAuthenticateForFolder(in boolean displayOnly);
  	readonly attribute string username;
  	readonly attribute string hostname;

	void setFlag(in unsigned long flag);
	void clearFlag(in unsigned long flag);
	boolean getFlag(in unsigned long flag);
  void setPrefFlag();

	void toggleFlag (in unsigned long flag);
	void onFlagChange (in unsigned long flag);
  
	attribute unsigned long flags;

  void RecursiveSetDeleteIsMoveToTrash(in boolean bVal);

	nsIMsgFolder getFoldersWithFlag(in unsigned long flags,
                         in unsigned long resultsize, out unsigned long numFolders);

	void getExpansionArray(in nsISupportsArray expansionArray);

	void deleteMessages(in nsISupportsArray message,
                      in nsIMsgWindow msgWindow,
                      in boolean deleteStorage, in boolean isMove);

  void copyMessages(in nsIMsgFolder srcFolder, in nsISupportsArray messages,
                    in boolean isMove, in nsIMsgWindow msgWindow,
                    in nsIMsgCopyServiceListener listener);

  void copyFileMessage(in nsIFileSpec fileSpec, in nsIMessage msgToReplace,
                       in boolean isDraft, in nsIMsgWindow msgWindow,
                       in nsIMsgCopyServiceListener listener);

  void acquireSemaphore (in nsISupports semHolder);
  void releaseSemaphore (in nsISupports semHolder);
  boolean testSemaphore (in nsISupports semHolder);
  readonly attribute boolean locked;

	nsIMessage createMessageFromMsgDBHdr(in nsIMsgDBHdr msgDBHdr);
	void getNewMessages(in nsIMsgWindow aWindow);

  /**
   * write out summary data for this folder
   * to the given folder cache (i.e. panacea.dat)
   */
	void writeToFolderCache(in nsIMsgFolderCache folderCache, in boolean deep);

  /**
   * the charset of this folder
   */
	attribute wstring charset;
	attribute boolean charsetOverride;
	attribute unsigned long biffState;

  /**
   * the number of new messages since this folder was last visited
   */
	attribute long numNewMessages;

  /**
   * verbose description of the new messages in this folder
   */
	readonly attribute wstring newMessagesNotificationDescription;

	// are we running a url as a result of the user clicking get msg?
	attribute boolean gettingNewMessages;
  /**
   * local path of this folder
   */
	attribute nsIFileSpec path;

	const nsMsgDispositionState nsMsgDispositionState_Replied = 0;
	const nsMsgDispositionState nsMsgDispositionState_Forwarded = 1;	
	void addMessageDispositionState(in nsIMessage aMessage, in nsMsgDispositionState aDispositionFlag);

	void markMessagesRead(in nsISupportsArray messages, in boolean markRead);
	void markAllMessagesRead();
	void markMessagesFlagged(in nsISupportsArray messages, in boolean markFlagged);
	void markThreadRead(in nsIMsgThread thread);
    nsIMsgDatabase getMsgDatabase(in nsIMsgWindow msgWindow);
    nsIMsgDatabase getDBFolderInfoAndDB(out nsIDBFolderInfo folderInfo);
  nsIMsgDBHdr GetMessageHeader(in nsMsgKey msgKey);
  boolean shouldStoreMsgOffline(in nsMsgKey msgKey);
  boolean hasMsgOffline(in nsMsgKey msgKey);
  nsIFileChannel getOfflineFileChannel(in nsMsgKey msgKey);
  void DownloadMessagesForOffline(in nsISupportsArray messages);        
	nsIMsgFolder getChildWithURI(in string uri, in boolean deep);
  void downloadAllForOffline(in nsIUrlListener listener, in nsIMsgWindow window);
	/**
	 *	Turn notifications on/off for various notification types. Currently only supporting
	 *  allMessageCountNotifications which refers to both total and unread message counts.
	 */
	const unsigned long allMessageCountNotifications    = 0;

	void enableNotifications(in long notificationType, in boolean enable);

  attribute nsIMsgRetentionSettings retentionSettings;

};
