<?xml version="1.0"?>

<bindings   id="mailBindings"
            xmlns="http://www.mozilla.org/xbl"
            xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
            xmlns:xbl="http://www.mozilla.org/xbl">

  <!-- dummy widget to force this file to load -->
  <binding id="dummy" extends="xul:box"/>
 
  <!-- Message Pane Widgets -->

  <!-- mail-toggle-headerfield: non email addrss headers which have a toggle associated with them (i.e. the subject). 
       use label to set the header name.
       use headerValue to set the header value. -->
  <binding id="mail-toggle-headerfield">
    <content>
      <xul:hbox class="headerNameBox" align="start">
          <xul:image class="expandHeaderViewButton" xbl:inherits="onclick=ontwistyclick"/>
          <xul:spacer flex="1"/>
        <xul:label class="headerName" xbl:inherits="value=label"/>  
      </xul:hbox>
      <xul:textbox class="headerValue plain" anonid="headerValue" flex="1" readonly="true"/>
    </content>

    <implementation>      
      <property name="headerValue" onset="return document.getAnonymousElementByAttribute(this, 'anonid', 'headerValue').value = val;"/>
    </implementation>
  </binding>

  <!-- mail-headerfield: presents standard text header name & value pairs. Don't use this for email addresses. 
       use label to set the header name.
       use headerValue to set the header value. -->
  <binding id="mail-headerfield">
    <content>
      <xul:hbox class="headerNameBox" align="start">
        <xul:label class="headerName" xbl:inherits="value=label" flex="1"/>
      </xul:hbox>
      <xul:textbox class="headerValue plain" anonid="headerValue" flex="1" readonly="true"/> 
    </content>

    <implementation>      
      <property name="headerValue" onset="return document.getAnonymousElementByAttribute(this, 'anonid', 'headerValue').value = val;"/>  
    </implementation>
  </binding>

  <binding id="mail-emailheaderfield">
    <content>
      <xul:hbox class="headerNameBox" align="start">
        <xul:label class="headerName" xbl:inherits="value=label" flex="1"/>
        </xul:hbox>
        <xul:mail-emailaddress anonid="emailAddressNode"/>
    </content>

    <implementation>
      <property name="emailAddressNode" onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'emailAddressNode');"
        readonly="true"/>
    </implementation>
  </binding>
  
  <!-- multi-emailHeaderField: presents multiple emailheaderfields with a toggle -->
  <binding id="mail-multi-emailHeaderField">
    <content>
      <xul:hbox class="headerNameBox" align="start" pack="end">
        <xul:image class="addresstwisty" anonid="toggleIcon"
                   onclick="toggleAddressView();"/>
        <xul:label class="headerName" xbl:inherits="value=label"/>
        </xul:hbox>

        <xul:label class="headerValue" anonid="emailAddresses" flex="1"/>
        <xul:label class="headerValue" anonid="longEmailAddresses" flex="1" collapsed="true"/>
    </content>

    <implementation>
      <constructor>
        <![CDATA[
          this.mLongViewCreated = false;
          this.mAddresses = new Array;
        ]]>
      </constructor>

      <field name="mLongViewCreated"/>
      <field name="mAddresses"/>
      <!-- as a perf optimization we are going to keep a cache of email address nodes which we've
           created around for the lifetime of the widget. mSizeOfAddressCache controls how many of these
           elements we keep around -->
      <field name="mSizeOfAddressCache">3</field>
      
      <!-- addAddressView: a public method used to add an address to this widget. 
           aAddresses is an object with 3 properties: displayName, emailAddress and fullAddress
      -->
      <method name="addAddressView">
        <parameter name="aAddress"/>
        <body>
          <![CDATA[
            this.mAddresses.push(aAddress);
          ]]>
        </body>
      </method>
      
      <!-- updateEmailAddressNode: private method used to set properties on an address node -->
      <method name="updateEmailAddressNode">
        <parameter name="aEmailNode"/>
        <parameter name="aAddress"/>
        <body>
          <![CDATA[
            aEmailNode.setAttribute("label", aAddress.fullAddress);    
            aEmailNode.setTextAttribute("emailAddress", aAddress.emailAddress);
            aEmailNode.setTextAttribute("fullAddress", aAddress.fullAddress);  
            aEmailNode.setTextAttribute("displayName", aAddress.displayName);

            try
            {
              if ("AddExtraAddressProcessing" in top)
                AddExtraAddressProcessing(aAddress.emailAddress, aEmailNode);
            }
            catch(ex)
            {
              dump("AddExtraAddressProcessing failed: " + ex);
            }
          ]]>
        </body>
      </method>

      <!-- fillCachedAddresses: private method used to fill up any cached pre-existing
           emailAddress fields without creating new email address fields. Returns a remainder
           for the # of addresses which require new addresses being created.
           Invariants: 1) aNumAddressesToShow >= 0 && it is <= mAddresses.length -->
      <method name="fillCachedAddresses">
        <parameter name="aAddressesNode"/>
        <parameter name="aNumAddressesToShow"/>
        <body>
          <![CDATA[
            var numExistingCachedAddresses = aAddressesNode.childNodes.length;
            if (!numExistingCachedAddresses) 
              return this.mAddresses.length; // we couldn't pre fill anything
            else if (numExistingCachedAddresses > 1)
              numExistingCachedAddresses = (numExistingCachedAddresses + 1)/ 2;
            
            var index = 0; 
            var numAddressesAdded = 0;
            var emailAddressNode;
            var commaNode;
            while (numAddressesAdded < numExistingCachedAddresses && numAddressesAdded < aNumAddressesToShow)
            {
              if (index && numExistingCachedAddresses > 1)
              {
                commaNode = aAddressesNode.childNodes[index++];
                if (commaNode)
                  commaNode.removeAttribute('collapsed');
              }

              // get the node pointed to by index
              emailAddressNode = aAddressesNode.childNodes[index++];
              this.updateEmailAddressNode(emailAddressNode, this.mAddresses[numAddressesAdded]);
              emailAddressNode.removeAttribute('collapsed');
              numAddressesAdded++;
            }

            // if we have added all of our elements but we still have more cached items in this address node
            // then make sure the extra cached copies are collapsed...
            numExistingCachedAddresses = aAddressesNode.childNodes.length;  // reset
            while (index < numExistingCachedAddresses)
            {
              aAddressesNode.childNodes[index++].setAttribute('collapsed', true);
            }

            return this.mAddresses.length - numAddressesAdded;
          ]]>
        </body>
      </method>

      <!-- fillAddressesNode: private method used to create email address nodes for either our short
           or long view. aAddressesNode: the div we want to add addresses too. 
          aNumAddressesToShow: number of addresses to put into the list -->
      <method name="fillAddressesNode">
        <parameter name="aAddressesNode"/>
        <parameter name="aNumAddressesToShow"/>
        <body>
          <![CDATA[
            var numAddresses = this.mAddresses.length;
            if (aNumAddressesToShow <= 0 || aNumAddressesToShow > numAddresses)  // then show all
              aNumAddressesToShow = numAddresses;

            // before we try to create email address nodes, try to leverage any cached nodes...
            var remainder = this.fillCachedAddresses(aAddressesNode, aNumAddressesToShow);
            var index = numAddresses - remainder; 
            while (index < numAddresses && index < aNumAddressesToShow)
            {
              var newAddressNode = document.createElement("mail-emailaddress");
              if (index)
              {
                var textNode = document.createElement("text");
                textNode.setAttribute("value", ", ");
                textNode.setAttribute("class", "emailSeparator");
                aAddressesNode.appendChild(textNode);
              }              
              
              var itemInDocument = aAddressesNode.appendChild(newAddressNode);
              this.updateEmailAddressNode(itemInDocument, this.mAddresses[index]);
              index++;
            }
          ]]>
        </body>
      </method>

      <property name="emailAddresses" onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'emailAddresses');"
        readonly="true"/>
      <property name="longEmailAddresses" onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'longEmailAddresses');"
        readonly="true"/> 
      <property name="toggleIcon" onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'toggleIcon');"
        readonly="true"/>

      <!-- buildView: public method used by callers when they are done adding all the email addresses to the widget
           aNumAddressesToShow: total # of addresses to show in the short view -->
      <method name="buildViews">
        <parameter name="aNumAddressesToShow"/>
        <body>
          <![CDATA[
            // always build the short view...its cheap...
            this.fillAddressesNode(this.emailAddresses, aNumAddressesToShow);
            // if we are currently toggled to show all the email addresses, build the long one too...
            if (this.emailAddresses.collapsed)
              this.buildLongView();

            // make sure the icon is always visible if we have more than the # of addresses to show     
            this.toggleIcon.collapsed = this.mAddresses.length <= aNumAddressesToShow;
          ]]> 
        </body>
      </method>
            
      <!-- buildLongView: private method used for delayed construction of the long view -->
      <method name="buildLongView">
        <body>
          <![CDATA[
            if (!this.mLongViewCreated)
            {
              this.fillAddressesNode(this.longEmailAddresses, -1);
              this.mLongViewCreated = true;
            }
          ]]> 
        </body>
      </method>

      <method name="toggleAddressView">
        <body>
          <![CDATA[
          var shortNode = this.emailAddresses;
          var longNode = this.longEmailAddresses;
          var imageNode = this.toggleIcon;
          // test to see which if short is already collapsed...
          if (shortNode.collapsed)
          {
            longNode.collapsed = true;
            shortNode.collapsed = false;
            imageNode.removeAttribute("open");
          }
          else
          {
            this.buildLongView();
            shortNode.collapsed = true;
            longNode.collapsed = false;
            imageNode.setAttribute("open", "true");

            if (!this.mLongViewCreated)
            {
              // Need to call UpdateMessageHeaders() because this is the first
              // time the long view is being built.  This is required in order
              // to update the addresses of the long view that might contain
              // extra image info.
              // It should also only be called from toggleAddressView(), not
              // from buildView().
              UpdateMessageHeaders();
            }
          }
          ]]>  
        </body>
      </method>
      
      <!-- internal method used to clear both our divs -->
      <method name="clearChildNodes">
        <parameter name="aParentNode"/>
        <body>
          <![CDATA[
            // we want to keep around the first mSizeOfAddressCache email address nodes
            // don't forget that we have comma text nodes in there too so really we want to keep
            // around cache size * 2 - 1.
            var numItemsToPreserve = this.mSizeOfAddressCache * 2 - 1;
            var numItemsInNode = aParentNode.childNodes.length;

            while (numItemsInNode && (numItemsInNode > numItemsToPreserve))
            { 
              aParentNode.removeChild(aParentNode.childNodes[numItemsInNode-1]);
              numItemsInNode = numItemsInNode - 1;
            }
          ]]>       
        </body>
      </method>

      <method name="clearEmailAddresses">
        <body>
          <![CDATA[
            // clear out our local state
            this.mAddresses = new Array; 
            this.mLongViewCreated = false;

            // remove anything inside of each of our labels....
            var parentLabel = this.emailAddresses;
            if (parentLabel)
              this.clearChildNodes(parentLabel);
            parentLabel = this.longEmailAddresses;
            if (parentLabel)
              this.clearChildNodes(parentLabel);             
          ]]>
        </body>
      </method>       
    </implementation>
  </binding>

  <binding id="mail-emailaddress">
    <content popup="emailAddressPopup" context="emailAddressPopup">
      <xul:label anonid="emailValue" class="emailDisplayButton plain"                 
                 xbl:inherits="value=label,crop"/>
      <xul:image class="emailDisplayImage" anonid="emailImage"
                 context="emailAddressPopup" xbl:inherits="src=image"/>
    </content>
    
    <implementation>  
      <property name="label"      onset="this.getPart('emailValue').setAttribute('label',val); return val;"
                                  onget="return this.getPart('emailValue').getAttribute('label');"/>
      <property name="crop"       onset="this.getPart('emailValue').setAttribute('crop',val); return val;"
                                  onget="return this.getPart('emailValue').getAttribute('crop');"/>
      <property name="disabled"   onset="this.getPart('emailValue').setAttribute('disabled',val); return val;"
                                  onget="return this.getPart('emailValue').getAttribute('disabled');"/>
      <property name="src"        onset="this.getPart('emailImage').setAttribute('src',val); return val;"
                                  onget="return this.getPart('emailImage').getAttribute('src');"/>
      <property name="imgalign"   onset="this.getPart('emailImage').setAttribute('imgalign',val); return val;"
                                  onget="return this.getPart('emailImage').getAttribute('imgalign');"/>

      <method name="getPart">
        <parameter name="aPartId"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this, "anonid", aPartId);
        ]]></body>
      </method>

      <method name="setTextAttribute">
        <parameter name="attributeName"/>
        <parameter name="attributeValue"/>
        <body><![CDATA[
          this.setAttribute(attributeName, attributeValue);
          this.getPart("emailImage").setAttribute(attributeName, attributeValue);          
          this.getPart("emailValue").setAttribute(attributeName, attributeValue);          
        ]]></body>
      </method>

      <method name="getTextAttribute">
        <parameter name="attributeName"/>
        <body><![CDATA[   
          return this.getPart("emailValue").getAttribute(attributeName);
        ]]></body>
      </method>

      <method name="GetIconNode">
        <body><![CDATA[
          return this.getPart("emailImage");
        ]]></body>
      </method>
    </implementation>
  </binding>
</bindings>
