<?xml version="1.0"?>

<bindings   id="mailBindings"
            xmlns="http://www.mozilla.org/xbl"
            xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
  
  <binding id="search-menulist-abstract" extends="xul:box">
    <content>
      <xul:menulist inherits="flex" oncommand="this.parentNode.onSelect(event)">
        <xul:menupopup/>
      </xul:menulist>
    </content>

    <interface>
      <property readonly="true" name="validityManager">
        <![CDATA[
           Components.classes['mozilla.mail.search.validityManager.1'].getService(Components.interfaces.nsIMsgSearchValidityManager);
        ]]>
      </property>
      <property name="searchScope">
        <!-- scope ID - retrieve the table -->
        <setter>
          <![CDATA[
            this.internalScope = val;
            this.refreshList();
            var targets = this.targets;
            if (targets) {
              for (var i=0; i< targets.length; i++) {
                dump("searchScopeSet: targets[" + i + "] = " + targets[i] + "\n")
                targets[i].searchScope = val;
              }
            }
            dump("done\n");
          ]]>
        </setter>
        <getter>
          <![CDATA[
            return this.internalScope;
          ]]>
        </getter>
      </property>

      <property name="validityTable" readonly="true" onget="return this.validityManager.getTable(this.searchScope)"/>

      <property name="valueStrings" readonly="true">
        <getter>
          <![CDATA[
            var strings = new Array;
            var ids = this.valueIds;
            var bundle = this.stringBundle;
            for (var i=0; i<ids.length; i++)
                strings[i] = this.stringBundle.GetStringFromID(ids[i]);
            return strings;
          ]]>
        </getter>
      </property>
      <property name="targets" readonly="true">
        <getter>
          <![CDATA[
            var forAttrs =  this.getAttribute("for");
            if (!forAttrs) return null;
            var targetIds = forAttrs.split(",");
            if (targetIds.length == 0) return null;

            var targets = new Array;
            var j=0;
            for (var i=0; i<targetIds.length;i++) {
              var target = document.getElementById(targetIds[i]);
              if (target) targets[j++] = target;
              if (!target) dump("Bad target " + i + ": " + targetIds[i] + "\n");
            }
            return targets;
          ]]>
        </getter>
      </property>
      <method name="refreshList">
        <body>
          <![CDATA[
            dump("refreshing <" + this.tagName + ">\n");
            var menuItemIds = this.valueIds;
            var menuItemStrings = this.valueStrings;

            var menulist = this.anonymousContent[0];
            var popup = menulist.firstChild;

            // save our old "data" so we can restore it later
            var oldData = menulist.data;

            // remove the old popup children
            while (popup.hasChildNodes())
              popup.removeChild(popup.lastChild);

            var newSelection;
            for (var i=0; i<menuItemIds.length; i++) {
              // create the menuitem
              var menuitem = document.createElement("menuitem");
              menuitem.setAttribute("value", menuItemStrings[i]);
              menuitem.setAttribute("data", menuItemIds[i]);
              popup.appendChild(menuitem);

              // try to restore the selection
              if (!newSelection || oldData == menuItemIds[i].toString()) {
                newSelection = menuitem;
              }
            }

            // now restore the selection
            menulist.selectedItem = newSelection
          ]]>
        </body>
      </method>
      <method name="onSelect">
        <argument name="event"/>
        <body>
          <![CDATA[
            dump("onSelect!\n");
            var menulist = this.anonymousContent[0];

            // notify targets
            var targets = this.targets;
            if (targets) {
              dump("There are " + targets.length + " targets\n");
              for (var i=0; i< targets.length; i++) {
                dump("onSelect: targets[" + i + "] = " + targets[i] + "\n");
                targets[i].parentValue = menulist.data;
              }
            }
          ]]>
        </body>
      </method>
    </interface>
    <handler type="command" value="dump('onCommand!\n');"/>
  </binding>

  <!-- searchattribute - Subject, Sender, To, CC, etc. -->
  <binding id="searchattribute"
           extends="chrome://messenger/skin/mailWidgets.xml#search-menulist-abstract">
    <interface>
      <property name="stringBundle">
          <![CDATA[
           srGetStrBundle("chrome://messenger/locale/search-attributes.properties");
          ]]>
      </property>
      <property name="valueIds" readonly="true">
        <getter>
          <![CDATA[
            var length = new Object;
            return this.validityTable.getAvailableAttributes(length);
          ]]>
        </getter>
      </property>
    </interface>
  </binding>

  <!-- searchoperator - Contains, Is Less than, etc -->
  <binding id="searchoperator"
           extends="chrome://messenger/skin/mailWidgets.xml#search-menulist-abstract">
    <interface>
      <property name="stringBundle">
          <![CDATA[
            srGetStrBundle("chrome://messenger/locale/search-operators.properties");
          ]]>
      </property>
      <property name="valueIds" readonly="true">
        <getter>
          <![CDATA[
            var length = new Object;
            return this.validityTable.getAvailableOperators(this.searchAttribute,length);
          ]]>
        </getter>
      </property>
      <property name="parentValue">
        <setter>
          <![CDATA[
            this.searchAttribute = val;
            this.refreshList();
          ]]>
        </setter>
        <getter>
          <![CDATA[
            return this.searchAttribute;
          ]]>
        </getter>
      </property>
    </interface>
  </binding>

  <!-- searchvalue - a widget which dynamically changes it's user interface
       depending on what type of data it's supposed to be showing
       currently handles arbitrary text entry, and menulists for priority and
       status
  -->
  <binding id="searchvalue" extends="xul:deck">
    <!-- yeah yeah, this stuff needs to be localized. I'm working on it! -->
    <content>
      <xul:textfield flex="1" />
      <xul:menulist flex="1" >
        <xul:menupopup>
          <xul:menuitem value="Lowest"/>
          <xul:menuitem value="Low"/>
          <xul:menuitem value="Normal"/>
          <xul:menuitem value="High"/>
          <xul:menuitem value="Highest"/>
        </xul:menupopup>
      </xul:menulist>
      <xul:menulist flex="1" >
        <xul:menupopup>
          <xul:menuitem value="read"/>
          <xul:menuitem value="replied"/>
        </xul:menupopup>
      </xul:menulist>
    </content>
    <interface>
      <!-- parentValue forwards to the attribute -->
      <property name="parentValue" onset="this.searchAttribute=val;"
                                   onget="return this.searchAttribute;"/>
      <property name="searchAttribute" onget="return this.internalAttribute;">
        <setter>
          <![CDATA[
            this.internalAttribute = val;
            // we inherit from a deck, so just use it's index attribute
            // to hide/show widgets
            if (val == Components.interfaces.nsMsgSearchAttrib.Priority)
              this.setAttribute("index", "1");
            else if (val == Components.interfaces.nsMsgSearchAttrib.MsgStatus)
              this.setAttribute("index", "2");
            else
              this.setAttribute("index", "0");
          ]]>
        </setter>
      </property>
    </interface>
  </binding>
  <binding id="searchterm">
    <interface>
      <!-- the three tags that make up a term - to use, set the
           attribute in the XUL to the ID of the term.
        -->
      <property name="searchattribute" readonly="true" onget="return document.getElementById(this.getAttribute('searchattribute'));"/>

      <property name="searchoperator" readonly="true" onget="return document.getElementById(this.getAttribute('searchoperator'));"/>

      <property name="searchvalue" readonly="true" onget="return document.getElementById(this.getAttribute('searchvalue'));"/>

      <!-- right now only handles filters - need to abstract termlist -->
      <method name="initialize">
        <argument name="filter"/>
        <argument name="termIndex"/>
        <body>
          <![CDATA[
            var attrib = new Object;
            var op = new Object;
            var value = new Object;
            var booland = new Object;
            var header = new Object;
            filter.GetTerm(termIndex, attrib, op, value, booland, header);

            var searchAttribute=this.searchattribute;
            var searchOperator=this.searchoperator;
            var searchValue=this.searchvalue;

            if (searchAttribute) searchAttribute.value = attrib.value;
            if (searchOperator) searchOperator.value = op.value;
            if (searchValue) searchValue.value = value.value;
          ]]>
        </body>
      </method>
    </interface>
  </binding>
</bindings>
