<?xml version="1.0"?>

<bindings   id="mailBindings"
            xmlns="http://www.mozilla.org/xbl"
            xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
  
  <binding id="search-menulist-abstract" extends="xul:box">
    <content>
      <xul:menulist inherits="flex" oncommand="this.parentNode.onSelect(event)">
        <xul:menupopup/>
      </xul:menulist>
    </content>

    <interface>
      <property readonly="true" name="validityManager">
        <![CDATA[
           Components.classes['mozilla.mail.search.validityManager.1'].getService(Components.interfaces.nsIMsgSearchValidityManager);
        ]]>
      </property>
      <property name="searchScope" onget="return this.internalScope;">
        <!-- scope ID - retrieve the table -->
        <setter>
          <![CDATA[
            // if scope isn't changing this is a noop
            if (this.internalScope == val) return;

            this.internalScope = val;
            this.refreshList();
            var targets = this.targets;
            if (targets) {
              for (var i=0; i< targets.length; i++) {
                targets[i].searchScope = val;
              }
            }
          ]]>
        </setter>
      </property>

      <property name="validityTable" readonly="true" onget="return this.validityManager.getTable(this.searchScope)"/>

      <property name="valueStrings" readonly="true">
        <getter>
          <![CDATA[
            var strings = new Array;
            var ids = this.valueIds;
            var bundle = this.stringBundle;
            for (var i=0; i<ids.length; i++)
                strings[i] = this.stringBundle.GetStringFromID(ids[i]);
            return strings;
          ]]>
        </getter>
      </property>
      <property name="targets" readonly="true">
        <getter>
          <![CDATA[
            var forAttrs =  this.getAttribute("for");
            if (!forAttrs) return null;
            var targetIds = forAttrs.split(",");
            if (targetIds.length == 0) return null;

            var targets = new Array;
            var j=0;
            for (var i=0; i<targetIds.length;i++) {
              var target = document.getElementById(targetIds[i]);
              if (target) targets[j++] = target;
            }
            return targets;
          ]]>
        </getter>
      </property>

      <!-- value forwards to the internal menulist's "data" attribute -->
      <property name="value" onget="return this.anonymousContent[0].selectedItem.data">
        <setter>
          <![CDATA[
            var menulist = this.anonymousContent[0];
            var dataItems = menulist.getElementsByAttribute("data", val);
            if (dataItems.length > 0)
                menulist.selectedItem = dataItems[0];
          ]]>
        </setter>
      </property>
      <method name="refreshList">
        <body>
          <![CDATA[
            var menuItemIds = this.valueIds;
            var menuItemStrings = this.valueStrings;

            var menulist = this.anonymousContent[0];
            var popup = menulist.firstChild;

            // save our old "data" so we can restore it later
            var oldData = menulist.data;

            // remove the old popup children
            while (popup.hasChildNodes())
              popup.removeChild(popup.lastChild);

            var newSelection;
            for (var i=0; i<menuItemIds.length; i++) {
              // create the menuitem
              var menuitem = document.createElement("menuitem");
              menuitem.setAttribute("value", menuItemStrings[i]);
              menuitem.setAttribute("data", menuItemIds[i]);
              popup.appendChild(menuitem);

              // try to restore the selection
              if (!newSelection || oldData == menuItemIds[i].toString()) {
                newSelection = menuitem;
              }
            }

            // now restore the selection
            menulist.selectedItem = newSelection
          ]]>
        </body>
      </method>
      <method name="onSelect">
        <argument name="event"/>
        <body>
          <![CDATA[
            var menulist = this.anonymousContent[0];

            // notify targets
            var targets = this.targets;
            if (targets) {
              for (var i=0; i< targets.length; i++) {
                targets[i].parentValue = menulist.data;
              }
            }
          ]]>
        </body>
      </method>
    </interface>
  </binding>

  <!-- searchattribute - Subject, Sender, To, CC, etc. -->
  <binding id="searchattribute"
           extends="chrome://messenger/skin/mailWidgets.xml#search-menulist-abstract">
    <interface>
      <property name="stringBundle">
          <![CDATA[
           srGetStrBundle("chrome://messenger/locale/search-attributes.properties");
          ]]>
      </property>
      <property name="valueIds" readonly="true">
        <getter>
          <![CDATA[
            var length = new Object;
            return this.validityTable.getAvailableAttributes(length);
          ]]>
        </getter>
      </property>
    </interface>
  </binding>

  <!-- searchoperator - Contains, Is Less than, etc -->
  <binding id="searchoperator"
           extends="chrome://messenger/skin/mailWidgets.xml#search-menulist-abstract">
    <interface>
      <property name="stringBundle">
          <![CDATA[
            srGetStrBundle("chrome://messenger/locale/search-operators.properties");
          ]]>
      </property>
      <property name="valueIds" readonly="true">
        <getter>
          <![CDATA[
            var length = new Object;
            return this.validityTable.getAvailableOperators(this.searchAttribute,length);
          ]]>
        </getter>
      </property>
      <property name="parentValue">
        <setter>
          <![CDATA[
            if (this.searchAttribute == val) return;
            this.searchAttribute = val;
            this.refreshList();
          ]]>
        </setter>
        <getter>
          <![CDATA[
            return this.searchAttribute;
          ]]>
        </getter>
      </property>
    </interface>
  </binding>

  <!-- searchvalue - a widget which dynamically changes it's user interface
       depending on what type of data it's supposed to be showing
       currently handles arbitrary text entry, and menulists for priority and
       status
  -->
  <binding id="searchvalue" extends="xul:deck">
    <!-- yeah yeah, this stuff needs to be localized. I'm working on it! -->
    <content>
      <xul:textfield flex="1" />
      <xul:menulist flex="1" >
        <xul:menupopup>
          <xul:menuitem value="Lowest"/>
          <xul:menuitem value="Low"/>
          <xul:menuitem value="Normal"/>
          <xul:menuitem value="High"/>
          <xul:menuitem value="Highest"/>
        </xul:menupopup>
      </xul:menulist>
      <xul:menulist flex="1" >
        <xul:menupopup>
          <xul:menuitem value="read"/>
          <xul:menuitem value="replied"/>
        </xul:menupopup>
      </xul:menulist>
    </content>
    <interface>
      <!-- parentValue forwards to the attribute -->
      <property name="parentValue" onset="this.searchAttribute=val;"
                                   onget="return this.searchAttribute;"/>
      <property name="searchAttribute" onget="return this.internalAttribute;">
        <setter>
          <![CDATA[
            // noop if we're not changing it
            if (this.internalAttribute == val) return;
            this.internalAttribute = val;
            // we inherit from a deck, so just use it's index attribute
            // to hide/show widgets
            if (val == Components.interfaces.nsMsgSearchAttrib.Priority)
              this.setAttribute("index", "1");
            else if (val == Components.interfaces.nsMsgSearchAttrib.MsgStatus)
              this.setAttribute("index", "2");
            else
              this.setAttribute("index", "0");
          ]]>
        </setter>
      </property>
      <property name="value" onget="return this.internalValue;">
        <setter>
          <![CDATA[
          // val is a nsIMsgSearchValue object
          this.internalValue = val;
          var attrib = val.attrib;
          this.searchAttribute = attrib;
          if (attrib == Components.interfaces.nsMsgSearchAttrib.Priority)
            this.anonymousContent[1].data=val.priority;
          else if (attrib == Components.interfaces.nsMsgSearchAttrib.MsgStatus)
            this.anonymousContent[2].data=val.status;
          else
            this.anonymousContent[0].value = val.str;
          ]]>
        </setter>
      </property>
    </interface>
  </binding>
  <binding id="searchterm" extends="xul:box">
    <interface>
      <!-- the three tags that make up a term - to use, set the
           attribute in the XUL to the ID of the term.
        -->
      <property name="searchTerm" onget="return this.internalSearchTerm">
        <setter>
          <![CDATA[
            this.internalSearchTerm = val;

            var term = val;
            // val is a nsIMsgSearchTerm
            var searchAttribute=this.searchattribute;
            var searchOperator=this.searchoperator;
            var searchValue=this.searchvalue;

            if (searchAttribute) searchAttribute.value = term.attrib;
            if (searchOperator) searchOperator.value = val.op;
            if (searchValue) searchValue.value = term.value;
          ]]>
        </setter>
      </property>
 
      <property name="searchScope">
        <getter>
          <![CDATA[
             var searchAttribute = this.searchattribute;
             if (searchAttribute)
               return searchAttribute.searchScope;
             return undefined;
           ]]>
        </getter>
        <setter>
          <![CDATA[
            var searchAttribute = this.searchattribute;
            if (searchAttribute) searchAttribute.searchScope=val;
           ]]>
        </setter>
      </property>
      <property name="searchattribute" 
                onget="return document.getElementById(this.getAttribute('searchattribute'));"
                onset="this.setAttribute('searchattribute',val.id)"/>

      <property name="searchoperator" 
                onget="return document.getElementById(this.getAttribute('searchoperator'));"
                onset="this.setAttribute('searchoperator',val.id)"/>

      <property name="searchvalue" 
                onget="return document.getElementById(this.getAttribute('searchvalue'));"
                onset="this.setAttribute('searchvalue',val.id)"/>

      <!-- takes an nsIMsgSearchValue and initializes the appropriate widget
           with the right value
        -->
      <!-- right now only handles filters - need to abstract termlist -->
      <method name="initialize">
        <argument name="filter"/>
        <argument name="termIndex"/>
        <argument name="scope"/>
        <body>
          <![CDATA[
          ]]>
        </body>
      </method>
    </interface>
  </binding>
</bindings>
