<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.5b2 [en] (WinNT; I) [Netscape]">
   <TITLE>JavaScript Reference Implementation (JSRef) README</TITLE>
</HEAD>
<BODY>

<H2>
Introduction</H2>
This is the README file for the <SPAN CLASS=LXRSHORTDESC>JavaScript Reference (JSRef) implementation.</SPAN>
It consists of build conventions and instructions, source code conventions,
a design walk-through, and a brief file-by-file description of the source.
<P><SPAN CLASS=LXRLONGDESC>JSRef builds a library or DLL containing the JavaScript runtime (compiler,
interpreter, decompiler, garbage collector, atom manager, standard classes).
It then compiles a small "shell" program and links that with the library
to make an interpreter that can be used interactively and with test .js
files to run scripts.&nbsp; The code has no dependencies on the Navigator.</SPAN>
<P><I>Quick start tip</I>: skip to "Using the JS API" below, build js,
and play with the object named "it" (start by setting 'it.noisy = true').
<H2>
Build conventions</H2>

<UL>
<LI>
On Windows, use MSDEV4.2 or 5.0.&nbsp; Use either the js.mdp project file
to build with the IDE or '<TT>nmake -f js.mak</TT>' to build from the command-line</LI>

<LI>
On Mac, use CodeWarrior 3.x (<TT>JSRef.mcp</TT> in the <TT>js/src/macbuild</TT>
subdirectory)</LI>

<LI>
On Unix, use vendor cc or <A HREF="ftp://prep.ai.mit.edu/pub/gnu">gcc</A>
for compiling, and use '<TT>gmake -f Makefile.ref</TT>' for building. To
compile optimized code, pass
<TT>BUILD_OPT=1</TT> on the nmake/gmake command
line or preset it in the environment or makefile. The C preprocessor macro
<TT>DEBUG</TT>
will be undefined, and <TT>NDEBUG </TT>(archaic Unix-ism for "No Debugging")
will be defined. Without <TT>BUILD_OPT</TT>, <TT>DEBUG</TT> is predefined
and
<TT>NDEBUG</TT> is undefined. On Unix, your own debug flag, <TT>DEBUG_$USER</TT>,
will be defined or undefined as <TT>BUILD_OPT</TT> is unset or set.</LI>

<LI>
To add C compiler options from the make command line, set <TT>XCFLAGS=-Dfoo</TT>.
To predefine -D or -U options in the makefile, set <TT>DEFINES</TT>. To
predefine -I options in the makefile, set INCLUDES.</LI>

<LI>
To turn on GC instrumentation, define <TT>JS_GCMETER</TT>.</LI>

<LI>
To enable multi-threaded execution, define <TT>JS_THREADSAFE</TT> and flesh
out the stubs and required headers in <I>jslock.c</I> and <I>jslock.h</I>.
See the JS API docs for more.</LI>

<LI>
To turn on the arena package's instrumentation, define <TT>JS_ARENAMETER</TT>.</LI>

<LI>
To turn on the hash table package's metering, define <TT>JS_HASHMETER</TT>.</LI>
</UL>

<H2>
Naming and coding conventions</H2>

<UL>
<LI>
Public function names begin with <TT>JS_</TT> followed by capitalized "intercaps",
e.g. <TT>JS_NewObject</TT>.</LI>

<LI>
Extern but library-private function names use a <TT>js_</TT> prefix and
mixed case, e.g. <TT>js_LookupSymbol</TT>.</LI>

<LI>
Most static function names have unprefixed, mixed-case names: <TT>GetChar</TT>.</LI>

<LI>
But static native methods of JS objects have lowercase, underscore-separated
or intercaps names, e.g., <TT>str_indexOf</TT>.</LI>

<LI>
And library-private and static data use underscores, not intercaps (but
library-private data do use a <TT>js_</TT> prefix).</LI>

<LI>
Scalar type names are lowercase and js-prefixed: <TT>jsdouble</TT>.</LI>

<LI>
Aggregate type names are JS-prefixed and mixed-case: <TT>JSObject.</TT></LI>

<LI>
Macros are generally <TT>ALL_CAPS </TT>and underscored, to call out potential
side effects, multiple uses of a formal argument, etc. - Four spaces of
indentation per statement nesting level.</LI>

<LI>
Tabs are taken to be eight spaces, and an Emacs magic comment at the top
of each file tries to help. If you're using MSVC or similar, you'll want
to set tab width to 8, or convert these files to be space-filled.</LI>

<LI>
DLL entry points have their return type expanded within a <TT>JS_PUBLIC_API()</TT>
macro call, to get the right Windows secret type qualifiers in the right
places for both 16- and 32-bit builds.</LI>

<LI>
Callback functions that might be called from a DLL are similarly macroized
with <TT>JS_STATIC_DLL_CALLBACK</TT> (if the function otherwise would be
static to hide its name) or <TT>JS_DLL_CALLBACK</TT> (this macro takes
no type argument; it should be used after the return type and before the
function name).</LI>
</UL>

<H2>
Using the JS API</H2>

<H4>
Starting up</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Tune this to avoid wasting space for shallow stacks, while saving on
&nbsp;&nbsp;&nbsp;&nbsp; * malloc overhead/fragmentation for deep or highly-variable stacks.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; #define STACK_CHUNK_SIZE&nbsp;&nbsp;&nbsp; 8192

&nbsp;&nbsp;&nbsp; JSRuntime *rt;
&nbsp;&nbsp;&nbsp; JSContext *cx;

&nbsp;&nbsp;&nbsp; /* You need a runtime and one or more contexts to do anything with JS. */
&nbsp;&nbsp;&nbsp; rt = JS_Init(1000000L);
&nbsp;&nbsp;&nbsp; if (!rt)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fail("can't create JavaScript runtime");
&nbsp;&nbsp;&nbsp; cx = JS_NewContext(rt, STACK_CHUNK_SIZE);
&nbsp;&nbsp;&nbsp; if (!cx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fail("can't create JavaScript context");

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * The context definitely wants a global object, in order to have standard
&nbsp;&nbsp;&nbsp;&nbsp; * classes and functions like Date and parseInt.&nbsp; See below for details on
&nbsp;&nbsp;&nbsp;&nbsp; * JS_NewObject.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; JSObject *globalObj;

&nbsp;&nbsp;&nbsp; globalObj = JS_NewObject(cx, &amp;my_global_class, 0, 0);
&nbsp;&nbsp;&nbsp; JS_InitStandardClasses(cx, globalObj);</TT></PRE>

<H4>
Defining objects and properties</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /* Statically initialize a class to make "one-off" objects. */
&nbsp;&nbsp;&nbsp; JSClass my_class = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "MyClass",

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* All of these can be replaced with the corresponding JS_*Stub
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function pointers. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_addProperty, my_delProperty, my_getProperty, my_setProperty,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_enumerate,&nbsp;&nbsp; my_resolve,&nbsp;&nbsp;&nbsp;&nbsp; my_convert,&nbsp;&nbsp;&nbsp;&nbsp; my_finalize
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; JSObject *obj;

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Define an object named in the global scope that can be enumerated by
&nbsp;&nbsp;&nbsp;&nbsp; * for/in loops.&nbsp; The parent object is passed as the second argument, as
&nbsp;&nbsp;&nbsp;&nbsp; * with all other API calls that take an object/name pair.&nbsp; The prototype
&nbsp;&nbsp;&nbsp;&nbsp; * passed in is null, so the default object prototype will be used.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; obj = JS_DefineObject(cx, globalObj, "myObject", &amp;my_class, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_ENUMERATE);

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Define a bunch of properties with a JSPropertySpec array statically
&nbsp;&nbsp;&nbsp;&nbsp; * initialized and terminated with a null-name entry.&nbsp; Besides its name,
&nbsp;&nbsp;&nbsp;&nbsp; * each property has a "tiny" identifier (MY_COLOR, e.g.) that can be used
&nbsp;&nbsp;&nbsp;&nbsp; * in switch statements (in a common my_getProperty function, for example).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; enum my_tinyid {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_COLOR, MY_HEIGHT, MY_WIDTH, MY_FUNNY, MY_ARRAY, MY_RDONLY
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; static JSPropertySpec my_props[] = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"color",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_COLOR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_ENUMERATE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"height",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_HEIGHT,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_ENUMERATE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"width",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_WIDTH,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_ENUMERATE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"funny",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_FUNNY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_ENUMERATE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"array",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_ARRAY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_ENUMERATE},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"rdonly",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MY_RDONLY,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JSPROP_READONLY},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0}
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; JS_DefineProperties(cx, obj, my_props);

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Given the above definitions and call to JS_DefineProperties, obj will
&nbsp;&nbsp;&nbsp;&nbsp; * need this sort of "getter" method in its class (my_class, above).&nbsp; See
&nbsp;&nbsp;&nbsp;&nbsp; * the example for the "It" class in js.c.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; static JSBool
&nbsp;&nbsp;&nbsp; my_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (JSVAL_IS_INT(id)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (JSVAL_TO_INT(id)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MY_COLOR:&nbsp; *vp = . . .; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MY_HEIGHT: *vp = . . .; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MY_WIDTH:&nbsp; *vp = . . .; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MY_FUNNY:&nbsp; *vp = . . .; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MY_ARRAY:&nbsp; *vp = . . .; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case MY_RDONLY: *vp = . . .; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JS_TRUE;
&nbsp;&nbsp;&nbsp; }</TT></PRE>

<H4>
Defining functions</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /* Define a bunch of native functions first: */
&nbsp;&nbsp;&nbsp; static JSBool
&nbsp;&nbsp;&nbsp; my_abs(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jsdouble x, z;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!JS_ValueToNumber(cx, argv[0], &amp;x))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JS_FALSE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; z = (x &lt; 0) ? -x : x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return JS_NewDoubleValue(cx, z, rval);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; . . .

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Use a JSFunctionSpec array terminated with a null name to define a
&nbsp;&nbsp;&nbsp;&nbsp; * bunch of native functions.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; static JSFunctionSpec my_functions[] = {
&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; native&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nargs&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"abs",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_abs,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"acos",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_acos,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {"asin",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_asin,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1},
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {0}
&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Pass a particular object to define methods for it alone.&nbsp; If you pass
&nbsp;&nbsp;&nbsp;&nbsp; * a prototype object, the methods will apply to all instances past and
&nbsp;&nbsp;&nbsp;&nbsp; * future of the prototype's class (see below for classes).
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; JS_DefineFunctions(cx, globalObj, my_functions);</TT></PRE>

<H4>
Defining classes</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * This pulls together the above API elements by defining a constructor
&nbsp;&nbsp;&nbsp;&nbsp; * function, a prototype object, and properties of the prototype and of
&nbsp;&nbsp;&nbsp;&nbsp; * the constructor, all with one API call.
&nbsp;&nbsp;&nbsp;&nbsp; *
&nbsp;&nbsp;&nbsp;&nbsp; * Initialize a class by defining its constructor function, prototype, and
&nbsp;&nbsp;&nbsp;&nbsp; * per-instance and per-class properties.&nbsp; The latter are called "static"
&nbsp;&nbsp;&nbsp;&nbsp; * below by analogy to Java.&nbsp; They are defined in the constructor object's
&nbsp;&nbsp;&nbsp;&nbsp; * scope, so that 'MyClass.myStaticProp' works along with 'new MyClass()'.
&nbsp;&nbsp;&nbsp;&nbsp; *
&nbsp;&nbsp;&nbsp;&nbsp; * JS_InitClass takes a lot of arguments, but you can pass null for any of
&nbsp;&nbsp;&nbsp;&nbsp; * the last four if there are no such properties or methods.
&nbsp;&nbsp;&nbsp;&nbsp; *
&nbsp;&nbsp;&nbsp;&nbsp; * Note that you do not need to call JS_InitClass to make a new instance of
&nbsp;&nbsp;&nbsp;&nbsp; * that class -- otherwise there would be a chicken-and-egg problem making
&nbsp;&nbsp;&nbsp;&nbsp; * the global object -- but you should call JS_InitClass if you require a
&nbsp;&nbsp;&nbsp;&nbsp; * constructor function for script authors to call via new, and/or a class
&nbsp;&nbsp;&nbsp;&nbsp; * prototype object ('MyClass.prototype') for authors to extend with new
&nbsp;&nbsp;&nbsp;&nbsp; * properties at run-time.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; protoObj = JS_InitClass(cx, globalObj, &amp;my_class,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* native constructor function and min arg count */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MyClass, 0,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* prototype object properties and methods -- these
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will be "inherited" by all instances through
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delegation up the instance's prototype link. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_props, my_methods,

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* class constructor properties and methods */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; my_static_props, my_static_methods);</TT></PRE>

<H4>
Running scripts</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /* These should indicate source location for diagnostics. */
&nbsp;&nbsp;&nbsp; char *filename;
&nbsp;&nbsp;&nbsp; uintN lineno;

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * The return value comes back here -- if it could be a GC thing, you must
&nbsp;&nbsp;&nbsp;&nbsp; * add it to the GC's "root set" with JS_AddRoot(cx, &amp;thing) where thing
&nbsp;&nbsp;&nbsp;&nbsp; * is a JSString *, JSObject *, or jsdouble *, and remove the root before
&nbsp;&nbsp;&nbsp;&nbsp; * rval goes out of scope, or when rval is no longer needed.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; jsval rval;
&nbsp;&nbsp;&nbsp; JSBool ok;

&nbsp;&nbsp;&nbsp; /*
&nbsp;&nbsp;&nbsp;&nbsp; * Some example source in a C string.&nbsp; Larger, non-null-terminated buffers
&nbsp;&nbsp;&nbsp;&nbsp; * can be used, if you pass the buffer length to JS_EvaluateScript.
&nbsp;&nbsp;&nbsp;&nbsp; */
&nbsp;&nbsp;&nbsp; char *source = "x * f(y)";

&nbsp;&nbsp;&nbsp; ok = JS_EvaluateScript(cx, globalObj, source, strlen(source),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filename, lineno, &amp;rval);

&nbsp;&nbsp;&nbsp; if (ok) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Should get a number back from the example source. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jsdouble d;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ok = JS_ValueToNumber(cx, rval, &amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .
&nbsp;&nbsp;&nbsp; }</TT></PRE>

<H4>
Calling functions</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /* Call a global function named "foo" that takes no arguments. */
&nbsp;&nbsp;&nbsp; ok = JS_CallFunctionName(cx, globalObj, "foo", 0, 0, &amp;rval);

&nbsp;&nbsp;&nbsp; jsval argv[2];

&nbsp;&nbsp;&nbsp; /* Call a function in obj's scope named "method", passing two arguments. */
&nbsp;&nbsp;&nbsp; argv[0] = . . .;
&nbsp;&nbsp;&nbsp; argv[1] = . . .;
&nbsp;&nbsp;&nbsp; ok = JS_CallFunctionName(cx, obj, "method", 2, argv, &amp;rval);</TT></PRE>

<H4>
Shutting down</H4>

<PRE><TT>&nbsp;&nbsp;&nbsp; /* For each context you've created: */
&nbsp;&nbsp;&nbsp; JS_DestroyContext(cx);

&nbsp;&nbsp;&nbsp; /* And finally: */
&nbsp;&nbsp;&nbsp; JS_Finish(rt);</TT></PRE>

<H4>
Debugging API</H4>
See the<TT> trap, untrap, watch, unwatch, line2pc</TT>, and <TT>pc2line</TT>
commands in <TT>js.c</TT>. Also the (scant) comments in <I>jsdbgapi.h</I>.
<H2>
Design walk-through</H2>
This section must be brief for now -- it could easily turn into a book.
<H4>
JS "JavaScript Proper"</H4>
JS modules declare and implement the JavaScript compiler, interpreter,
decompiler, GC and atom manager, and standard classes.
<P>JavaScript uses untyped bytecode and runtime type tagging of data values.
The <TT>jsval</TT> type is a signed machine word that contains either a
signed integer value (if the low bit is set), or a type-tagged pointer
or boolean value (if the low bit is clear). Tagged pointers all refer to
8-byte-aligned things in the GC heap.
<P>Objects consist of a possibly shared structural description, called
the map or scope; and unshared property values in a vector, called the
slots. Object properties are associated with nonnegative integers stored
in <TT>jsval</TT>'s, or with atoms (unique string descriptors) if named
by an identifier or a non-integral index expression.
<P>Scripts contain bytecode, source annotations, and a pool of string,
number, and identifier literals. Functions are objects that extend scripts
or native functions with formal parameters, a literal syntax, and a distinct
primitive type ("function").
<P>The compiler consists of a recursive-descent parser and a random-logic
rather than table-driven lexical scanner. Semantic and lexical feedback
are used to disambiguate hard cases such as missing semicolons, assignable
expressions ("lvalues" in C parlance), etc. The parser generates bytecode
as it parses, using fixup lists for downward branches and code buffering
and rewriting for exceptional cases such as for loops. It attempts no error
recovery. The interpreter executes the bytecode of top-level scripts, and
calls itself indirectly to interpret function bodies (which are also scripts).
All state associated with an interpreter instance is passed through formal
parameters to the interpreter entry point; most implicit state is collected
in a type named JSContext. Therefore, all API and almost all other functions
in JSRef take a JSContext pointer as their first argument.
<P>The decompiler translates postfix bytecode into infix source by consulting
a separate byte-sized code, called source notes, to disambiguate bytecodes
that result from more than one grammatical production.
<P>The GC is a mark-and-sweep, non-conservative (perfect) collector. It
can allocate only fixed-sized things -- the current size is two machine
words. It is used to hold JS object and string descriptors (but not property
lists or string bytes), and double-precision floating point numbers. It
runs automatically only when maxbytes (as passed to <TT>JS_Init()</TT>)
bytes of GC things have been allocated and another thing-allocation request
is made. JS API users should call <TT>JS_GC()</TT> or <TT>JS_MaybeGC()</TT>
between script executions or from the branch callback, as often as necessary.
<P>An important point about the GC's "perfection": you must add roots for
new objects created by your native methods if you store references to them
into a non-JS structure in the malloc heap or in static data. Also, if
you make a new object in a native method, but do not store it through the
<TT>rval</TT> result parameter (see math_abs in the "Using the JS API"
section above) so that it is in a known root, the object is guaranteed
to survive only until another new object is created. Either lock the first
new object when making two in a row, or store it in a root you've added,
or store it via rval.
<P>The atom manager consists of a hash table associating strings uniquely
with scanner/parser information such as keyword type, index in script or
function literal pool, etc. Atoms play three roles in JSRef: as literals
referred to by unaligned 16-bit immediate bytecode operands, as unique
string descriptors for efficient property name hashing, and as members
of the root GC set for perfect GC. This design therefore requires atoms
to be manually reference counted, from script literal pools (<TT>JSAtomMap</TT>)
and object symbol (<TT>JSSymbol</TT>) entry keys.
<P>Native objects and methods for arrays, booleans, dates, functions, numbers,
and strings are implemented using the JS API and certain internal interfaces
used as "fast paths".
<P>In general, errors are signaled by false or unoverloaded-null return
values, and are reported using <TT>JS_ReportError()</TT> or one of its
variants by the lowest level in order to provide the most detail. Client
code can substitute its own error reporting function and suppress errors,
or reflect them into Java or some other runtime system as exceptions, GUI
dialogs, etc..
<H2>
File walk-through</H2>

<H4>
jsapi.c, jsapi.h</H4>
The public API to be used by almost all client code.&nbsp; If your client
code can't make do with <TT>jsapi.h</TT>, and must reach into a friend
or private js* file, please let us know so we can extend <TT>jsapi.h</TT>
to include what you need in a fashion that we can support over the long
run.
<H4>
jspubtd.h, jsprvtd.h</H4>
These files exist to group struct and scalar typedefs so they can be used
everywhere without dragging in struct definitions from N different files.
The <TT>jspubtd.h</TT> file contains public typedefs, and is included by
<TT>jsapi.h</TT>. The <TT>jsprvtd.h</TT> file contains private typedefs
and is included by various .h files that need type names, but not type
sizes or declarations.
<H4>
jsdbgapi.c, jsdbgapi.h</H4>
The Debugging API, still very much under development. Provided so far:
<UL>
<LI>
Traps, with which breakpoints, single-stepping, step over, step out, and
so on can be implemented. The debugger will have to consult jsopcode.def
on its own to figure out where to plant trap instructions to implement
functions like step out, but a future jsdbgapi.h will provide convenience
interfaces to do these things. At most one trap per bytecode can be set.
When a script (<TT>JSScript</TT>) is destroyed, all traps set in its bytecode
are cleared.</LI>

<LI>
Watchpoints, for intercepting set operations on properties and running
a debugger-supplied function that receives the old value and a pointer
to the new one, which it can use to modify the new value being set.</LI>

<LI>
Line number to PC and back mapping functions. The line-to-PC direction
"rounds" toward the next bytecode generated from a line greater than or
equal to the input line, and may return the PC of a for-loop update part,
if given the line number of the loop body's closing brace. Any line after
the last one in a script or function maps to a PC one byte beyond the last
bytecode in the script. An example, from perfect.js:</LI>

<PRE><TT>14&nbsp;&nbsp; function perfect(n)
15&nbsp;&nbsp; {
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("The perfect numbers up to " +&nbsp; n + " are:");
17
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // We build sumOfDivisors[i] to hold a string expression for
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the sum of the divisors of i, excluding i itself.
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var sumOfDivisors = new ExprArray(n+1,1);
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (var divisor = 2; divisor &lt;= n; divisor++) {
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (var j = divisor + divisor; j &lt;= n; j += divisor) {
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sumOfDivisors[j] += " + " + divisor;
24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // At this point everything up to 'divisor' has its sumOfDivisors
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // expression calculated, so we can determine whether it's perfect
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // already by evaluating.
28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (eval(sumOfDivisors[divisor]) == divisor) {
29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("" + divisor + " = " + sumOfDivisors[divisor]);
30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete sumOfDivisors;
33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("That's all.");
34&nbsp;&nbsp; }</TT></PRE>
The line number to PC and back mappings can be tested using the js program
with the following script:
<PRE><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; load("perfect.js")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print(perfect)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dis(perfect)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (var ln = 0; ln &lt;= 40; ln++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var pc = line2pc(perfect,ln)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ln2 = pc2line(perfect,pc)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print("\tline " + ln + " => pc " + pc + " => line " + ln2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</TT></PRE>
The result of the for loop over lines 0 to 40 inclusive is:
<PRE><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 0 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 1 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 2 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 3 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 4 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 5 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 6 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 7 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 8 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 9 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 10 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 11 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 12 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 13 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 14 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 15 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 16 => pc 0 => line 16
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 17 => pc 19 => line 20
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 18 => pc 19 => line 20
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 19 => pc 19 => line 20
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 20 => pc 19 => line 20
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 21 => pc 36 => line 21
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 22 => pc 53 => line 22
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 23 => pc 74 => line 23
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 24 => pc 92 => line 22
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 25 => pc 106 => line 28
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 26 => pc 106 => line 28
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 27 => pc 106 => line 28
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 28 => pc 106 => line 28
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 29 => pc 127 => line 29
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 30 => pc 154 => line 21
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 31 => pc 154 => line 21
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 32 => pc 161 => line 32
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 33 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 34 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 35 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 36 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 37 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 38 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 39 => pc 172 => line 33
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line 40 => pc 172 => line 33</TT></PRE>
</UL>

<H4>
jsconfig.h</H4>
Various configuration macros defined as 0 or 1 depending on how <TT>JS_VERSION</TT>
is defined (as 10 for JavaScript 1.0, 11 for JavaScript 1.1, etc.). Not
all macros are tested around related code yet. In particular, JS 1.0 support
is missing from JSRef. JS 1.2 support will appear in a future JSRef release.
<BR>&nbsp;
<H4>
js.c</H4>
The "JS shell", a simple interpreter program that uses the JS API and more
than a few internal interfaces (some of these internal interfaces could
be replaced by <TT>jsapi.h</TT> calls). The js program built from this
source provides a test vehicle for evaluating scripts and calling functions,
trying out new debugger primitives, etc.
<H4>
jsarray.*, jsbool.*, jdsdate.*, jsfun.*, jsmath.*, jsnum.*, jsstr.*</H4>
These file pairs implement the standard classes and (where they exist)
their underlying primitive types. They have similar structure, generally
starting with class definitions and continuing with internal constructors,
finalizers, and helper functions.
<H4>
jsobj.*, jsscope.*</H4>
These two pairs declare and implement the JS object system. All of the
following happen here:
<UL>
<LI>
creating objects by class and prototype, and finalizing objects;</LI>

<LI>
defining, looking up, getting, setting, and deleting properties;</LI>

<LI>
creating and destroying properties and binding names to them.</LI>
</UL>
The details of an object map (scope) are mostly hidden in <TT>jsscope.[ch]</TT>,
where scopes start out as linked lists of symbols, and grow after some
threshold into PR hash tables.
<H4>
jsatom.c, jsatom.h</H4>
The atom manager. Contains well-known string constants, their atoms, the
global atom hash table and related state, the js_Atomize() function that
turns a counted string of bytes into an atom, and literal pool (<TT>JSAtomMap</TT>)
methods.
<H4>
jsgc.c, jsgc.h</H4>
[TBD]
<H4>
jsinterp.*, jscntxt.*</H4>
The bytecode interpreter, and related functions such as Call and AllocStack,
live in <I>jsinterp.c</I>. The JSContext constructor and destructor are
factored out into <I>jscntxt.c</I> for minimal linking when the compiler
part of JS is split from the interpreter part into a separate program.
<H4>
jsemit.*, jsopcode.tbl, jsopcode.*, jsparse.*, jsscan.*, jsscript.*</H4>
Compiler and decompiler modules. The <I>jsopcode.tbl</I> file is a C preprocessor
source that defines almost everything there is to know about JS bytecodes.
See its major comment for how to use it. For now, a debugger will use it
and its dependents such as <I>jsopcode.h</I> directly, but over time we
intend to extend <I>jsdbgapi.h</I> to hide uninteresting details and provide
conveniences. The code generator is split across paragraphs of code in
<I>jsparse.c</I>, and the utility methods called on <TT>JSCodeGenerator</TT>
appear in <I>jsemit.c</I>. Source notes generated by <I>jsparse.c</I> and
<I>jsemit.c</I> are used in <I>jsscript.c</I> to map line number to program
counter and back.
<H4>
jstypes.h, jslog2.c</H4>
Fundamental representation types and utility macros. This file alone among
all .h files in JSRef must be included first by .c files. It is not nested
in .h files, as other prerequisite .h files generally are, since it is
also a direct dependency of most .c files and would be over-included if
nested in addition to being directly included. The one "not-quite-a-macro
macro" is the <TT>JS_CeilingLog2()</TT> function in <I>jslog2.c</I>.
<H4>
jsarena.c, jsarena.h</H4>
Last-In-First-Out allocation macros that amortize malloc costs and allow
for en-masse freeing. See the paper mentioned in prarena.h's major comment.
<H4>
jsutil.c, jsutil.h</H4>
The <TT>JS_ASSERT</TT> macro is used throughout JSRef source as a proof
device to make invariants and preconditions clear to the reader, and to
hold the line during maintenance and evolution against regressions or violations
of assumptions that it would be too expensive to test unconditionally at
run-time. Certain assertions are followed by run-time tests that cope with
assertion failure, but only where I'm too smart or paranoid to believe
the assertion will never fail...
<H4>
jsclist.h</H4>
Doubly-linked circular list struct and macros.
<H4>
jscpucfg.c</H4>
This standalone program generates <I>jscpucfg.h</I>, a header file containing
bytes per word and other constants that depend on CPU architecture and
C compiler type model. It tries to discover most of these constants by
running its own experiments on the build host, so if you are cross-compiling,
beware.
<H4>
prdtoa.c, prdtoa.h</H4>
David Gay's portable double-precision floating point to string conversion
code, with Permission To Use notice included.
<H4>
prhash.c, prhash.h</H4>
Portable, extensible hash tables. These use multiplicative hash for strength
reduction over division hash, yet with very good key distribution over
power of two table sizes. Collisions resolve via chaining, so each entry
burns a malloc and can fragment the heap.
<H4>
prlong.c, prlong.h</H4>
64-bit integer emulation, and compatible macros that use C's long long
type where it exists (my last company mapped long long to a 128-bit type,
but no real architecture does 128-bit ints yet).
<H4>
jsosdep.h</H4>
Annoying OS dependencies rationalized into a few "feature-test" macros
such as <TT>HAVE_LONG_LONG</TT>.
<H4>
jsprf.*</H4>
Portable, buffer-overrun-resistant sprintf and friends. For no good reason
save lack of time, the %e, %f, and %g formats cause your system's native
sprintf, rather than <TT>JS_dtoa()</TT>, to be used. This bug doesn't affect
JSRef, because it uses its own <TT>JS_dtoa()</TT> call in <I>jsnum.c</I>
to convert from double to string, but it's a bug that we'll fix later,
and one you should be aware of if you intend to use a <TT>JS_*printf()</TT>&nbsp;
function with your own floating type arguments - various vendor sprintf's
mishandle NaN, +/-Inf, and some even print normal floating values inaccurately.
<H4>
prmjtime.c, prmjtime.h</H4>
Time functions. These interfaces are named in a way that makes local vs.
universal time confusion likely. Caveat emptor, and we're working on it.
To make matters worse, Java (and therefore JavaScript) uses "local" time
numbers (offsets from the epoch) in its Date class.
</BODY>
</HTML>
