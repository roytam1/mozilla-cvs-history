Index: cairo/src/cairo-win32-surface.c
===================================================================
--- cairo.orig/src/cairo-win32-surface.c	2006-02-07 17:14:24.921875000 -0800
+++ cairo/src/cairo-win32-surface.c	2006-02-09 17:57:30.562500000 -0800
@@ -132,8 +132,13 @@
     bitmap_info->bmiHeader.biPlanes = 1;
     
     switch (format) {
-    case CAIRO_FORMAT_ARGB32:
+    /* We can't create real RGB24 bitmaps because something seems to
+     * break if we do, especially if we don't set up an image
+     * fallback.  It could be a bug with using a 24bpp pixman image
+     * (and creating one with masks).
+     */
     case CAIRO_FORMAT_RGB24:
+    case CAIRO_FORMAT_ARGB32:
 	bitmap_info->bmiHeader.biBitCount = 32;
 	bitmap_info->bmiHeader.biCompression = BI_RGB;
 	bitmap_info->bmiHeader.biClrUsed = 0;	/* unused */
@@ -182,6 +187,8 @@
     if (!surface->bitmap)
 	goto FAIL;
 
+    GdiFlush();
+
     surface->saved_dc_bitmap = SelectObject (surface->dc,
 					     surface->bitmap);
     if (!surface->saved_dc_bitmap)
@@ -386,6 +393,8 @@
 		 SRCCOPY))
 	goto FAIL;
 
+    GdiFlush();
+
     *local_out = local;
     
     return CAIRO_STATUS_SUCCESS;
@@ -409,6 +418,8 @@
     cairo_status_t status;
 
     if (surface->image) {
+	GdiFlush();
+
 	*image_out = (cairo_image_surface_t *)surface->image;
 	*image_extra = NULL;
 
@@ -452,6 +463,8 @@
     int x1, y1, x2, y2;
 
     if (surface->image) {
+	GdiFlush();
+
 	image_rect->x = 0;
 	image_rect->y = 0;
 	image_rect->width = surface->clip_rect.width;
@@ -612,7 +625,7 @@
 		      src_x, src_y,
 		      width, height,
 		      blend_function))
-	return _cairo_win32_print_gdi_error ("_cairo_win32_surface_composite");
+	return _cairo_win32_print_gdi_error ("_cairo_win32_surface_composite(AlphaBlend)");
     
     return CAIRO_STATUS_SUCCESS;
 }
@@ -675,13 +688,13 @@
 		     src->dc,
 		     src_x + itx, src_y + ity,
 		     SRCCOPY))
-	    return _cairo_win32_print_gdi_error ("_cairo_win32_surface_composite");
+	    return _cairo_win32_print_gdi_error ("_cairo_win32_surface_composite(BitBlt)");
 
 	return CAIRO_STATUS_SUCCESS;
 	
     } else if (integer_transform &&
 	       (src->format == CAIRO_FORMAT_RGB24 || src->format == CAIRO_FORMAT_ARGB32) &&
-	       dst->format == CAIRO_FORMAT_RGB24 &&
+	       (dst->format == CAIRO_FORMAT_RGB24 || dst->format == CAIRO_FORMAT_ARGB32) &&
 	       op == CAIRO_OPERATOR_OVER) {
 
 	return _composite_alpha_blend (dst, src, alpha,
@@ -783,10 +796,11 @@
     HBRUSH new_brush;
     int i;
 
-    /* If we have a local image, use the fallback code; it will be as fast
-     * as calling out to GDI.
-     */
-    if (surface->image)
+    /* XXXperf If it's not RGB24, we need to do a little more checking
+     * to figure out when we can use GDI.  We don't have that checking
+     * anywhere at the moment, so just bail and use the fallback
+     * paths. */
+    if (surface->format != CAIRO_FORMAT_RGB24)
 	return CAIRO_INT_STATUS_UNSUPPORTED;
 
     /* Optimize for no destination alpha (surface->pixman_image is non-NULL for all
@@ -1007,6 +1021,31 @@
     return surface->backend == &cairo_win32_surface_backend;
 }
 
+/**
+ * cairo_win32_surface_get_dc
+ * @surface: a #cairo_surface_t
+ *
+ * Returns the HDC associated with this surface, or NULL if none.
+ * Also returns NULL if the surface is not a win32 surface.
+ *
+ * Return value: HDC or NULL if no HDC available.
+ **/
+HDC
+cairo_win32_surface_get_dc (cairo_surface_t *surface)
+{
+    cairo_win32_surface_t *winsurf;
+
+    if (surface == NULL)
+	return NULL;
+
+    if (!_cairo_surface_is_win32(surface))
+	return NULL;
+
+    winsurf = (cairo_win32_surface_t *) surface;
+
+    return winsurf->dc;
+}
+
 static const cairo_surface_backend_t cairo_win32_surface_backend = {
     _cairo_win32_surface_create_similar,
     _cairo_win32_surface_finish,
@@ -1026,7 +1065,17 @@
     NULL, /* old_show_glyphs */
     NULL, /* get_font_options */
     _cairo_win32_surface_flush,
-    NULL  /* mark_dirty_rectangle */
+    NULL, /* mark_dirty_rectangle */
+    NULL, /* scaled_font_fini */
+    NULL, /* scaled_glyph_fini */
+
+    NULL, /* paint */
+    NULL, /* mask */
+    NULL, /* stroke */
+    NULL, /* fill */
+    NULL, /* show_glyphs */
+
+    NULL, /* snapshot */
 };
 
 /*
Index: cairo/src/cairo-win32.h
===================================================================
--- cairo.orig/src/cairo-win32.h	2006-02-07 17:14:24.922875000 -0800
+++ cairo/src/cairo-win32.h	2006-02-07 17:15:20.390625000 -0800
@@ -60,6 +60,9 @@
 cairo_public double
 cairo_win32_scaled_font_get_metrics_factor (cairo_scaled_font_t *scaled_font);
 
+cairo_public HDC
+cairo_win32_surface_get_dc (cairo_surface_t *surface);
+
 CAIRO_END_DECLS
 
 #else  /* CAIRO_HAS_WIN32_SURFACE */
Index: cairo/src/cairo-win32-font.c
===================================================================
--- cairo.orig/src/cairo-win32-font.c	2006-02-09 17:53:51.265625000 -0800
+++ cairo/src/cairo-win32-font.c	2006-02-09 17:54:49.062500000 -0800
@@ -1127,7 +1127,6 @@
 	return CAIRO_STATUS_SUCCESS;
 
     if (_cairo_surface_is_win32 (generic_surface) &&
-	surface->format == CAIRO_FORMAT_RGB24 &&
 	op == CAIRO_OPERATOR_OVER &&
 	_cairo_pattern_is_opaque_solid (pattern)) {
 
