<?xml version="1.0"?>

<bindings   id="autocompleteBindings"
            xmlns="http://www.mozilla.org/xbl"
            xmlns:html="http://www.w3.org/TR/REC-html40"
            xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<binding id="autocomplete" extends="resource:/chrome/xulBindings.xml#textfield">
    <content excludes="template,observes,menupopup">
        <xul:box flex="1"
            onkeydown=" me = this.parentNode;
                        me.callListener(me, 'stopLookup'); 
                        if (me.autoCompleteTimer) {
                            clearTimeout(me.autoCompleteTimer);
                            me.autoCompleteTimer = 0;
                        }"
            onkeyup="   me = this.parentNode;
                        if (me.autoCompleteTimer)
                            clearTimeout(me.autoCompleteTimer);
                        if (event.which != 13) {
                            me.needToAutocomplete = true;
                            me.autoCompleteTimer = setTimeout(me.callListener, me.timeout, me, 'startLookup');
                        }"
        >
            <html:input flex="1" inherits="value,type,maxlength,disabled,size,readonly"/>
            <xul:popupset>
                <xul:popup>
                </xul:popup>
            </xul:popupset>
        </xul:box>
    </content>

    <interface>
        <property name="timeout"    onset="return this.setAttribute('timeout', val);"
                                    onget="return this.getAttribute('timeout');"/>

        <property name="autoCompleteSession">
        <![CDATA[
            if (this.getAttribute('searchSessionType') != "") {
                searchSession = unescape('component:%2F%2Fnetscape%2FautocompleteSession%26type=');
                searchSession = searchSession + this.getAttribute('searchSessionType');
                try {
                    Components.classes[searchSession].getService(Components.interfaces.nsIAutoCompleteSession);
//                      var session = Components.classes[searchSession].createInstance();
//                      session.QueryInterface(Components.interfaces.nsIAutoCompleteSession);
                } catch (e) {dump("### ERROR, cannot create a search session. " + e + "\n");}
            }
        ]]>
        </property>

        <property name="autoCompleteTimer">
        <![CDATA[
            0;
        ]]>
        </property>

        <property name="lastResults">
        <![CDATA[
            var results = Components.classes["component://netscape/autocomplete/results"].createInstance();
            results.QueryInterface(Components.interfaces.nsIAutoCompleteResults);
        ]]>
        </property>

        <property name="autoCompleteListener">
        <![CDATA[
        ({
            onAutoComplete: function(result, status) {
                if (status == Components.interfaces.nsIAutoCompleteStatus.failed)
                    return;
                    
                this.param.lastResults = result;
                if (status == Components.interfaces.nsIAutoCompleteStatus.ignored || 
                    status == Components.interfaces.nsIAutoCompleteStatus.noMatch)
                    return;
                
                if (result == null && result.items.Count() == 0)
                    return;

                if (result.defaultItemIndex > result.items.Count())
                    result.defaultItemIndex = 0;
                
                item = result.items.QueryElementAt(result.defaultItemIndex, Components.interfaces.nsIAutoCompleteItem);
                
                //Time to build the new edit field value
                //First, check if the search string correspond to the current value of the field, else ignore it
                if (result.searchString != this.param.value)
                    return;

                match = item.value.toLowerCase();
                entry = this.param.value.toLowerCase();
                inputElement = this.param.anonymousContent[0].firstChild;
                
                if (entry != match)
                {
                    if (match.substring(0, entry.length) == entry)
                    {
                        this.param.value = this.param.value + item.value.substring(entry.length, match.length);
                        inputElement.setSelectionRange(entry.length, match.length);
                        this.param.noDirectMatch = false;
                    }
                    else
                   {
                        this.param.value = this.param.value + " >> " + item.value;
                        inputElement.setSelectionRange(entry.length, this.param.value.length);
                        this.param.noDirectMatch = true;
                   }
                }

                popupset = this.param.anonymousContent[0].childNodes[1];
                
                //Now, build the popup content
                popupElement = popupset.firstChild.cloneNode(false);
                for (i = 0; i < result.items.Count(); i ++)
                {
                    item = result.items.QueryElementAt(i, Components.interfaces.nsIAutoCompleteItem);
                    menuitem = document.createElement("menuitem");
                    menuitem.setAttribute('id', i);
                    menuitem.setAttribute('value', item.value);
                    popupElement.appendChild(menuitem);
                    dump("  match=" + item.value + "\n");
                }
                popupset.replaceChild(popupElement, popupset.firstChild);
//TODO: Select the default item
//                popupset.selectedItem = result.defaultItemIndex;                
//                popupset.firstChild.openPopup(this.param.anonymousContent[0].firstChild, -1, -1, "popup", "bottomleft", "topleft");
            },

            param: this
        })
        ]]>
        </property>

        <method name="callListener">
            <argument name="me"/>
            <argument name="action"/>
            <body>
            <![CDATA[
                switch (action) {
                    case 'startLookup':
                        if (!me.lastResults || me.value != me.lastResults.searchString)
                            me.autoCompleteSession.onStartLookup(me.value, me.lastResults, me.autoCompleteListener);
                        break;

                    case 'stopLookup':
                        //TODO: hide the popup menu now. How do we to that?
                        me.autoCompleteSession.onStopLookup();
                        break;

                    case 'autoComplete':
                        if (me.autoCompleteTimer) {
                            clearTimeout(me.autoCompleteTimer);
                            me.autoCompleteTimer = 0;
                        }
                        me.autoCompleteSession.onAutoComplete(me.value, me.lastResults, me.autoCompleteListener);
                        me.needToAutocomplete = false;
                        break;
                }
            ]]>
            </body>
        </method>
        
        <method name="finishAutoComplete">
            <argument name="event"/>
            <body>
            <![CDATA[
                inputElement = this.anonymousContent[0].firstChild;
                entry = this.value.substring(0, inputElement.selectionStart) + this.value.substring(inputElement.selectionEnd, this.value.length);

                if (this.lastResults)
                {
                    if (this.lastResults.searchString == entry)
                    {
                        try {
                            this.value = this.lastResults.items.QueryElementAt(this.lastResults.defaultItemIndex, Components.interfaces.nsIAutoCompleteItem).value;
                        } catch(e) {};
                        inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length);
                        return;
                    }
                }
                
                this.callListener(this, 'autoComplete');
            ]]>
            </body>
        </method>
        
    </interface>

    <handlers>
        <handler type="keydown" keycode="vk_return" value="this.finishAutoComplete(event);"/>

        <handler type="focus" value="this.needToAutocomplete = false;"/>

        <handler type="blur" value="
            if (this.needToAutocomplete)
                this.finishAutoComplete(event);
            "/>
    </handlers>

</binding> 
</bindings> 
