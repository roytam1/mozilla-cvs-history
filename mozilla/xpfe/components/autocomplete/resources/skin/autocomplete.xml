<?xml version="1.0"?>

<bindings   id="autocompleteBindings"
            xmlns="http://www.mozilla.org/xbl"
            xmlns:html="http://www.w3.org/TR/REC-html40"
            xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<binding id="autocomplete" extends="xul:box">
    <content excludes="template,observes,menupopup">
        <xul:box
            onkeydown=" me = this.parentNode;
                        me.callListener(me, event, 'stopLookup'); 
                        if (me.autoCompleteTimer) {
                            clearTimeout(me.autoCompleteTimer);
                            me.autoCompleteTimer = 0;
                        }"
            onkeyup="   me = this.parentNode;
                        if (me.autoCompleteTimer)
                            clearTimeout(me.autoCompleteTimer);
                        if (event.which != 13) {
                            me.needToAutocomplete = true;
                            me.autoCompleteTimer = setTimeout(me.callListener, me.timeout, me, event, 'startLookup');
                        }"
        >
            <xul:textfield class="addressingWidget" inherits="value,timeout"/>
            <xul:popupset>
                <xul:popup>
                </xul:popup>
            </xul:popupset>
        </xul:box>
    </content>

    <interface>
        <property name="value"      onset="return this.anonymousContent[0].firstChild.value = val;"
                                    onget="return this.anonymousContent[0].firstChild.value;"/>

        <property name="timeout"    onset="return this.setAttribute('timeout', val);"
                                    onget="return this.getAttribute('timeout');"/>

        <property name="autoCompleteSession">
        <![CDATA[
            if (this.getAttribute('searchSessionClass') != "") {
                searchSession = 'component://' + unescape(this.getAttribute('searchSessionClass'));
                try {
                    Components.classes[searchSession].getService(Components.interfaces.nsIAutoCompleteSession);
                } catch (e) {}
            }
        ]]>
        </property>

        <property name="autoCompleteTimer">
        <![CDATA[
            0;
        ]]>
        </property>

        <property name="autoCompleteListener">
        <![CDATA[
        ({
            onAutoComplete: function(result, status) {
                dump("onAutoComplete, result=" + result + ", status=" + status + "\n");
                this.param.lastResult = result;
                item = result.items.QueryElementAt(result.defaultItemIndex, Components.interfaces.nsIAutoCompleteItem);
                
                //Time to build the new edit field value
                //First, check if the search string correspond to the current value of the field, else ignore it
                if (result.searchString != this.param.value)
                    return;

                match = item.value.toLowerCase();
                entry = this.param.value.toLowerCase();
                inputElement = this.param.anonymousContent[0].firstChild.anonymousContent[0].firstChild;
                
                if (entry != match)
                {
                    if (match.substring(0, entry.length) == entry)
                    {
                        this.param.value = this.param.value + item.value.substring(entry.length, match.length);
                        inputElement.setSelectionRange(entry.length, match.length);
                    }
                    else
                   {
                        dump("oops, no direct match!\n");
//                        this.param.value = this.param.value + " " + item.value;
//                        inputElement.setSelectionRange(entry.length + 1, this.param.value.length);
                   }
                }

                popupset = this.param.anonymousContent[0].childNodes[1];
                dump("popupset=" + popupset + ", popup=" + popupset.firstChild + "\n");
                
                //Now, build the popup content
                popupElement = popupset.firstChild.cloneNode(false);
                for (i = 0; i < result.items.Count(); i ++)
                {
                    item = result.items.QueryElementAt(i, Components.interfaces.nsIAutoCompleteItem);
                    menuitem = document.createElement("menuitem");
                    menuitem.setAttribute('id', i);
                    menuitem.setAttribute('value', item.value);
                    popupElement.appendChild(menuitem);
                }
                popupset.replaceChild(popupElement, popupset.firstChild);
//TODO: Select the default item
//                popupset.selectedItem = result.defaultItemIndex;
                
//                popupset.firstChild.openPopup(this.param.anonymousContent[0].firstChild, -1, -1, "popup", "bottomleft", "topleft");
            },

            param: this
        })
        ]]>
        </property>

        <method name="callListener">
            <argument name="me"/>
            <argument name="event"/>
            <argument name="action"/>
            <body>
            <![CDATA[
                dump("callListener, action=" + action + ", me=" + me + "\n");
                switch (action) {
                    case 'startLookup':
                        dump('>>> startLookup...\n');
                        me.autoCompleteSession.onStartLookup(event, me.value, me.lastResult, me.autoCompleteListener);
                        break;

                    case 'stopLookup':
                        dump('>>> stopLookup...\n');
                        //TODO: hide the popup menu now. How do we to that?
                        me.autoCompleteSession.onStopLookup(event);
                        break;

                    case 'autoComplete':
                        dump('>>> autoComplete...\n');
                        if (me.autoCompleteTimer) {
                            clearTimeout(me.autoCompleteTimer);
                            me.autoCompleteTimer = 0;
                        }
                        me.autoCompleteSession.onAutoComplete(event, me.value, me.lastResult, me.autoCompleteListener);
                        me.needToAutocomplete = false;
                        break;
                }
            ]]>
            </body>
        </method>
        
        <method name="finishAutoComplete">
            <body>
            <![CDATA[
                inputElement = this.anonymousContent[0].firstChild.anonymousContent[0].firstChild;
                entry = this.value.substring(0, inputElement.selectionStart) + this.value.substring(inputElement.selectionEnd, this.value.length);

                if (this.lastResult)
                {
                    if (this.lastResult.searchString == entry)
                    {
                        dump('dont need to autocomplete again, just use previous result\n');
                        this.value = this.lastResult.items.QueryElementAt(this.lastResult.defaultItemIndex, Components.interfaces.nsIAutoCompleteItem).value;
                        return;
                    }
                }
                
                this.callListener(this, event, 'autoComplete');
            ]]>
            </body>
        </method>
        
    </interface>

    <handlers>
        <handler type="keypress" keycode="vk_return" value="this.finishAutoComplete();"/>

        <handler type="focus" value="this.needToAutocomplete = false;"/>

        <handler type="blur" value="
            if (this.needToAutocomplete)
                this.finishAutoComplete();
            "/>
    </handlers>

</binding> 

</bindings>
