<?xml version="1.0"?>

<bindings id="xulBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:html="http://www.w3.org/1999/xhtml"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
 
  <binding id="radio" extends="chrome://global/content/xulBindings.xml#checkbox">
    <implementation>
      <property name="data" onset="this.setAttribute('data',val); return val;"
                            onget="return this.getAttribute('data');"/>
      <property name="group" onset="this.setAttribute('group',val); return val;"
                            onget="return this.getAttribute('group');"/>
    </implementation>
  </binding>
  
  <binding id="radiogroup" extends="xul:box">

    <implementation>
      <property name="data" onset="this.setAttribute('data',val); return val;"
                            onget="return this.getAttribute('data');"/>
      <property name="selectedItem">
        <getter>
        <![CDATA[
          var groupElements = this.getElementsByAttribute( "group", this.id );
          for( var i = 0; i < groupElements.length; i++ ) {
            if( groupElements[i].checked || 
                groupElements[i].getAttribute( "checked" ) == "true" ) {
              return groupElements[i];
            }
          }
          return null;
        ]]>
        </getter>
        <setter>
        <![CDATA[
          var aDOMElement = val;
          if (this.getAttribute("focused") == "true") 
            val.setAttribute("focused", "true");
          this.data = aDOMElement.data;

          aDOMElement.checked = true;
          
          // uncheck all other group nodes
          var groupElements = this.getElementsByAttribute( "group", aDOMElement.group );
          for( var i = 0; i < groupElements.length; i++ )
            {
              if( groupElements[i] != aDOMElement && groupElements[i].checked )
                {
                  groupElements[i].checked = false;
                  groupElements[i].removeAttribute("checked");
                  groupElements[i].removeAttribute("focused");
                }
            }
          return val;
        ]]>
        </setter>        
      </property>
      <method name="checkAdjacentElement">
        <parameter name="aNextFlag"/>
        <body>
        <![CDATA[
          var radios = this.getElementsByTagName("radio");
          var index;
          for (var i = 0; i < radios.length; i++ ) {
            if (radios[i] != this.selectedItem) 
              continue;
            if (aNextFlag) {
              index = i + 1 < radios.length ? i + 1 : 0;
              this.selectedItem = radios[index];
              break;
            }
            else {              
              index = i - 1 >= 0 ? i - 1 : radios.length - 1;
              this.selectedItem = radios[index];
              break;
            }
          }
        ]]>
        </body>
      </method>
    </implementation>
    <handlers>
      <handler event="click" button="1">
        <![CDATA[
            if (event.target.localName == "radio" && !event.target.disabled)
              this.selectedItem = event.target;

         ]]>
      </handler>
      <handler event="keypress" key=" ">
        <![CDATA[
            if (event.target.localName == "radio" && !event.target.disabled)
              this.selectedItem = event.target;

        ]]>
      </handler>
     
      <!-- keyboard navigation -->
      <!-- Here's how keyboard navigation works in radio groups on Windows:
           The group takes 'focus'
           The user is then free to navigate around inside the group
           using the arrow keys. Accessing previous or following radio buttons
           is done solely through the arrow keys and not the tab button. Tab
           takes you to the next widget in the tab order -->
      <handler event="keypress" keycode="VK_UP">
        this.checkAdjacentElement(false);
      </handler>
      <handler event="keypress" keycode="VK_LEFT">
        this.checkAdjacentElement(false);
      </handler>
      <handler event="keypress" keycode="VK_DOWN">
        this.checkAdjacentElement(true);
      </handler>
      <handler event="keypress" keycode="VK_RIGHT">
        this.checkAdjacentElement(true);
      </handler>

      <!-- set a focused attribute on the selected item when the group
           receives focus so that we can style it as if it were focused even though
           it is not (Windows platform behaviour is for the group to receive focus,
           not the item -->
      <handler event="focus">
        this.setAttribute("focused", "true");
        this.selectedItem.setAttribute("focused", "true");
      </handler>
      <handler event="blur">
        this.removeAttribute("focused");
        this.selectedItem.removeAttribute("focused");
      </handler>
    </handlers>
  </binding>
  
</bindings>
