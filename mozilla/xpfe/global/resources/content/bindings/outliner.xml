<?xml version="1.0"?>

<bindings id="outlinerBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
  
  <binding id="outliner-base">
    <resources>
      <stylesheet src="chrome://global/content/bindings/outliner.css"/>
      <stylesheet src="chrome://global/skin/outliner.css"/>
    </resources>
  </binding>

  <binding id="outliner" extends="chrome://global/content/bindings/outliner.xml#outliner-base">
    <content orient="vertical">
      <xul:hbox class="outliner-columns">
        <children includes="outlinercol|splitter"/>
        <xul:outlinercol class="outliner-columnpicker" fixed="true" ordinal="2147483647"/>
      </xul:hbox>
      <xul:outlinerrows class="outliner-rows" flex="1">
        <children/>
      </xul:outlinerrows>
    </content>
    
    <implementation>
      <property name="outlinerBoxObject"
                onget="return this.boxObject.QueryInterface(Components.interfaces.nsIOutlinerBoxObject);"
                readonly="true"/>
      <property name="currentIndex"
                onget="return this.outlinerBoxObject.selection.currentIndex;"
                onset="return this.outlinerBoxObject.selection.currentIndex=val;"/>
      <field name="selectionHead">
        -1
      </field>
      <field name="selectionTail">
        -1
      </field>
      <property name="singleSelection"
                onget="return this.getAttribute('seltype') == 'single'"
                readonly="true"/>

      <property name="enableColumnDrag"
                onget="return this.getAttribute('enableColumnDrag') == 'true';"
                onset="this.setAttribute('enableColumnDrag', val); return val == 'true';"/>

      <property name="firstOrdinalColumn">
        <getter><![CDATA[
          var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var cols = this.getElementsByTagNameNS(xulns, "outlinercol");
          for (var i = 0; i < cols.length; ++i) {
            var parent = cols[i].boxObject.parentBox;
            if (parent)
              return parent.boxObject.firstChild;
          }
          return null;
        ]]></getter>
      </property>
      
      <field name="_columnsDirty">true</field>

      <method name="_ensureColumnOrder">
        <body><![CDATA[
          if (this._columnsDirty) {
            // update the ordinal position of each column to assure that it is
            // an odd number and 2 positions above it's next sibling
            var col = this.firstOrdinalColumn;
            var cols = [];
            while (col) {
              if (col.localName == "outlinercol" && col.parentNode == this)
                cols[cols.length] = col;
              col = col.boxObject.nextSibling;
            }
            var i;
            for (i = 0; i < cols.length; ++i)
              cols[i].setAttribute("ordinal", (i*2)+1);
              
            // update the ordinal positions of splitters to even numbers, so that 
            // they are in between columns
            var splitters = this.getElementsByTagName("splitter");
            for (i = 0; i < splitters.length; ++i)
              splitters[i].setAttribute("ordinal", (i+1)*2);
            
            this._columnsDirty = false;
          }
        ]]></body>
      </method>

      <method name="_reorderColumn">
        <parameter name="aColMove"/>
        <parameter name="aColBefore"/>
        <parameter name="aBefore"/>
        <body><![CDATA[
          this._ensureColumnOrder();
          
          var cols = [];
          var col;
          if (aColBefore.ordinal < aColMove.ordinal) {
            col = aColBefore;
            while (col) {
              if (col.localName == "outlinercol")
                cols.push(col);
              col = col.boxObject.nextSibling;
              if (col == aColMove)  
                break;
            }

            aColMove.ordinal = aColBefore.ordinal;
            var i;
            for (i = 0; i < cols.length; ++i)
              cols[i].ordinal += 2;
          } else {
            col = aColMove.boxObject.nextSibling;
            while (col) {
              if (col.localName == "outlinercol")
                cols.push(col);
              col = col.boxObject.nextSibling;
              if (col == aColBefore && aBefore)
                break;
            }

            aColMove.ordinal = aBefore ? aColBefore.ordinal-2 : aColBefore.ordinal;

            for (i = 0; i < cols.length; ++i)
              cols[i].ordinal -= 2;
          }
        ]]></body>
      </method>
      
      <method name="_getColumnAtX">
        <parameter name="aX"/>
        <parameter name="aThresh"/>
        <parameter name="aPos"/>
        <body><![CDATA[
          if (aPos) aPos.value = "before";

          var col = this.firstOrdinalColumn;
          var lastCol = null;
          var currentX = this.boxObject.x;
          while (col) {
            if (col.localName == "outlinercol" && col.parentNode == this) {
              var cw = col.boxObject.width;
              if (cw > 0) {
                currentX += cw;
                if (currentX - (cw*aThresh) > aX)
                  return col;
              }
              lastCol = col;
            }
            col = col.boxObject.nextSibling;
          }

          if (aPos) aPos.value = "after";
          return lastCol;
        ]]></body>
      </method>

    </implementation>
    
    <handlers>
      <handler event="focus" action="this.outlinerBoxObject.focused = true;"/>
      <handler event="blur" action="this.outlinerBoxObject.focused = false;"/>
  
      <handler event="dragenter" action="this.outlinerBoxObject.onDragEnter(event);"/>
      <handler event="dragexit" action="this.outlinerBoxObject.onDragExit(event);"/>
      <handler event="dragover" action="this.outlinerBoxObject.onDragOver(event);"/>
      <handler event="dragdrop" action="this.outlinerBoxObject.onDragDrop(event);"/>

      <handler event="keypress" keycode="vk_enter">
        <![CDATA[
         if (this.currentIndex == -1)
           return;
         if (this.outlinerBoxObject.view.isContainer(this.currentIndex))
           this.outlinerBoxObject.view.toggleOpenState(this.currentIndex);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_return">
        <![CDATA[
         if (this.currentIndex == -1)
           return;
         if (this.outlinerBoxObject.view.isContainer(this.currentIndex))
           this.outlinerBoxObject.view.toggleOpenState(this.currentIndex);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_left">
        <![CDATA[
         if (this.currentIndex == -1)
           return;
         if (!this.outlinerBoxObject.view.isContainer(this.currentIndex))
           return;
         if (this.outlinerBoxObject.view.isContainerOpen(this.currentIndex))
           this.outlinerBoxObject.view.toggleOpenState(this.currentIndex);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_right">
        <![CDATA[
         if (this.currentIndex == -1)
           return;
         if (!this.outlinerBoxObject.view.isContainer(this.currentIndex))
           return;
         if (!this.outlinerBoxObject.view.isContainerOpen(this.currentIndex))
           this.outlinerBoxObject.view.toggleOpenState(this.currentIndex);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_up">
        <![CDATA[
         var c = this.currentIndex;
         if (c == -1 || c == 0)
           return;
         this.selectionHead = -1;
         this.selectionTail = -1;
         this.outlinerBoxObject.selection.timedSelect(c-1, 500);
         this.outlinerBoxObject.ensureRowIsVisible(c-1);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_down">
        <![CDATA[
         var c = this.currentIndex;
         try { if (c+1 == this.outlinerBoxObject.view.rowCount)
           return;
         } catch (e) {}
         this.selectionHead = -1;
         this.selectionTail = -1;
         this.outlinerBoxObject.selection.timedSelect(c+1, 500);
         this.outlinerBoxObject.ensureRowIsVisible(c+1);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_up" modifiers="shift">
        <![CDATA[
         if (this.singleSelection)
           return;
         var c = this.currentIndex;
         if (c == -1 || c == 0)
           return;
         if (c == this.selectionTail) {
           if (this.selectionHead < this.selectionTail) {
             this.outlinerBoxObject.selection.toggleSelect(c);
             this.currentIndex = c - 1;
           }
           else {
             this.outlinerBoxObject.selection.toggleSelect(c - 1);
           }
         }
         else {
           this.outlinerBoxObject.selection.clearSelection();
           this.selectionHead = c;
           this.outlinerBoxObject.selection.rangedSelect(c, c - 1, true);
         }
         this.selectionTail = c - 1;
         this.outlinerBoxObject.ensureRowIsVisible(c - 1);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_down" modifiers="shift">
        <![CDATA[
         if (this.singleSelection)
           return;
         var c = this.currentIndex;
         try { if (c+1 == this.outlinerBoxObject.view.rowCount)
           return;
         } catch (e) {}
         if (c == this.selectionTail) {
           if (this.selectionHead > this.selectionTail) {
             this.outlinerBoxObject.selection.toggleSelect(c);
             this.currentIndex = c + 1;
           }
           else
             this.outlinerBoxObject.selection.toggleSelect(c + 1);
         }
         else {
           this.outlinerBoxObject.selection.clearSelection();
           this.selectionHead = c;
           this.outlinerBoxObject.selection.rangedSelect(c, c + 1, true);
         }
         this.selectionTail = c + 1;
         this.outlinerBoxObject.ensureRowIsVisible(c + 1);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_up" modifiers="control">
        <![CDATA[
         var c = this.currentIndex;
         if (c == -1 || c == 0)
           return;
         this.currentIndex = c-1;
         this.outlinerBoxObject.ensureRowIsVisible(c-1);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_down" modifiers="control">
        <![CDATA[
         var c = this.currentIndex;
         try { if (c+1 == this.outlinerBoxObject.view.rowCount)
           return;
         } catch (e) {}
         this.currentIndex = c+1;
         this.outlinerBoxObject.ensureRowIsVisible(c+1);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_up">
        <![CDATA[
         var c = this.currentIndex;
         if (c == 0)
           return;
         this.selectionHead = -1;
         this.selectionTail = -1;
         var f = this.outlinerBoxObject.getFirstVisibleRow();
         var i = 0;
         if (f > 0) {
           var p = this.outlinerBoxObject.getPageCount();
           if (f - p >= 0)
             i = c - p;
           else
             i = c - f;
           this.outlinerBoxObject.scrollByPages(-1);
         }
         this.outlinerBoxObject.selection.timedSelect(i, 500);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_down">
        <![CDATA[
         var c = this.currentIndex;
         var l = this.outlinerBoxObject.view.rowCount - 1;
         if (c == l)
           return;
         this.selectionHead = -1;
         this.selectionTail = -1;
         var f = this.outlinerBoxObject.getFirstVisibleRow();
         var p = this.outlinerBoxObject.getPageCount();
         var i = l;
         var lastTopRowIndex = l - p;
         if (f <= lastTopRowIndex) {
           if (f + p <= lastTopRowIndex)
             i = c + p;
           else
             i = lastTopRowIndex + c - f + 1;
           this.outlinerBoxObject.scrollByPages(1);
         }
         this.outlinerBoxObject.selection.timedSelect(i, 500);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_up" modifiers="shift">
        <![CDATA[
         if (this.singleSelection)
           return;
         var c = this.currentIndex;
         if (c == 0)
           return;
         var f = this.outlinerBoxObject.getFirstVisibleRow();
         var i = 0;
         if (f > 0) {
           var p = this.outlinerBoxObject.getPageCount();
           if (f - p >= 0)
             i = c - p;
           else
             i = c - f;
           this.outlinerBoxObject.scrollByPages(-1);
         }
         if (c == this.selectionTail) {
           if (this.selectionHead < this.selectionTail) {
             if (i < this.selectionHead) {
               this.outlinerBoxObject.selection.clearRange(c, this.selectionHead + 1);
               this.outlinerBoxObject.selection.rangedSelect(this.selectionHead - 1, i, true);
             }
             else {
               this.outlinerBoxObject.selection.clearRange(c, i + 1);
               this.currentIndex = i;
             }
           }
           else
             this.outlinerBoxObject.selection.rangedSelect(c - 1, i, true);
         }
         else {
           this.outlinerBoxObject.selection.clearSelection();
           this.selectionHead = c;
           this.outlinerBoxObject.selection.rangedSelect(c, i, true);
         }
         this.selectionTail = i;
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_down" modifiers="shift">
        <![CDATA[
         if (this.singleSelection)
           return;
         var c = this.currentIndex;
         var l = this.outlinerBoxObject.view.rowCount - 1;
         if (c == l)
           return;
         var f = this.outlinerBoxObject.getFirstVisibleRow();
         var p = this.outlinerBoxObject.getPageCount();
         var i = l;
         var lastTopRowIndex = l - p;
         if (f <= lastTopRowIndex) {
           if (f + p <= lastTopRowIndex)
             i = c + p;
           else
             i = lastTopRowIndex + c - f + 1;
           this.outlinerBoxObject.scrollByPages(1);
         }
         if (c == this.selectionTail) {
           if (this.selectionHead > this.selectionTail) {
             if (i > this.selectionHead) {
               this.outlinerBoxObject.selection.clearRange(c, this.selectionHead - 1);
               this.outlinerBoxObject.selection.rangedSelect(this.selectionHead + 1, i, true);
             }
             else {
               this.outlinerBoxObject.selection.clearRange(c, i - 1);
               this.currentIndex = i;
             }
           }
           else
             this.outlinerBoxObject.selection.rangedSelect(c + 1, i, true);
         }
         else {
           this.outlinerBoxObject.selection.clearSelection();
           this.selectionHead = c;
           this.outlinerBoxObject.selection.rangedSelect(c, i, true);
         }
         this.selectionTail = i;
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_up" modifiers="control">
        <![CDATA[
         var c = this.currentIndex;
         if (c == 0)
           return;
         var f = this.outlinerBoxObject.getFirstVisibleRow();
         var i = 0;
         if (f > 0) {
           var p = this.outlinerBoxObject.getPageCount();
           if (f - p >= 0)
             i = c - p;
           else
             i = c - f;
           this.outlinerBoxObject.scrollByPages(-1);
         }
         this.currentIndex = i;
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_page_down" modifiers="control">
        <![CDATA[
         var c = this.currentIndex;
         var l = this.outlinerBoxObject.view.rowCount - 1;
         if (c == l)
           return;
         var f = this.outlinerBoxObject.getFirstVisibleRow();
         var p = this.outlinerBoxObject.getPageCount();
         var i = l;
         var lastTopRowIndex = l - p;
         if (f <= lastTopRowIndex) {
           if (f + p <= lastTopRowIndex)
             i = c + p;
           else
             i = lastTopRowIndex + c - f + 1;
           this.outlinerBoxObject.scrollByPages(1);
         }
         this.currentIndex = i;
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_home">
        <![CDATA[
         if (this.currentIndex == 0)
           return;
         this.selectionHead = -1;
         this.selectionTail = -1;
         this.outlinerBoxObject.selection.timedSelect(0, 500);
         this.outlinerBoxObject.ensureRowIsVisible(0);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_end">
        <![CDATA[
         var l = this.outlinerBoxObject.view.rowCount - 1;
         if (this.currentIndex == l)
           return;
         this.selectionHead = -1;
         this.selectionTail = -1;
         this.outlinerBoxObject.selection.timedSelect(l, 500);
         this.outlinerBoxObject.ensureRowIsVisible(l);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_home" modifiers="shift">
        <![CDATA[
         if (this.singleSelection)
           return;
         var c = this.currentIndex;
         if (c == 0)
           return;
         if (c != this.selectionTail) {
           this.outlinerBoxObject.selection.clearSelection();
           this.selectionHead = c;
         }
         this.outlinerBoxObject.selection.rangedSelect(c, 0, true);
         this.selectionTail = 0;
         this.outlinerBoxObject.ensureRowIsVisible(0);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_end" modifiers="shift">
        <![CDATA[
         if (this.singleSelection)
           return;
         var c = this.currentIndex;
         var l = this.outlinerBoxObject.view.rowCount - 1;
         if (c == l)
           return;
         if (c != this.selectionTail) {
           this.outlinerBoxObject.selection.clearSelection();
           this.selectionHead = c;
         }
         this.outlinerBoxObject.selection.rangedSelect(c, l, true);
         this.selectionTail = l;
         this.outlinerBoxObject.ensureRowIsVisible(l);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_home" modifiers="control">
        <![CDATA[
         if (this.currentIndex == 0)
           return;
         this.currentIndex = 0;
         this.outlinerBoxObject.ensureRowIsVisible(0);
        ]]>
      </handler>
      <handler event="keypress" keycode="vk_end" modifiers="control">
        <![CDATA[
         var l = this.outlinerBoxObject.view.rowCount - 1;
         if (this.currentIndex == l)
           return;
         this.currentIndex = l;
         this.outlinerBoxObject.ensureRowIsVisible(l);
        ]]>
      </handler>
      <handler event="keypress">
        <![CDATA[
         if (event.keyCode == ' ') {
           var c = this.currentIndex;
           if (!this.outlinerBoxObject.selection.isSelected(c))
             this.outlinerBoxObject.selection.toggleSelect(c);
         }
         ]]>
      </handler>
    </handlers>    
  </binding>

  <binding id="outlinerrows" extends="chrome://global/content/bindings/outliner.xml#outliner-base">
    <resources>
      <stylesheet src="chrome://global/content/bindings/outliner.css"/>
      <stylesheet src="chrome://global/skin/outliner.css"/>
    </resources>

    <content>
      <xul:hbox flex="1" class="outliner-bodybox">
        <children/>
      </xul:hbox>
      <xul:scrollbar orient="vertical" class="outliner-scrollbar"/>
    </content>
  </binding>

  <binding id="outlinerbody" extends="chrome://global/content/bindings/outliner.xml#outliner-base">
    <implementation>
      <constructor>
        if ("_ensureColumnOrder" in this.parentNode)
          this.parentNode._ensureColumnOrder();
      </constructor>

      <field name="_lastSelectedRow">
        -1
      </field>
    </implementation>
    <handlers>
      <!-- If there is no modifier key, we select on mousedown, not
           click, so that drags work correctly. -->
      <handler event="mousedown">
      <![CDATA[
         if (!event.ctrlKey && !event.shiftKey && !event.metaKey) {
           var row = {};
           var col = {};
           var obj = {};
           var b = this.parentNode.outlinerBoxObject;
           b.getCellAt(event.clientX, event.clientY, row, col, obj);

           // save off the last selected row
           this._lastSelectedRow = row.value;

           try {
             if (row.value >= b.view.rowCount) return;
           } catch (e) { return; }
            
		   if (obj.value != "twisty") {
		     var column = document.getElementById(col.value);
		     var cycler = column.getAttribute('cycler') == 'true';

		     if (cycler)
			   b.view.cycleCell(row.value, col.value);
		     else
			   if (!b.selection.isSelected(row.value))
			     b.selection.select(row.value);
		   }
         }
      ]]>
      </handler>

      <!-- On a click (up+down on the same item), deselect everything
           except this item. -->
      <handler event="click">
      <![CDATA[
         if (event.button != 0) return;
         var row = {};
         var col = {};
		 var obj = {};
         var b = this.parentNode.outlinerBoxObject;
         b.getCellAt(event.clientX, event.clientY, row, col, obj);

         try {
           if (row.value >= b.view.rowCount) return;
         } catch (e) { return; }

		 if (obj.value == "twisty") {
           b.view.toggleOpenState(row.value);
		   return;
		 }

         var augment = event.ctrlKey || event.metaKey;
         if (event.shiftKey)
           b.selection.rangedSelect(-1, row.value, augment);
         else if (augment) {
           b.selection.toggleSelect(row.value);
           b.selection.currentIndex = row.value;
         }
         else {
          /* We want to deselect all the selected items except what was
            clicked, UNLESS it was a right-click.  We have to do this
            in click rather than mousedown so that you can drag a
            selected group of items */

           var column = document.getElementById(col.value);
           var cycler = column.getAttribute('cycler') == 'true';

           // if the last row has changed in between the time we 
           // mousedown and the time we click, don't fire the select handler.
           // see bug #92366
           if (!cycler && this._lastSelectedRow == row.value)
             b.selection.select(row.value);  
         }
      ]]>
      </handler>

      <!-- double-click -->
      <handler event="click" clickcount="2">
      <![CDATA[
           var row = {};
           var col = {};
		   var obj = {};
           var b = this.parentNode.outlinerBoxObject;
           b.getCellAt(event.clientX, event.clientY, row, col, obj);

           try {
             if (row.value >= b.view.rowCount) return;
           } catch (e) { return; }
		   var column = document.getElementById(col.value);
		   var cycler = column.getAttribute('cycler') == 'true';

		   if (!cycler && obj.value != "twisty" && b.view.isContainer(row.value))
             b.view.toggleOpenState(row.value);
      ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="outlinercol-base" extends="chrome://global/content/bindings/outliner.xml#outliner-base">
    <implementation>
      <constructor>
        this.parentNode._columnsDirty = true;
      </constructor>

      <property name="ordinal">
        <getter><![CDATA[
          var val = this.getAttribute("ordinal");
          return val == "" ? 1 : (val == "0" ? 0 : parseInt(val));
        ]]></getter>
        <setter><![CDATA[
          this.setAttribute("ordinal", val);
        ]]></setter>
      </property>
      
      <property name="_previousVisibleColumn">
        <getter><![CDATA[
          var sib = this.boxObject.previousSibling;
          while (sib) {
            if (sib.localName == "outlinercol" && sib.boxObject.width > 0 && sib.parentNode == this.parentNode)
              return sib;
            sib = sib.boxObject.previousSibling;
          }
          return null;
        ]]></getter>
      </property>

      <method name="onDragMouseMove">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var col = document.outlinercolDragging;
          if (!col) return;

          if (col.mDragGesturing) {
            if (Math.abs(aEvent.clientX - col.mStartDragX) < 5 &&
                Math.abs(aEvent.clientY - col.mStartDragY) < 5) {
              return;
            } else {
              col.mDragGesturing = false;
              col.setAttribute("dragging", "true");
            }
          }
                    
          var pos = {};
          var targetCol = col.parentNode._getColumnAtX(aEvent.clientX, 0.5, pos);
          
          if (col.mTargetCol == targetCol && col.mTargetDir == pos.value)
            return;
            
          if (col.mTargetCol) {
            // remove previous insertbefore/after attributes
            col.mTargetCol.removeAttribute("insertbefore");
            col.mTargetCol.removeAttribute("insertafter");
            var sib = col.mTargetCol.boxObject.previousSibling;
            var sib = col.mTargetCol._previousVisibleColumn;
            if (sib)
              sib.removeAttribute("insertafter");
            col.mTargetCol = null;
            col.mTargetDir = null;
          }
          
          if (targetCol) {
            // set insertbefore/after attributes
            if (pos.value == "after") {
              targetCol.setAttribute("insertafter", "true");
            } else {
              targetCol.setAttribute("insertbefore", "true");
              var sib = targetCol._previousVisibleColumn;
              if (sib)
                sib.setAttribute("insertafter", "true");
            }
            col.mTargetCol = targetCol;
            col.mTargetDir = pos.value;
          }
          
          // XXX should really just invalidate columns
          // XXX need to implement nsIOutlinerBoxObject::invalidateColumn(in long column)
          var bx = col.parentNode.boxObject.QueryInterface(Components.interfaces.nsIOutlinerBoxObject);
          bx.invalidate();
        ]]></body>        
      </method>

      <method name="onDragMouseUp">
        <parameter name="aEvent"/>
        <body><![CDATA[
          var col = document.outlinercolDragging;
          if (!col) return;
          col.removeAttribute("dragging", "true");
          
          if (col.mTargetCol) {
            // remove insertbefore/after attributes
            var before = col.mTargetCol.hasAttribute("insertbefore");
            col.mTargetCol.removeAttribute(before ? "insertbefore" : "insertafter");
            if (before) {
              var sib = col.mTargetCol.boxObject.previousSibling;
              var sib = col.mTargetCol._previousVisibleColumn;
              if (sib)
                sib.removeAttribute("insertafter");
            }
                        
            // move the column
            if (col != col.mTargetCol)
              col.parentNode._reorderColumn(col, col.mTargetCol, before);
          
            // repaint to remove lines
            var bx = col.parentNode.boxObject.QueryInterface(Components.interfaces.nsIOutlinerBoxObject);
            bx.invalidate();

            col.mTargetCol = null;
          }
          
          document.outlinercolDragging = null;
        ]]></body>        
      </method>

    </implementation>
    
    <handlers>
      <handler event="mousedown" button="0"><![CDATA[
        if (this.parentNode.enableColumnDrag) {
          var xulns = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          var cols = this.parentNode.getElementsByTagNameNS(xulns, "outlinercol");
          
          // only start column drag operation if there are at least 2 visible columns
          var visible = 0;
          for (var i = 0; i < cols.length; ++i)
            if (cols[i].boxObject.width > 0) ++visible;
            
          if (visible > 1) {
            window.addEventListener("mousemove", this.onDragMouseMove, false);
            window.addEventListener("mouseup", this.onDragMouseUp, false);
            document.outlinercolDragging = this;
            this.mDragGesturing = true;
            this.mStartDragX = event.clientX;
            this.mStartDragY = event.clientY;
          }
        }
      ]]></handler>
    </handlers>
  </binding>

  <binding id="outlinercol" extends="chrome://global/content/bindings/outliner.xml#outlinercol-base">
    <content>
      <xul:hbox class="outlinercol-box" flex="1" align="center">
        <xul:image class="outliner-image" inherits="src"/>
        <xul:label class="outlinercol-text" inherits="crop,value=label" flex="1" crop="right"/>
        <xul:image class="outlinercol-sortdirection"/>
      </xul:hbox>
    </content>
    <handlers>
      <handler event="click" button="0" action="if (event.originalTarget == this) { this.parentNode.outlinerBoxObject.view.cycleHeader(this.id, this); }"/>
    </handlers>
  </binding>

  <binding id="outlinercol-image" extends="chrome://global/content/bindings/outliner.xml#outlinercol-base">
    <content>
      <xul:hbox class="outlinercol-image-box" flex="1" align="center">
        <xul:image class="outlinercol-icon" inherits="src"/>
      </xul:hbox>
    </content>
    <handlers>
      <handler event="click" button="0" action="this.parentNode.outlinerBoxObject.view.cycleHeader(this.id, this)"/>
    </handlers>
  </binding>

  <binding id="columnpicker" extends="chrome://global/content/bindings/outliner.xml#outliner-base">
    <content>
      <xul:menu class="outliner-colpicker-menu" align="center" allowevents="true">
        <xul:image class="outliner-colpicker-icon"/>
        <xul:menupopup popupanchor="bottomright" popupalign="topright"
                  onpopupshowing="this.parentNode.parentNode.buildPopup(this);"/>
      </xul:menu>
    </content>
    
    <implementation>
       <method name="buildPopup">
         <parameter name="aPopup"/>
         <body>
           <![CDATA[
             var currCol = this.parentNode.parentNode.firstChild;

             // we no longer cache the picker content.  
             // remove the old content
             while (aPopup.childNodes.length) {
               aPopup.removeChild(aPopup.childNodes[0]);
             }


             while (currCol) {
               while (currCol && currCol.localName != "outlinercol")
                 currCol = currCol.nextSibling;
 
               if (currCol && (currCol != this)) {
                 // Construct an entry for each cell in the row, unless
                 // it is not being show
                 if (currCol.getAttribute("ignoreincolumnpicker") != "true") {
                     var columnName = currCol.getAttribute("label");
                     var popupChild = document.createElement("menuitem");
                     popupChild.setAttribute("type", "checkbox");
                     if (columnName == "") {
                       var display = currCol.getAttribute("display");
                       popupChild.setAttribute("label", display);
                     }
                     else {
                       popupChild.setAttribute("label", columnName);
                     }
                     popupChild.setAttribute("colid", currCol.id);
                     popupChild.setAttribute("oncommand",
                                             "this.parentNode.parentNode.parentNode.toggleColumnState(this);");
                     if (currCol.getAttribute("hidden") != "true")
                       popupChild.setAttribute("checked", "true");
                     if (currCol.getAttribute("primary") == "true")
                       popupChild.setAttribute("disabled", "true");


                     aPopup.appendChild(popupChild);
                 }
              } 
              if (currCol) 
                currCol = currCol.nextSibling;
            }
           ]]>
        </body>
       </method>
       <method name="toggleColumnState">
         <parameter name="aPopup"/>
         <body>
           <![CDATA[
             var colid = aPopup.getAttribute("colid");
             var colNode = document.getElementById(colid);
             if (colNode) {
               var checkedState = aPopup.getAttribute("checked");
               if (checkedState == "true")
                 colNode.removeAttribute("hidden");
               else
                 colNode.setAttribute("hidden", "true");
             }
           ]]>
         </body>
       </method>         
     </implementation>    
   </binding>
</bindings>

