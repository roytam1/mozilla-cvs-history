/*
 * ************* DO NOT EDIT THIS FILE ***********
 *
 * This file was automatically generated from nsIFile.idl.
 */


package org.mozilla.xpcom;


/**
 * Interface nsIFile
 *
 * IID: 0xc8c0a080-0868-11d3-915f-d9d889d48e3c
 */

public interface nsIFile extends nsISupports
{
    public static final String IID =
        "c8c0a080-0868-11d3-915f-d9d889d48e3c";

    /**
     *   Create Types
     *
     *   NORMAL_FILE_TYPE - A normal file.
     *   DIRECTORY_TYPE   - A directory/folder.
     */

    /* const unsigned long NORMAL_FILE_TYPE = 0; */
    public static final int NORMAL_FILE_TYPE = 0;

    /* const unsigned long DIRECTORY_TYPE = 1; */
    public static final int DIRECTORY_TYPE = 1;
    /**
     *  appendPath
     *
     *  This function is used for constructing a descendant of the
     *  current nsIFile.
     *
     *  @param relativePath
     *      A string which is intented to be a child node of the
     *      nsIFile.
     */

    /* void append ([const] in string node); */
    public void append(String node);

    /* void appendUnicode ([const] in wstring node); */
    public void appendUnicode(String node);
    /**
     * Normalize the pathName (e.g. removing .. and . components on Unix).
     */

    /* void normalize (); */
    public void normalize();
    /**
     *  create
     *
     *  This function will create a new file or directory in the
     *  file system. Any nodes that have not been created or
     *  resolved, will be.  If the file or directory already
     *  exists create() will return NS_ERROR_FILE_ALREADY_EXISTS.
     *
     *   @param type
     *       This specifies the type of file system object
     *       to be made.  The only two types at this time
     *       are file and directory which are defined above.
     *       If the type is unrecongnized, we will return an
     *       error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     *   @param permissions
     *       The unix style octal permissions.  This may
     *       be ignored on systems that do not need to do
     *       permissions.
     */

    /* void create (in unsigned long type, in unsigned long permissions); */
    public void create(int type, int permissions);
    /**
     *   Accessor to the leaf name of the file itself.
     */

    /* attribute string leafName; */
    public String getLeafName();
    public void setLeafName(String value);

    /* attribute wstring unicodeLeafName; */
    public String getUnicodeLeafName();
    public void setUnicodeLeafName(String value);
    /**
     *  copyTo
     *
     *  This will copy this file to the specified newParentDir.
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
     *  copyTo will NOT resolve aliases/shortcuts during the copy.
     *
     *   @param newParentDir
     *       This param is the destination directory. If the
     *       newParentDir is null, copyTo() will use the parent
     *       directory of this file. If the newParentDir is not
     *       null and is not a directory, an error will be
     *       returned (NS_ERROR_FILE_DESTINATION_NOT_DIR)
     *
     *   @param newName
     *       This param allows you to specify a new name for
     *       the file to be copied. This param may be null, in
     *       which case the current leaf name will be used.
     *
     */

    /* void copyTo (in nsIFile newParentDir, [const] in string newName); */
    public void copyTo(nsIFile newParentDir, String newName);

    /* void copyToUnicode (in nsIFile newParentDir, [const] in wstring newName); */
    public void copyToUnicode(nsIFile newParentDir, String newName);
    /**
     *  copyToFollowingLinks
     *
     *  This function is identical to copyTo except it, as
     *  the name implies, follows symbolic links.  Some OSes
     *  such as Unix and Linux always follow symbolic links
     *  when copying.
     */

    /* void copyToFollowingLinks (in nsIFile newParentDir, [const] in string newName); */
    public void copyToFollowingLinks(nsIFile newParentDir, String newName);

    /* void copyToFollowingLinksUnicode (in nsIFile newParentDir, [const] in wstring newName); */
    public void copyToFollowingLinksUnicode(nsIFile newParentDir, String newName);
    /**
     *  moveTo
     *
     *  This will move this file to the specified newParentDir.
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
     *  moveTo will NOT resolve aliases/shortcuts during the copy.
     *  moveTo will do the right thing and allow copies across
     *  volumes.
     *
     *   @param newParentDir
     *       This param is the destination directory. If the
     *       newParentDir is null, moveTo() will rename the file
     *       within its current directory. If the newParentDir is
     *       not null and does not name a directory, an error will
     *       be returned (NS_ERROR_FILE_DESTINATION_NOT_DIR)
     *
     *   @param newName
     *       This param allows you to specify a new name for
     *       the file to be moved. This param may be null, in
     *       which case the current leaf name will be used.
     *
     */

    /* void moveTo (in nsIFile newParentDir, [const] in string newName); */
    public void moveTo(nsIFile newParentDir, String newName);

    /* void moveToUnicode (in nsIFile newParentDir, [const] in wstring newName); */
    public void moveToUnicode(nsIFile newParentDir, String newName);
    /**
     *  This will try to execute this file.  It will not block for
     *  execution.  'args' will be passed through on the command line
     *  if the OS supports that.
     */

    /* void spawn ([array, size_is (count)] in string args, in unsigned long count); */
    public void spawn(String[] args, int count);
    /**
     *  This will try to delete this file.  The 'recursive' flag
     *  must be PR_TRUE to delete directories which are not empty.
     *
     *  This will not resolve any symlinks.
     */

    /* void delete (in boolean recursive); */
    public void delete(boolean recursive);
    /**
     *  Attributes of nsIFile.
     */

    /* attribute unsigned long permissions; */
    public int getPermissions();
    public void setPermissions(int value);

    /* attribute unsigned long permissionsOfLink; */
    public int getPermissionsOfLink();
    public void setPermissionsOfLink(int value);
    /**
     *  File Times are to be in milliseconds from
     *  midnight (00:00:00), January 1, 1970 Greenwich Mean
     *  Time (GMT).
     */

    /* attribute PRInt64 lastModificationDate; */
    public long getLastModificationDate();
    public void setLastModificationDate(long value);

    /* attribute PRInt64 lastModificationDateOfLink; */
    public long getLastModificationDateOfLink();
    public void setLastModificationDateOfLink(long value);
    /**
     * WARNING!  On the Mac getting/setting the file size with nsIFile
     * only deals with the size of the data fork.  If you need to
     * know the size of the combined data and resource forks use the
     * GetFileSizeWithResFork() method defined in nsILocalFileMac.h
     */

    /* attribute PRInt64 fileSize; */
    public long getFileSize();
    public void setFileSize(long value);

    /* readonly attribute PRInt64 fileSizeOfLink; */
    public long getFileSizeOfLink();
    /**
     *  target & path
     *
     *  Accessor to the string path.  These strings are
     *  not guaranteed to be a usable path to pass to NSPR
     *  or the C stdlib.  There are problems that affect
     *  platforms on which a path does not fully specify a
     *  file, because two volumes can have the same name.
     *  This is solved by holding "private", native data in
     *  the nsIFile implementation.  This native data is lost
     *  when you convert to a string.
     *
     *      DO NOT PASS TO USE WITH NSPR OR STDLIB.
     *
     *  target:
     *      Find out what the symlink points at.  Will give error
     *      (NS_ERROR_FILE_INVALID_PATH) if not a symlink.
     *
     *  path:
     *      Find out what the nsIFile points at.
     */

    /* readonly attribute string target; */
    public String getTarget();

    /* readonly attribute wstring unicodeTarget; */
    public String getUnicodeTarget();

    /* readonly attribute string path; */
    public String getPath();

    /* readonly attribute wstring unicodePath; */
    public String getUnicodePath();

    /* boolean exists (); */
    public boolean exists();

    /* boolean isWritable (); */
    public boolean isWritable();

    /* boolean isReadable (); */
    public boolean isReadable();

    /* boolean isExecutable (); */
    public boolean isExecutable();

    /* boolean isHidden (); */
    public boolean isHidden();

    /* boolean isDirectory (); */
    public boolean isDirectory();

    /* boolean isFile (); */
    public boolean isFile();

    /* boolean isSymlink (); */
    public boolean isSymlink();
    /**
     * Not a regular file, not a directory, not a symlink.
     */

    /* boolean isSpecial (); */
    public boolean isSpecial();
    /**
     *  createUnique
     *  
     *  This function will create a new file or directory in the
     *  file system. Any nodes that have not been created or
     *  resolved, will be.  If this file already exists, we try
     *  variations on the leaf name "suggestedName" until we find
     *  one that did not already exist.
     *
     *  If the search for nonexistent files takes too long
     *  (thousands of the variants already exist), we give up and
     *  return NS_ERROR_FILE_TOO_BIG.
     *
     *   @param type
     *       This specifies the type of file system object
     *       to be made.  The only two types at this time
     *       are file and directory which are defined above.
     *       If the type is unrecongnized, we will return an
     *       error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     *   @param permissions
     *       The unix style octal permissions.  This may
     *       be ignored on systems that do not need to do
     *       permissions.
     */

    /* void createUnique (in string suggestedName, in unsigned long type, in unsigned long permissions); */
    public void createUnique(String suggestedName, int type, int permissions);
    /**
      * clone()
      *
      * This function will allocate and initialize a nsIFile object to the
      * exact location of the |this| nsIFile.
      *
      *   @param file
      *          A nsIFile which this object will be initialize
      *          with.
      *
      */

    /* nsIFile clone (); */
    /* public nsIFile clone(); */
    /**
     *  Will determine if the inFile equals this.
     */

    /* boolean equals (in nsIFile inFile); */
    public boolean equals(nsIFile inFile);
    /**
     * Will determine if inFile is a descendant of this file
     * If |recur| is true, look in subdirectories too
     */

    /* boolean contains (in nsIFile inFile, in boolean recur); */
    public boolean contains(nsIFile inFile, boolean recur);
    /**
     * Parent will be null when this is at the top of the volume.
     */

    /* readonly attribute nsIFile parent; */
    public nsIFile getParent();
    /**
     * Returns an enumeration of the elements in a directory. Each
     * element in the enumeration is an nsIFile.
     *
     *   @return NS_ERROR_FILE_NOT_DIRECTORY if the current nsIFile does
     *           not specify a directory.
     */

    /* readonly attribute nsISimpleEnumerator directoryEntries; */
    public nsISimpleEnumerator getDirectoryEntries();
    /**
     * Accesses the file: url for the nsIFile. Setting this causes the path
     * to be reset.
     */

    /* attribute string URL; */
    public String getURL();
    public void setURL(String value);

}

/*
 * end
 */
