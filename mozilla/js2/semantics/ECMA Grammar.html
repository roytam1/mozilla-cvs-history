<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>ECMA Grammar</TITLE>
<LINK rel="stylesheet" href="styles.css">
</HEAD>

<BODY>
<H2>Types</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Value</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">nullValue</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">stringValue</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">ObjectOrNull</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN
class="field-name">nullObjectOrNull</SPAN>;&nbsp;<SPAN
class="field-name">objectObjectOrNull</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Object</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">tuple</SPAN>&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">properties</SPAN>:&nbsp;<SPAN class="type-name">Property</SPAN>[]<SPAN
class="symbol">­</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">typeofName</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">prototype</SPAN>:&nbsp;<SPAN class="type-name">ObjectOrNull</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">get</SPAN>:&nbsp;<SPAN class="type-name">PropName</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">put</SPAN>:&nbsp;<SPAN class="type-name">PropName</SPAN>&nbsp;&#215;&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;<SPAN class="symbol">®</SPAN>&nbsp;<SPAN
class="type-name">VoidOrException</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">delete</SPAN>:&nbsp;<SPAN class="type-name">PropName</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">BooleanOrException</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">call</SPAN>:&nbsp;<SPAN
class="type-name">ObjectOrNull</SPAN>&nbsp;&#215;&nbsp;<SPAN
class="type-name">Value</SPAN>[]&nbsp;<SPAN class="symbol">®</SPAN>&nbsp;<SPAN
class="type-name">ReferenceOrException</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">construct</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>[]&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ObjectOrException</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">defaultValue</SPAN>:&nbsp;<SPAN
class="type-name">DefaultValueHint</SPAN>&nbsp;<SPAN class="symbol">®</SPAN>&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">DefaultValueHint</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">noHint</SPAN>;&nbsp;<SPAN
class="field-name">numberHint</SPAN>;&nbsp;<SPAN class="field-name">stringHint</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Property</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">tuple</SPAN>&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">name</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">readOnly</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">enumerable</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">permanent</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">value</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN><SPAN
class="symbol">­</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">PropName</SPAN>&nbsp;=&nbsp;<SPAN class="type-name">String</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Place</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">tuple</SPAN>&nbsp;{<SPAN class="field-name">base</SPAN>:&nbsp;<SPAN
class="type-name">Object</SPAN>;&nbsp;<SPAN class="field-name">property</SPAN>:&nbsp;<SPAN
class="type-name">PropName</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Reference</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN
class="field-name">valueReference</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>;&nbsp;<SPAN
class="field-name">placeReference</SPAN>:&nbsp;<SPAN class="type-name">Place</SPAN>;&nbsp;<SPAN
class="field-name">virtualReference</SPAN>:&nbsp;<SPAN class="type-name">PropName</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">IntegerOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">VoidOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>;&nbsp;<SPAN
class="field-name">abrupt</SPAN>:&nbsp;<SPAN class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">BooleanOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">DoubleOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">StringOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">String</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">ObjectOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Object</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">ReferenceOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>;&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">ValueListOrException</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">normal</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>[];&nbsp;<SPAN class="field-name">abrupt</SPAN>:&nbsp;<SPAN
class="type-name">Exception</SPAN>}</SPAN></P>

<H2>Helper Functions</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="global-variable">objectOrNullToValue</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">ObjectOrNull</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">Value</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">o</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">nullObjectOrNull</SPAN>:&nbsp;<SPAN class="field-name">nullValue</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectObjectOrNull</SPAN>(<SPAN class="local-variable">obj</SPAN>:&nbsp;<SPAN
class="type-name">Object</SPAN>):&nbsp;<SPAN class="field-name">objectValue</SPAN>&nbsp;<SPAN
class="local-variable">obj</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">undefinedResult</SPAN>&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">undefinedValue</SPAN></P>

<P class="semantics"><SPAN class="global-variable">nullResult</SPAN>&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">nullValue</SPAN></P>

<P class="semantics"><SPAN class="global-variable">booleanResult</SPAN>(<SPAN
class="local-variable">b</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">booleanValue</SPAN>&nbsp;<SPAN
class="local-variable">b</SPAN></P>

<P class="semantics"><SPAN class="global-variable">doubleResult</SPAN>(<SPAN
class="local-variable">d</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">doubleValue</SPAN>&nbsp;<SPAN
class="local-variable">d</SPAN></P>

<P class="semantics"><SPAN class="global-variable">integerResult</SPAN>(<SPAN
class="local-variable">i</SPAN>:&nbsp;<SPAN class="type-name">Integer</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN
class="global-variable">rationalToDouble</SPAN>(<SPAN class="local-variable">i</SPAN>))</P>

<P class="semantics"><SPAN class="global-variable">stringResult</SPAN>(<SPAN
class="local-variable">s</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">stringValue</SPAN>&nbsp;<SPAN
class="local-variable">s</SPAN></P>

<P class="semantics"><SPAN class="global-variable">objectResult</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN>&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">objectValue</SPAN>&nbsp;<SPAN
class="local-variable">o</SPAN></P>

<H2>Exceptions</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Exception</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<SPAN class="field-name">exception</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>;&nbsp;<SPAN class="field-name">error</SPAN>:&nbsp;<SPAN
class="type-name">Error</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Error</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">oneof</SPAN>&nbsp;{<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">coerceToPrimitiveError</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">coerceToObjectError</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">getValueError</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">putValueError</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">deleteError</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="global-variable">makeError</SPAN>(<SPAN
class="local-variable">err</SPAN>:&nbsp;<SPAN class="type-name">Error</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">Exception</SPAN>&nbsp;=&nbsp;<SPAN class="field-name">error</SPAN>&nbsp;<SPAN
class="local-variable">err</SPAN></P>

<H2>Objects</H2>

<H2>Conversions</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="global-variable">referenceGetValue</SPAN>(<SPAN
class="local-variable">rv</SPAN>:&nbsp;<SPAN class="type-name">Reference</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">rv</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">valueReference</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>):&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="local-variable">v</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">placeReference</SPAN>(<SPAN
class="local-variable">r</SPAN>:&nbsp;<SPAN class="type-name">Place</SPAN>):&nbsp;<SPAN
class="local-variable">r</SPAN>.<SPAN class="field-name">base</SPAN>.<SPAN
class="field-name">get</SPAN>(<SPAN class="local-variable">r</SPAN>.<SPAN
class="field-name">property</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">virtualReference</SPAN>:&nbsp;<SPAN class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">ValueOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">getValueError</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">referencePutValue</SPAN>(<SPAN
class="local-variable">rv</SPAN>:&nbsp;<SPAN class="type-name">Reference</SPAN>,&nbsp;<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">VoidOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">rv</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">valueReference</SPAN>:&nbsp;<SPAN class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">VoidOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">putValueError</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">placeReference</SPAN>(<SPAN
class="local-variable">r</SPAN>:&nbsp;<SPAN class="type-name">Place</SPAN>):&nbsp;<SPAN
class="local-variable">r</SPAN>.<SPAN class="field-name">base</SPAN>.<SPAN
class="field-name">put</SPAN>(<SPAN class="local-variable">r</SPAN>.<SPAN
class="field-name">property</SPAN>,&nbsp;<SPAN class="local-variable">v</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">virtualReference</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<H2>Coercions</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="global-variable">coerceToBoolean</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">Boolean</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="global-variable">false</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">booleanValue</SPAN>(<SPAN
class="local-variable">b</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>):&nbsp;<SPAN
class="local-variable">b</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">doubleValue</SPAN>(<SPAN
class="local-variable">d</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>):&nbsp;<SPAN
class="semantic-keyword">not</SPAN>&nbsp;(<SPAN class="global-variable">doubleIsZero</SPAN>(<SPAN
class="local-variable">d</SPAN>)&nbsp;<SPAN class="semantic-keyword">or</SPAN>&nbsp;<SPAN
class="global-variable">doubleIsNan</SPAN>(<SPAN class="local-variable">d</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">stringValue</SPAN>(<SPAN
class="local-variable">s</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>):&nbsp;<SPAN
class="global-variable">length</SPAN>(<SPAN
class="local-variable">s</SPAN>)&nbsp;&#8800;&nbsp;0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="global-variable">true</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">coerceBooleanToDouble</SPAN>(<SPAN
class="local-variable">b</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">Double</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">if</SPAN>&nbsp;<SPAN
class="local-variable">b</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">then</SPAN>&nbsp;1.0<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">else</SPAN>&nbsp;0.0</P>

<P class="semantics"><SPAN class="global-variable">coerceToDouble</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">DoubleOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>:&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;NaN;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">nullValue</SPAN>:&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;0.0;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">booleanValue</SPAN>(<SPAN
class="local-variable">b</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>):&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN
class="global-variable">coerceBooleanToDouble</SPAN>(<SPAN class="local-variable">b</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">doubleValue</SPAN>(<SPAN
class="local-variable">d</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>):&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="local-variable">d</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">stringValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">coerceToUint32</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">IntegerOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">d</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">v</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">doubleToUint32</SPAN>(<SPAN
class="local-variable">d</SPAN>)</P>

<P class="semantics"><SPAN class="global-variable">coerceToInt32</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">IntegerOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">d</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">v</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">uint32ToInt32</SPAN>(<SPAN
class="global-variable">doubleToUint32</SPAN>(<SPAN class="local-variable">d</SPAN>))</P>

<P class="semantics"><SPAN class="global-variable">uint32ToInt32</SPAN>(<SPAN
class="local-variable">ui</SPAN>:&nbsp;<SPAN class="type-name">Integer</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">Integer</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">if</SPAN>&nbsp;<SPAN
class="local-variable">ui</SPAN>&nbsp;&lt;&nbsp;2147483648<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">then</SPAN>&nbsp;<SPAN
class="local-variable">ui</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">else</SPAN>&nbsp;<SPAN
class="local-variable">ui</SPAN>&nbsp;-&nbsp;4294967296</P>

<P class="semantics"><SPAN class="global-variable">coerceToString</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">StringOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;&#8220;<CODE>undefined</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;&#8220;<CODE>null</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">booleanValue</SPAN>(<SPAN
class="local-variable">b</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="local-variable">b</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;&#8220;<CODE>true</CODE>&#8221;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;&#8220;<CODE>false</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">stringValue</SPAN>(<SPAN
class="local-variable">s</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>):&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="local-variable">s</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">hint</SPAN>:&nbsp;<SPAN
class="type-name">DefaultValueHint</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>:&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">pv</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="local-variable">o</SPAN>.<SPAN
class="field-name">defaultValue</SPAN>(<SPAN class="local-variable">hint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">pv</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="local-variable">pv</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">ValueOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">coerceToPrimitiveError</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">coerceToObject</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ObjectOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">ObjectOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">coerceToObjectError</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">stringValue</SPAN>:&nbsp;<SPAN class="symbol">^</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="local-variable">o</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<H2>Environments</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">type</SPAN>&nbsp;<SPAN
class="type-name">Env</SPAN>&nbsp;=&nbsp;<SPAN class="type-expression"><SPAN
class="semantic-keyword">tuple</SPAN>&nbsp;{<SPAN class="field-name">this</SPAN>:&nbsp;<SPAN
class="type-name">ObjectOrNull</SPAN>}</SPAN></P>

<P class="semantics"><SPAN class="global-variable">lookupIdentifier</SPAN>(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>,&nbsp;<SPAN
class="local-variable">id</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ReferenceOrException</SPAN>&nbsp;=&nbsp;<SPAN class="symbol">^</SPAN></P>

<H2>Terminal Actions</H2>

<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">EvalIdentifier</SPAN>[<SPAN
class="terminal">Identifier</SPAN>]&nbsp;:&nbsp;<SPAN class="type-name">String</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">EvalNumber</SPAN>[<SPAN class="terminal">Number</SPAN>]&nbsp;:&nbsp;<SPAN
class="type-name">Double</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">EvalString</SPAN>[<SPAN class="terminal">String</SPAN>]&nbsp;:&nbsp;<SPAN
class="type-name">String</SPAN></P>

<H2>Primary Expressions</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<CODE class="terminal-keyword">this</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">null</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">true</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">false</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<SPAN class="terminal">Number</SPAN></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<SPAN class="terminal">String</SPAN></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">(</CODE>&nbsp;<VAR
class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">)</CODE></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">PrimaryLvalue</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<SPAN class="terminal">Identifier</SPAN></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">(</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR>&nbsp;<CODE class="terminal-keyword">)</CODE></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">PrimaryRvalue</VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">this</CODE>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="global-variable">objectOrNullToValue</SPAN>(<SPAN class="local-variable">e</SPAN>.<SPAN
class="field-name">this</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">null</CODE>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN class="global-variable">nullResult</SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">true</CODE>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN class="global-variable">booleanResult</SPAN>(<SPAN
class="global-variable">true</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">false</CODE>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN class="global-variable">booleanResult</SPAN>(<SPAN
class="global-variable">false</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<SPAN
class="terminal">Number</SPAN>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN class="global-variable">doubleResult</SPAN>(<SPAN
class="action-name">EvalNumber</SPAN>[<SPAN class="terminal">Number</SPAN>])</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<SPAN
class="terminal">String</SPAN>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN class="global-variable">stringResult</SPAN>(<SPAN
class="action-name">EvalString</SPAN>[<SPAN class="terminal">String</SPAN>])</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryRvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">(</CODE>&nbsp;<VAR class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">)</CODE>]&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>]</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">PrimaryLvalue</VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ReferenceOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryLvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<SPAN
class="terminal">Identifier</SPAN>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="global-variable">lookupIdentifier</SPAN>(<SPAN
class="local-variable">e</SPAN>,&nbsp;<SPAN class="action-name">EvalIdentifier</SPAN>[<SPAN
class="terminal">Identifier</SPAN>])</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryLvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">(</CODE>&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">)</CODE>]&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>]</P>

<H2>Left-Side Expressions</H2>

<H4>Syntax</H4>

<DIV class="grammar-argument"><VAR class="nonterminal"><SPAN
class="nonterminal-argument">ExprKind</SPAN></VAR>&nbsp;<SPAN class="symbol">Î</SPAN>&nbsp;{<VAR
class="nonterminal"><SPAN class="nonterminal-attribute">anyValue</SPAN></VAR>,&nbsp;<VAR
class="nonterminal"><SPAN class="nonterminal-attribute">noLValue</SPAN></VAR>}</DIV>
<DIV class="grammar-argument"><VAR class="nonterminal"><SPAN
class="nonterminal-argument">MemberExprKind</SPAN></VAR>&nbsp;<SPAN
class="symbol">Î</SPAN>&nbsp;{<VAR class="nonterminal"><SPAN
class="nonterminal-attribute">call</SPAN></VAR>,&nbsp;<VAR class="nonterminal"><SPAN
class="nonterminal-attribute">noCall</SPAN></VAR>}</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">PrimaryLvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">[</CODE>&nbsp;<VAR class="nonterminal">Expression</VAR>&nbsp;<CODE
class="terminal-keyword">]</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">.</CODE>&nbsp;<SPAN class="terminal">Identifier</SPAN></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<VAR
class="nonterminal">Arguments</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>&nbsp;<VAR
class="nonterminal">Arguments</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">call</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">[</CODE>&nbsp;<VAR class="nonterminal">Expression</VAR>&nbsp;<CODE
class="terminal-keyword">]</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">call</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">.</CODE>&nbsp;<SPAN class="terminal">Identifier</SPAN></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">PrimaryRvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">new</CODE>&nbsp;<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<VAR
class="nonterminal">Arguments</VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">PrimaryRvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">new</CODE>&nbsp;<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<VAR
class="nonterminal">Arguments</VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">call</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">new</CODE>&nbsp;<VAR
class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">Arguments</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<CODE class="terminal-keyword">(</CODE>&nbsp;<CODE
class="terminal-keyword">)</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">(</CODE>&nbsp;<VAR
class="nonterminal">ArgumentList</VAR>&nbsp;<CODE class="terminal-keyword">)</CODE></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">ArgumentList</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">ArgumentList</VAR>&nbsp;<CODE
class="terminal-keyword">,</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">Lvalue</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ReferenceOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">PrimaryLvalue</VAR>]&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PrimaryLvalue</VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">Lvalue</VAR>&nbsp;<VAR class="nonterminal">Arguments</VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">functionReference</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">function</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referenceGetValue</SPAN>(<SPAN
class="local-variable">functionReference</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">arguments</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Value</SPAN>[]</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Arguments</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">let</SPAN>&nbsp;<SPAN class="local-variable">this</SPAN>:&nbsp;<SPAN
class="type-name">ObjectOrNull</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">functionReference</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">valueReference</SPAN>,&nbsp;<SPAN
class="field-name">virtualReference</SPAN>:&nbsp;<SPAN
class="field-name">nullObjectOrNull</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">placeReference</SPAN>(<SPAN class="local-variable">p</SPAN>:&nbsp;<SPAN
class="type-name">Place</SPAN>):&nbsp;<SPAN class="field-name">objectObjectOrNull</SPAN>&nbsp;<SPAN
class="local-variable">p</SPAN>.<SPAN class="field-name">base</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">callObject</SPAN>(<SPAN class="local-variable">function</SPAN>,&nbsp;<SPAN
class="local-variable">this</SPAN>,&nbsp;<SPAN class="local-variable">arguments</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>&nbsp;<VAR
class="nonterminal">Arguments</VAR>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">function</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">arguments</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Value</SPAN>[]</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Arguments</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">callObject</SPAN>(<SPAN class="local-variable">function</SPAN>,&nbsp;<SPAN
class="field-name">nullObjectOrNull</SPAN>,&nbsp;<SPAN class="local-variable">arguments</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">[</CODE>&nbsp;<VAR class="nonterminal">Expression</VAR>&nbsp;<CODE
class="terminal-keyword">]</CODE>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">container</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">property</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Expression</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">readProperty</SPAN>(<SPAN
class="local-variable">container</SPAN>,&nbsp;<SPAN class="local-variable">property</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">.</CODE>&nbsp;<SPAN class="terminal">Identifier</SPAN>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">container</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">readProperty</SPAN>(<SPAN
class="local-variable">container</SPAN>,&nbsp;<SPAN class="field-name">stringValue</SPAN>&nbsp;<SPAN
class="action-name">EvalIdentifier</SPAN>[<SPAN class="terminal">Identifier</SPAN>])</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN>,<SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">PrimaryRvalue</VAR>]&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">PrimaryRvalue</VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">ref</SPAN>:&nbsp;<SPAN class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-argument">MemberExprKind</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">referenceGetValue</SPAN>(<SPAN class="local-variable">ref</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">new</CODE>&nbsp;<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<VAR
class="nonterminal">Arguments</VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">constructor</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">arguments</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Value</SPAN>[]</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Arguments</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">constructObject</SPAN>(<SPAN
class="local-variable">constructor</SPAN>,&nbsp;<SPAN class="local-variable">arguments</SPAN>)</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">noCall</SPAN>,<SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">new</CODE>&nbsp;<VAR
class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">constructor</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">constructObject</SPAN>(<SPAN
class="local-variable">constructor</SPAN>,&nbsp;<B>[]</B><SUB><SPAN
class="type-name">Value</SPAN></SUB>)</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Arguments</VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueListOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Arguments</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">(</CODE>&nbsp;<CODE class="terminal-keyword">)</CODE>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)&nbsp;=&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<B>[]</B><SUB><SPAN class="type-name">Value</SPAN></SUB></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Arguments</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<CODE
class="terminal-keyword">(</CODE>&nbsp;<VAR class="nonterminal">ArgumentList</VAR>&nbsp;<CODE
class="terminal-keyword">)</CODE>]&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ArgumentList</VAR>]</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">ArgumentList</VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueListOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ArgumentList</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">arg</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<B>[</B><SPAN class="local-variable">arg</SPAN><B>]</B></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ArgumentList</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">ArgumentList<SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">,</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">args</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Value</SPAN>[]</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ArgumentList<SUB>1</SUB></VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">arg</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;(<SPAN class="local-variable">args</SPAN>&nbsp;<SPAN
class="symbol">¨</SPAN>&nbsp;<B>[</B><SPAN class="local-variable">arg</SPAN><B>]</B>)</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Lvalue</VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ReferenceOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR>]&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">call</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN></SUP></VAR>]&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MemberLvalue<SUP><SPAN
class="nonterminal-attribute">noCall</SPAN></SUP></VAR>]</P>

<P class="semantics"><SPAN class="global-variable">readProperty</SPAN>(<SPAN
class="local-variable">container</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">property</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ReferenceOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">obj</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToObject</SPAN>(<SPAN class="local-variable">container</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">name</SPAN>:&nbsp;<SPAN
class="type-name">PropName</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToString</SPAN>(<SPAN class="local-variable">property</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="field-name">placeReference</SPAN>&nbsp;<B><SPAN
class="symbol">á</SPAN></B><SPAN class="local-variable">obj</SPAN>,&nbsp;<SPAN
class="local-variable">name</SPAN><B><SPAN class="symbol">ñ</SPAN></B><SUB><SPAN
class="type-name">Place</SPAN></SUB></P>

<P class="semantics"><SPAN class="global-variable">callObject</SPAN>(<SPAN
class="local-variable">function</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">this</SPAN>:&nbsp;<SPAN class="type-name">ObjectOrNull</SPAN>,&nbsp;<SPAN
class="local-variable">arguments</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Value</SPAN>[]</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ReferenceOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">function</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">ReferenceOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">coerceToObjectError</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):&nbsp;<SPAN
class="local-variable">o</SPAN>.<SPAN class="field-name">call</SPAN>(<SPAN
class="local-variable">this</SPAN>,&nbsp;<SPAN class="local-variable">arguments</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">constructObject</SPAN>(<SPAN
class="local-variable">constructor</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">arguments</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Value</SPAN>[]</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">constructor</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">ValueOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">coerceToObjectError</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">res</SPAN>:&nbsp;<SPAN
class="type-name">Object</SPAN>&nbsp;=&nbsp;<SPAN class="local-variable">o</SPAN>.<SPAN
class="field-name">construct</SPAN>(<SPAN class="local-variable">arguments</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">objectResult</SPAN>(<SPAN
class="local-variable">res</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<H2>Postfix Expressions</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">call</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">++</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">--</CODE></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">++</CODE></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">--</CODE></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">NewExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MemberExpression<SUP><SPAN
class="nonterminal-attribute">call</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MemberExpression<SUP><SPAN class="nonterminal-attribute">call</SPAN>,<SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">++</CODE>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandReference</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referenceGetValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">u</SPAN>:&nbsp;<SPAN
class="type-name">Void</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<SPAN
class="global-variable">referencePutValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>,&nbsp;<SPAN
class="field-name">doubleValue</SPAN>&nbsp;<SPAN class="global-variable">doubleAdd</SPAN>(<SPAN
class="local-variable">operand</SPAN>,&nbsp;1.0))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="local-variable">operand</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">--</CODE>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandReference</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referenceGetValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">u</SPAN>:&nbsp;<SPAN
class="type-name">Void</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;<SPAN
class="global-variable">referencePutValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>,&nbsp;<SPAN
class="field-name">doubleValue</SPAN>&nbsp;<SPAN class="global-variable">doubleSubtract</SPAN>(<SPAN
class="local-variable">operand</SPAN>,&nbsp;1.0))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="local-variable">operand</SPAN>)</P>

<H2>Unary Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">delete</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">void</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">typeof</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">typeof</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">++</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">--</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">+</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">-</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">~</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<CODE class="terminal-keyword">!</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">PostfixExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">delete</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rv</SPAN>:&nbsp;<SPAN class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Lvalue</VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rv</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">valueReference</SPAN>:&nbsp;<SPAN class="field-name">abrupt</SPAN><SUB><SPAN
class="type-name">ValueOrException</SPAN></SUB>&nbsp;<SPAN
class="global-variable">makeError</SPAN>(<SPAN class="field-name">deleteError</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">placeReference</SPAN>(<SPAN class="local-variable">r</SPAN>:&nbsp;<SPAN
class="type-name">Place</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">b</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>&nbsp;=&nbsp;<SPAN class="local-variable">r</SPAN>.<SPAN
class="field-name">base</SPAN>.<SPAN class="field-name">delete</SPAN>(<SPAN
class="local-variable">r</SPAN>.<SPAN class="field-name">property</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">booleanResult</SPAN>(<SPAN
class="local-variable">b</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">virtualReference</SPAN>:&nbsp;<SPAN
class="global-variable">booleanResult</SPAN>(<SPAN class="global-variable">true</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">void</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operand</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">undefinedResult</SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">typeof</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rv</SPAN>:&nbsp;<SPAN class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Lvalue</VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rv</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">valueReference</SPAN>(<SPAN class="local-variable">v</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>):&nbsp;<SPAN class="global-variable">stringResult</SPAN>(<SPAN
class="global-variable">valueTypeof</SPAN>(<SPAN class="local-variable">v</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">placeReference</SPAN>(<SPAN class="local-variable">r</SPAN>:&nbsp;<SPAN
class="type-name">Place</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">v</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="local-variable">r</SPAN>.<SPAN
class="field-name">base</SPAN>.<SPAN class="field-name">get</SPAN>(<SPAN
class="local-variable">r</SPAN>.<SPAN class="field-name">property</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">stringResult</SPAN>(<SPAN
class="global-variable">valueTypeof</SPAN>(<SPAN class="local-variable">v</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">virtualReference</SPAN>:&nbsp;<SPAN
class="global-variable">stringResult</SPAN>(&#8220;<CODE>undefined</CODE>&#8221;)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">typeof</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">noLValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">stringResult</SPAN>(<SPAN class="global-variable">valueTypeof</SPAN>(<SPAN
class="local-variable">v</SPAN>))</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">++</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandReference</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referenceGetValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">let</SPAN>&nbsp;<SPAN class="local-variable">res</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN class="global-variable">doubleAdd</SPAN>(<SPAN
class="local-variable">operand</SPAN>,&nbsp;1.0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">u</SPAN>:&nbsp;<SPAN
class="type-name">Void</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referencePutValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>,&nbsp;<SPAN
class="field-name">doubleValue</SPAN>&nbsp;<SPAN class="local-variable">res</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="local-variable">res</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">--</CODE>&nbsp;<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>:&nbsp;<SPAN
class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandReference</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referenceGetValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">let</SPAN>&nbsp;<SPAN class="local-variable">res</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">doubleSubtract</SPAN>(<SPAN
class="local-variable">operand</SPAN>,&nbsp;1.0)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">u</SPAN>:&nbsp;<SPAN
class="type-name">Void</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referencePutValue</SPAN>(<SPAN
class="local-variable">operandReference</SPAN>,&nbsp;<SPAN
class="field-name">doubleValue</SPAN>&nbsp;<SPAN class="local-variable">res</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="local-variable">res</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">+</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="local-variable">operand</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">-</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="global-variable">doubleNegate</SPAN>(<SPAN
class="local-variable">operand</SPAN>))</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">~</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">operand</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToInt32</SPAN>(<SPAN class="local-variable">operandValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">integerResult</SPAN>(<SPAN class="global-variable">bitwiseXor</SPAN>(<SPAN
class="local-variable">operand</SPAN>,&nbsp;-1))</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<CODE class="terminal-keyword">!</CODE>&nbsp;<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">operandValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">booleanResult</SPAN>(<SPAN class="semantic-keyword">not</SPAN>&nbsp;<SPAN
class="global-variable">coerceToBoolean</SPAN>(<SPAN
class="local-variable">operandValue</SPAN>))</P>

<P class="semantics"><SPAN class="global-variable">valueTypeof</SPAN>(<SPAN
class="local-variable">v</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">String</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">v</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>:&nbsp;&#8220;<CODE>undefined</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">nullValue</SPAN>:&nbsp;&#8220;<CODE>object</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>:&nbsp;&#8220;<CODE>boolean</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>:&nbsp;&#8220;<CODE>number</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">stringValue</SPAN>:&nbsp;&#8220;<CODE>string</CODE>&#8221;;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">o</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):&nbsp;<SPAN
class="local-variable">o</SPAN>.<SPAN class="field-name">typeofName</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<H2>Multiplicative Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">*</CODE>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">/</CODE>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">%</CODE>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">*</CODE>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryDoubleOperator</SPAN>(<SPAN
class="global-variable">doubleMultiply</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">/</CODE>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryDoubleOperator</SPAN>(<SPAN
class="global-variable">doubleDivide</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">%</CODE>&nbsp;<VAR class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">UnaryExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryDoubleOperator</SPAN>(<SPAN
class="global-variable">doubleRemainder</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<P class="semantics"><SPAN class="global-variable">applyBinaryDoubleOperator</SPAN>(<SPAN
class="local-variable">operator</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Double</SPAN>&nbsp;&#215;&nbsp;<SPAN class="type-name">Double</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">Double</SPAN></SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)<BR>
&nbsp;&nbsp;:&nbsp;<SPAN class="type-name">ValueOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">leftValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">doubleResult</SPAN>(<SPAN class="local-variable">operator</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN class="local-variable">rightNumber</SPAN>))</P>

<H2>Additive Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">+</CODE>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">-</CODE>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">+</CODE>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="field-name">noHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN class="field-name">noHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="local-variable">leftPrimitive</SPAN>&nbsp;<SPAN
class="semantic-keyword">is</SPAN>&nbsp;<SPAN class="field-name">stringValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">or</SPAN>&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>&nbsp;<SPAN
class="semantic-keyword">is</SPAN>&nbsp;<SPAN class="field-name">stringValue</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftString</SPAN>:&nbsp;<SPAN
class="type-name">String</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToString</SPAN>(<SPAN class="local-variable">leftPrimitive</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightString</SPAN>:&nbsp;<SPAN
class="type-name">String</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToString</SPAN>(<SPAN
class="local-variable">rightPrimitive</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">stringResult</SPAN>(<SPAN
class="local-variable">leftString</SPAN>&nbsp;<SPAN class="symbol">¨</SPAN>&nbsp;<SPAN
class="local-variable">rightString</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryDoubleOperator</SPAN>(<SPAN
class="global-variable">doubleAdd</SPAN>,&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>,&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">-</CODE>&nbsp;<VAR class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">MultiplicativeExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryDoubleOperator</SPAN>(<SPAN
class="global-variable">doubleSubtract</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<H2>Bitwise Shift Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&lt;&lt;</CODE>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;&gt;</CODE>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;&gt;&gt;</CODE>&nbsp;<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&lt;&lt;</CODE>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">bitmapValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">countValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">bitmap</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToUint32</SPAN>(<SPAN class="local-variable">bitmapValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">count</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToUint32</SPAN>(<SPAN class="local-variable">countValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">integerResult</SPAN>(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="global-variable">uint32ToInt32</SPAN>(<SPAN class="global-variable">bitwiseAnd</SPAN>(<SPAN
class="global-variable">bitwiseShift</SPAN>(<SPAN class="local-variable">bitmap</SPAN>,&nbsp;<SPAN
class="global-variable">bitwiseAnd</SPAN>(<SPAN
class="local-variable">count</SPAN>,&nbsp;31)),&nbsp;4294967295)))</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;&gt;</CODE>&nbsp;<VAR class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">bitmapValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">countValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">bitmap</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToInt32</SPAN>(<SPAN class="local-variable">bitmapValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">count</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToUint32</SPAN>(<SPAN class="local-variable">countValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">integerResult</SPAN>(<SPAN class="global-variable">bitwiseShift</SPAN>(<SPAN
class="local-variable">bitmap</SPAN>,&nbsp;-<SPAN class="global-variable">bitwiseAnd</SPAN>(<SPAN
class="local-variable">count</SPAN>,&nbsp;31)))</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;&gt;&gt;</CODE>&nbsp;<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">bitmapValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">countValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AdditiveExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">bitmap</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToUint32</SPAN>(<SPAN class="local-variable">bitmapValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">count</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToUint32</SPAN>(<SPAN class="local-variable">countValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">integerResult</SPAN>(<SPAN class="global-variable">bitwiseShift</SPAN>(<SPAN
class="local-variable">bitmap</SPAN>,&nbsp;-<SPAN class="global-variable">bitwiseAnd</SPAN>(<SPAN
class="local-variable">count</SPAN>,&nbsp;31)))</P>

<H2>Relational Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&lt;</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&lt;=</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;=</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&lt;</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">orderValues</SPAN>(<SPAN class="local-variable">leftValue</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN class="global-variable">true</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">orderValues</SPAN>(<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="global-variable">true</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&lt;=</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">orderValues</SPAN>(<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="global-variable">false</SPAN>,&nbsp;<SPAN
class="global-variable">true</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&gt;=</CODE>&nbsp;<VAR class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ShiftExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">orderValues</SPAN>(<SPAN class="local-variable">leftValue</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>,&nbsp;<SPAN class="global-variable">true</SPAN>)</P>

<P class="semantics"><SPAN class="global-variable">orderValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">less</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>,&nbsp;<SPAN
class="local-variable">greaterOrEqual</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>)<BR>
&nbsp;&nbsp;:&nbsp;<SPAN class="type-name">ValueOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="field-name">numberHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN class="field-name">numberHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="local-variable">leftPrimitive</SPAN>&nbsp;<SPAN
class="semantic-keyword">is</SPAN>&nbsp;<SPAN class="field-name">stringValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">and</SPAN>&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>&nbsp;<SPAN
class="semantic-keyword">is</SPAN>&nbsp;<SPAN class="field-name">stringValue</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="global-variable">booleanResult</SPAN>(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="global-variable">compareStrings</SPAN>(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>.<SPAN class="field-name">stringValue</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>.<SPAN class="field-name">stringValue</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">less</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">greaterOrEqual</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">greaterOrEqual</SPAN>))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">leftPrimitive</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN
class="local-variable">rightPrimitive</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">booleanResult</SPAN>(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="global-variable">doubleCompare</SPAN>(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">leftNumber</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">rightNumber</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">less</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">greaterOrEqual</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">greaterOrEqual</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="global-variable">false</SPAN>))</P>

<P class="semantics"><SPAN class="global-variable">compareStrings</SPAN>(<SPAN
class="local-variable">left</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>,&nbsp;<SPAN
class="local-variable">right</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>,&nbsp;<SPAN
class="local-variable">less</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>,&nbsp;<SPAN
class="local-variable">equal</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>,&nbsp;<SPAN
class="local-variable">greater</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>)<BR>
&nbsp;&nbsp;:&nbsp;<SPAN class="type-name">Boolean</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">if</SPAN>&nbsp;<SPAN
class="global-variable">empty</SPAN>(<SPAN class="local-variable">left</SPAN>)&nbsp;<SPAN
class="semantic-keyword">and</SPAN>&nbsp;<SPAN class="global-variable">empty</SPAN>(<SPAN
class="local-variable">right</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">then</SPAN>&nbsp;<SPAN
class="local-variable">equal</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">else</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="global-variable">empty</SPAN>(<SPAN
class="local-variable">left</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">then</SPAN>&nbsp;<SPAN
class="local-variable">less</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">else</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="global-variable">empty</SPAN>(<SPAN
class="local-variable">right</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">then</SPAN>&nbsp;<SPAN
class="local-variable">greater</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">else</SPAN>&nbsp;<SPAN
class="semantic-keyword">let</SPAN>&nbsp;<SPAN
class="local-variable">leftCharCode</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">characterToCode</SPAN>(<SPAN class="global-variable">first</SPAN>(<SPAN
class="local-variable">left</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">rightCharCode</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">characterToCode</SPAN>(<SPAN class="global-variable">first</SPAN>(<SPAN
class="local-variable">right</SPAN>))<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="semantic-keyword">if</SPAN>&nbsp;<SPAN
class="local-variable">leftCharCode</SPAN>&nbsp;&lt;&nbsp;<SPAN
class="local-variable">rightCharCode</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="local-variable">less</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN class="semantic-keyword">if</SPAN>&nbsp;<SPAN
class="local-variable">leftCharCode</SPAN>&nbsp;&gt;&nbsp;<SPAN
class="local-variable">rightCharCode</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="local-variable">greater</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN class="global-variable">compareStrings</SPAN>(<SPAN
class="global-variable">rest</SPAN>(<SPAN class="local-variable">left</SPAN>),&nbsp;<SPAN
class="global-variable">rest</SPAN>(<SPAN class="local-variable">right</SPAN>),&nbsp;<SPAN
class="local-variable">less</SPAN>,&nbsp;<SPAN class="local-variable">equal</SPAN>,&nbsp;<SPAN
class="local-variable">greater</SPAN>)</P>

<H2>Equality Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">==</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">!=</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">===</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">!==</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">==</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">eq</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">compareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">booleanResult</SPAN>(<SPAN class="local-variable">eq</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">!=</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">eq</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">compareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">booleanResult</SPAN>(<SPAN class="semantic-keyword">not</SPAN>&nbsp;<SPAN
class="local-variable">eq</SPAN>)</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">===</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">booleanResult</SPAN>(<SPAN
class="global-variable">strictCompareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>))</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">!==</CODE>&nbsp;<VAR class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">RelationalExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">booleanResult</SPAN>(<SPAN class="semantic-keyword">not</SPAN>&nbsp;<SPAN
class="global-variable">strictCompareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>))</P>

<P class="semantics"><SPAN class="global-variable">compareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN class="type-name">BooleanOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">true</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>,&nbsp;<SPAN class="field-name">objectValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">false</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">booleanValue</SPAN>(<SPAN
class="local-variable">leftBool</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">false</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>(<SPAN class="local-variable">rightBool</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>):&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;(<SPAN
class="semantic-keyword">not</SPAN>&nbsp;(<SPAN class="local-variable">leftBool</SPAN>&nbsp;<SPAN
class="semantic-keyword">xor</SPAN>&nbsp;<SPAN class="local-variable">rightBool</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>,&nbsp;<SPAN class="field-name">stringValue</SPAN>,&nbsp;<SPAN
class="field-name">objectValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="global-variable">compareDoubleToValue</SPAN>(<SPAN
class="global-variable">coerceBooleanToDouble</SPAN>(<SPAN
class="local-variable">leftBool</SPAN>),&nbsp;<SPAN class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">doubleValue</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>):&nbsp;<SPAN
class="global-variable">compareDoubleToValue</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">stringValue</SPAN>(<SPAN
class="local-variable">leftStr</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">false</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>(<SPAN class="local-variable">rightBool</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">leftValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="global-variable">doubleEqual</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN
class="global-variable">coerceBooleanToDouble</SPAN>(<SPAN
class="local-variable">rightBool</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>(<SPAN class="local-variable">rightNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">leftValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="global-variable">doubleEqual</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN class="local-variable">rightNumber</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">stringValue</SPAN>(<SPAN class="local-variable">rightStr</SPAN>:&nbsp;<SPAN
class="type-name">String</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">compareStrings</SPAN>(<SPAN
class="local-variable">leftStr</SPAN>,&nbsp;<SPAN class="local-variable">rightStr</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>,&nbsp;<SPAN class="global-variable">true</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN class="field-name">noHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">compareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">leftObj</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">false</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>(<SPAN class="local-variable">rightBool</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="field-name">noHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">compareValues</SPAN>(<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>&nbsp;<SPAN
class="global-variable">coerceBooleanToDouble</SPAN>(<SPAN
class="local-variable">rightBool</SPAN>));<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>,&nbsp;<SPAN class="field-name">stringValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="field-name">noHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="global-variable">compareValues</SPAN>(<SPAN
class="local-variable">leftPrimitive</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>(<SPAN class="local-variable">rightObj</SPAN>:&nbsp;<SPAN
class="type-name">Object</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;(<SPAN class="local-variable">leftObj</SPAN>.<SPAN
class="field-name">properties</SPAN>&nbsp;<SPAN class="symbol">º</SPAN>&nbsp;<SPAN
class="local-variable">rightObj</SPAN>.<SPAN class="field-name">properties</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">compareDoubleToValue</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN class="type-name">BooleanOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>:&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="global-variable">false</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToDouble</SPAN>(<SPAN class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="global-variable">doubleEqual</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN class="local-variable">rightNumber</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToPrimitive</SPAN>(<SPAN
class="local-variable">rightValue</SPAN>,&nbsp;<SPAN class="field-name">noHint</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">compareDoubleToValue</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN
class="local-variable">rightPrimitive</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<P class="semantics"><SPAN class="global-variable">doubleEqual</SPAN>(<SPAN
class="local-variable">x</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>,&nbsp;<SPAN
class="local-variable">y</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>)&nbsp;:&nbsp;<SPAN
class="type-name">Boolean</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="global-variable">doubleCompare</SPAN>(<SPAN
class="local-variable">x</SPAN>,&nbsp;<SPAN class="local-variable">y</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>,&nbsp;<SPAN class="global-variable">true</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>,&nbsp;<SPAN class="global-variable">false</SPAN>)</P>

<P class="semantics"><SPAN class="global-variable">strictCompareValues</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>)&nbsp;:&nbsp;<SPAN class="type-name">Boolean</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">case</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>&nbsp;<SPAN class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>:&nbsp;<SPAN
class="local-variable">rightValue</SPAN>&nbsp;<SPAN class="semantic-keyword">is</SPAN>&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">nullValue</SPAN>:&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">is</SPAN>&nbsp;<SPAN class="field-name">nullValue</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">booleanValue</SPAN>(<SPAN
class="local-variable">leftBool</SPAN>:&nbsp;<SPAN class="type-name">Boolean</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">booleanValue</SPAN>(<SPAN class="local-variable">rightBool</SPAN>:&nbsp;<SPAN
class="type-name">Boolean</SPAN>):&nbsp;<SPAN class="semantic-keyword">not</SPAN>&nbsp;(<SPAN
class="local-variable">leftBool</SPAN>&nbsp;<SPAN class="semantic-keyword">xor</SPAN>&nbsp;<SPAN
class="local-variable">rightBool</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">doubleValue</SPAN>,&nbsp;<SPAN class="field-name">stringValue</SPAN>,&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="global-variable">false</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">doubleValue</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>:&nbsp;<SPAN class="type-name">Double</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">doubleValue</SPAN>(<SPAN class="local-variable">rightNumber</SPAN>:&nbsp;<SPAN
class="type-name">Double</SPAN>):&nbsp;<SPAN class="global-variable">doubleEqual</SPAN>(<SPAN
class="local-variable">leftNumber</SPAN>,&nbsp;<SPAN class="local-variable">rightNumber</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">stringValue</SPAN>,&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="global-variable">false</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">stringValue</SPAN>(<SPAN
class="local-variable">leftStr</SPAN>:&nbsp;<SPAN class="type-name">String</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">stringValue</SPAN>(<SPAN class="local-variable">rightStr</SPAN>:&nbsp;<SPAN
class="type-name">String</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="global-variable">compareStrings</SPAN>(<SPAN
class="local-variable">leftStr</SPAN>,&nbsp;<SPAN class="local-variable">rightStr</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>,&nbsp;<SPAN class="global-variable">true</SPAN>,&nbsp;<SPAN
class="global-variable">false</SPAN>);<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">objectValue</SPAN>:&nbsp;<SPAN class="global-variable">false</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="field-name">objectValue</SPAN>(<SPAN
class="local-variable">leftObj</SPAN>:&nbsp;<SPAN class="type-name">Object</SPAN>):<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">case</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN>&nbsp;<SPAN
class="semantic-keyword">of</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">objectValue</SPAN>(<SPAN class="local-variable">rightObj</SPAN>:&nbsp;<SPAN
class="type-name">Object</SPAN>):&nbsp;<SPAN class="local-variable">leftObj</SPAN>.<SPAN
class="field-name">properties</SPAN>&nbsp;<SPAN class="symbol">º</SPAN>&nbsp;<SPAN
class="local-variable">rightObj</SPAN>.<SPAN class="field-name">properties</SPAN>;<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="field-name">undefinedValue</SPAN>,&nbsp;<SPAN class="field-name">nullValue</SPAN>,&nbsp;<SPAN
class="field-name">booleanValue</SPAN>,&nbsp;<SPAN class="field-name">doubleValue</SPAN>,&nbsp;<SPAN
class="field-name">stringValue</SPAN>:&nbsp;<SPAN class="global-variable">false</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">end</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">end</SPAN></P>

<H2>Binary Bitwise Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&amp;</CODE>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">^</CODE>&nbsp;<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">|</CODE>&nbsp;<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&amp;</CODE>&nbsp;<VAR class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">EqualityExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryBitwiseOperator</SPAN>(<SPAN
class="global-variable">bitwiseAnd</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">^</CODE>&nbsp;<VAR class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryBitwiseOperator</SPAN>(<SPAN
class="global-variable">bitwiseXor</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">|</CODE>&nbsp;<VAR class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseXorExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">applyBinaryBitwiseOperator</SPAN>(<SPAN
class="global-variable">bitwiseOr</SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>,&nbsp;<SPAN class="local-variable">rightValue</SPAN>)</P>

<P class="semantics"><SPAN class="global-variable">applyBinaryBitwiseOperator</SPAN>(<SPAN
class="local-variable">operator</SPAN>:&nbsp;<SPAN class="type-expression"><SPAN
class="type-name">Integer</SPAN>&nbsp;&#215;&nbsp;<SPAN class="type-name">Integer</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">Integer</SPAN></SPAN>,&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>)<BR>
&nbsp;&nbsp;:&nbsp;<SPAN class="type-name">ValueOrException</SPAN><BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftInt</SPAN>:&nbsp;<SPAN class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToInt32</SPAN>(<SPAN class="local-variable">leftValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">rightInt</SPAN>:&nbsp;<SPAN
class="type-name">Integer</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">coerceToInt32</SPAN>(<SPAN class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="global-variable">integerResult</SPAN>(<SPAN class="local-variable">operator</SPAN>(<SPAN
class="local-variable">leftInt</SPAN>,&nbsp;<SPAN class="local-variable">rightInt</SPAN>))</P>

<H2>Binary Logical Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">&amp;&amp;</CODE>&nbsp;<VAR
class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">||</CODE>&nbsp;<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">&amp;&amp;</CODE>&nbsp;<VAR
class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="global-variable">coerceToBoolean</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">BitwiseOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">||</CODE>&nbsp;<VAR class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="global-variable">coerceToBoolean</SPAN>(<SPAN
class="local-variable">leftValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="field-name">normal</SPAN>&nbsp;<SPAN
class="local-variable">leftValue</SPAN><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalAndExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)</P>

<H2>Conditional Operator</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">?</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">:</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>&nbsp;<CODE
class="terminal-keyword">?</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>&nbsp;<CODE
class="terminal-keyword">:</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>2</SUB></VAR>]<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">condition</SPAN>:&nbsp;<SPAN class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">LogicalOrExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">if</SPAN>&nbsp;<SPAN class="global-variable">coerceToBoolean</SPAN>(<SPAN
class="local-variable">condition</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">then</SPAN>&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN
class="semantic-keyword">else</SPAN>&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>2</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)</P>

<H2>Assignment Operators</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN class="symbol">Þ</SPAN></DIV>
  <DIV class="grammar-rhs">&nbsp;&nbsp;&nbsp;<VAR
class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
  <DIV class="grammar-rhs">|&nbsp;&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">=</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H2>Expressions</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">ConditionalExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">Lvalue</VAR>&nbsp;<CODE
class="terminal-keyword">=</CODE>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>:&nbsp;<SPAN class="type-name">Env</SPAN>)<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">leftReference</SPAN>:&nbsp;<SPAN
class="type-name">Reference</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Lvalue</VAR>](<SPAN class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN
class="local-variable">rightValue</SPAN>:&nbsp;<SPAN
class="type-name">Value</SPAN>&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP><SUB>1</SUB></VAR>](<SPAN
class="local-variable">e</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="semantic-keyword">letexc</SPAN>&nbsp;<SPAN class="local-variable">u</SPAN>:&nbsp;<SPAN
class="type-name">Void</SPAN>&nbsp;=&nbsp;<SPAN
class="global-variable">referencePutValue</SPAN>(<SPAN
class="local-variable">leftReference</SPAN>,&nbsp;<SPAN
class="local-variable">rightValue</SPAN>)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="semantic-keyword">in</SPAN>&nbsp;<SPAN
class="field-name">normal</SPAN>&nbsp;<SPAN class="local-variable">rightValue</SPAN></P>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]<BR>
&nbsp;&nbsp;=&nbsp;<SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">AssignmentExpression<SUP><SPAN
class="nonterminal-argument">ExprKind</SPAN></SUP></VAR>]</P>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">Expression</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Expression</VAR>]&nbsp;:&nbsp;<SPAN
class="type-expression"><SPAN class="type-name">Env</SPAN>&nbsp;<SPAN
class="symbol">®</SPAN>&nbsp;<SPAN class="type-name">ValueOrException</SPAN></SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Expression</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">CommaExpression<SUP><SPAN
class="nonterminal-attribute">anyValue</SPAN></SUP></VAR>]</P>

<H2>Programs</H2>

<H4>Syntax</H4>

<DIV class="grammar-rule">
  <DIV class="grammar-lhs"><VAR class="nonterminal">Program</VAR>&nbsp;<SPAN
class="symbol">Þ</SPAN>&nbsp;<VAR class="nonterminal">Expression</VAR>&nbsp;<SPAN
class="terminal">End</SPAN></DIV>
</DIV>
<H4>Semantics</H4>

<P class="semantics"><SPAN class="semantic-keyword">action</SPAN>&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Program</VAR>]&nbsp;:&nbsp;<SPAN
class="type-name">ValueOrException</SPAN></P>

<P class="semantics-next"><SPAN class="action-name">Eval</SPAN>[<VAR
class="nonterminal">Program</VAR>&nbsp;<SPAN class="symbol">Þ</SPAN>&nbsp;<VAR
class="nonterminal">Expression</VAR>&nbsp;<SPAN class="terminal">End</SPAN>]&nbsp;=&nbsp;<SPAN
class="action-name">Eval</SPAN>[<VAR class="nonterminal">Expression</VAR>](<B><SPAN
class="symbol">á</SPAN></B><SPAN class="field-name">nullObjectOrNull</SPAN><B><SPAN
class="symbol">ñ</SPAN></B><SUB><SPAN class="type-name">Env</SPAN></SUB>)</P>

</BODY>
</HTML>
