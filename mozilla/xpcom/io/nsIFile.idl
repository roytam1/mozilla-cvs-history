/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/*
 * The contents of this file are subject to the Netscape Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is Mozilla Communicator client code, 
 * released March 31, 1998. 
 *
 * The Initial Developer of the Original Code is Netscape Communications 
 * Corporation.  Portions created by Netscape are
 * Copyright (C) 1998-1999 Netscape Communications Corporation. All
 * Rights Reserved.
 *
 * Contributor(s): 
 *     Doug Turner <dougt@netscape.com>
 */


// This is the only correct cross-platform way to specify a file.
// Strings are not such a way. If you grew up on windows or unix, you
// may think they are. Welcome to reality.

#include "nsISupports.idl"

[scriptable, uuid(c8c0a080-0868-11d3-915f-d9d889d48e3c)]
interface nsIFile : nsISupports
{

    /**
     *   Path Types - Different path types that nsIFile can parse.
     *
     *   NATIVE_PATH is a **native** path.  For example, on windows 
     *   this would be "c:\\foo\\bar" and on the mac it would be 
     *   "Macintosh HD:foo:bar"
     *
     *   UNIX_PATH is a unix style path.  If you are running on unix 
     *   this is the same as InitWithNativePath.  This strings look like
     *   "/Development/MPW/SysErrs.err"
     *
     *   NSPR_PATH is a NSPR style path.  NSPR expects a UNIX path on unix 
     *   and Macintosh, but a native path on windows.  If you want to create 
     *   a nsIFile form a string that comes back from NSPR, use this call
     */

    const unsigned long NATIVE_PATH = 0;
    const unsigned long UNIX_PATH   = 1;
    const unsigned long NSPR_PATH   = 2;

    /**
     *   Create Types
     *
     *   NORMAL_FILE_TYPE - A normal file.  
     *   DIRECTORY_TYPE   - A directory/folder.
     */
    const unsigned long NORMAL_FILE_TYPE = 0;
    const unsigned long DIRECTORY_TYPE   = 1;
    
     
    /**
      * initWithKey
      *
      * This function will initialize the nsIFile object to the
      * location of a well known place.  The location is specified
      * by a string which will be looked up in the registry.  If
      * the string is not found, NS_ERROR_FILE_UNRECONGNIZED_PATH
      * will be returned         
      * 
      *   @param fileKey
      *          A string which represents a special system directory
      *          or a directory which has been registered.
      *
      */
       
       void initWithKey( [const] in string fileKey);


    /**
      * initWithFile
      *
      * This function will initialize the nsIFile object to the
      * exact location of the passed nsIFile.             // what errors can this return?
      * 
      *   @param file
      *          A nsIFile which this object will be initialize
      *          with.
      *
      */
       
       void initWithFile(in nsIFile file);

    /**
      * initWithPath
      *
      * This function will initialize the nsIFile object.  Any
      * internal state information will be reset.  Non-terminal
      * nodes will be resolved. An error will be returned if a
      * non-terminal is a file (NS_ERROR_FILE_INVALID_PATH)
      * 
      *
      *  NOTE:  This function has a known bug on the macintosh and
      *         other OSes which do not represent file locations 
      *         as pathes.  If you do use this function, be very
      *         aware of this problem as bugs.
      *
      *   @param pathType
      *          A pathType defined above.  If the pathType is not
      *          recongnized, NS_ERROR_FILE_UNKNOWN_TYPE will
      *          be returned.
      *
      *   @param filePath       
      *          A string which specifies a full file path to a 
      *          location.  Relative paths will be treated as an
      *          error (NS_ERROR_FILE_UNRECONGNIZED_PATH).
      *
      */
      
       void initWithPath(in unsigned long pathType, [const] in string filePath );

    
    /**
     *  appendPath
     *
     *  This function is used for constructing a descendat of the
     *  current nsIFile.  Non-terminal nodes will be resolved. An 
     *  error will be returned if a non-terminal is a file 
     *  (NS_ERROR_FILE_INVALID_PATH).  
     *
     *  @param relativePath       
     *         A unix style string which is intented to be a relative 
     *         path of the nsIFile.  Starting and trailing '/' will 
     *         be ignored.  If this path is not a unix style path, an 
     *         error will be returned (NS_ERROR_FILE_UNRECONGNIZED_PATH).
     */

      void appendPath([const] in string relativePath);

      /**
       * Normalize the pathName (e.g. removing .. and . components on Unix).
       */
      void normalize();

    /**
     *  create
     *
     *  This function will create a new file or directory in the 
     *  file system. Any nodes that have not been created or 
     *  resolved, will be.  If the file or directory already 
     *  exists create() will return NS_ERROR_FILE_ALREADY_EXISTS.
     * 
     *   @param type
     *          This specifies the type of file system object
     *          to be made.  The only two types at this time
     *          are file and directory which are defined above.
     *          If the type is unrecongnized, we will return an
     *          error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     *   @param permissions
     *          This unix style octal permissions.  This may
     *          be ignored on systems that do not need to do
     *          permissions.
     */
  
      void create(in unsigned long type, in unsigned long permissions);


    /**
     *   Accessor to the leaf name of the file itself. 
     */
    readonly attribute string leafName;
    
    /**
     *  getPath
     *
     *  Accessor to the full file path.  The use of the path is 
     *  strongly discouraged.  Bugs will be writen up against
     *  any use other than displaying a pathname to the user. 
     *
     *  The problem affects platforms in which a path does not 
     *  fully specify a file, because two volumes can have the 
     *  same name.  This is solved by holding a "private" native 
     *  data.  This data is lost when you convert to a string.
     *
     *  @param type
     *         This specifies the type of file path to be 
     *         returned. The file types are defined above.
     */

      string getPath(in unsigned long pathType);
    
  
    /**
     *  copyTo
     *
     *  This will copy this file to the specified newParentDir.  
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error 
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
	 *  copyTo will NOT resolve aliases/shortcuts during the copy.
     *
     *   @param newParentDir
     *          This param is the destination directory. If the 
     *          newParentDir is nsnull, copyTo() will simply  
     *          rename the file. If the newParentDir is not 
     *          null and does not exists, an error will be 
     *          returned (NS_ERROR_FILE_DESTINATION_NOT_DIR)
     *
     *   @param newName
     *          This param allows you to specify a new name
     *          for the file to be copied.  This can be nsnull.
     *
	 */

      void copyTo(in nsIFile newParentDir, [const] in string newName);
     
    /**
     *  copyToFollowingLinks
     *
     *  This function is identical to copyTo except it, as
     *  the name implies, follows symbolic links.
     */

      void copyToFollowingLinks(in nsIFile newParentDir, [const] in string newName);
    
    /**
     *  moveTo
     *
     *  This will move this file to the specified newParentDir.  
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error 
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
	 *  moveTo will NOT resolve aliases/shortcuts during the copy.
     *  moveTo will do the right thing and allow copies across
     *  volumes.
     *
     *   @param newParentDir
     *          This param is the destination directory. If the 
     *          newParentDir is nsnull, moveTo() will simply  
     *          rename the file. If the newParentDir is not 
     *          null and does not exists, an error will be 
     *          returned (NS_ERROR_FILE_DESTINATION_NOT_DIR)
     *
     *   @param newName
     *          This param allows you to specify a new name
     *          for the file to be moved.  This can be nsnull.
     *
	 */
      void moveTo(in nsIFile newParentDir, [const] in string newName);

    /**
     *  moveToFollowingLinks
     *
     *  This function is identical to moveTo except it, as
     *  the name implies, follows symbolic links.
     */
      
      void moveToFollowingLinks(in nsIFile newParentDir, [const] in string newName);
    
    /**
     *  This will try to execute this file.  It will not block for
     *  execution.  'args' will be passed through on the command line
     *  if the OS supports that.
     */
    void execute([const] in string args);
    
    /**
     *  This will try to delete this file.  The 'recursive' flag
     *  must be PR_TRUE to delete directories which are not empty.
     *
     *  This will not resolve any symlinks.
     */
    void delete(in boolean recursive);

    /**
     * Truncate the file to the given length.
     */
    void truncate(in unsigned long length);

    /**
     *  Attributes of nsIFile.
     */
    attribute unsigned long lastModificationDate;
    attribute unsigned long permissions;
    readonly attribute unsigned long fileSize;

    attribute unsigned long lastModificationDateOfLink;
    attribute unsigned long permissionsOfLink;
    /* should we make this writable and have it map to truncate? */
    readonly attribute unsigned long fileSizeOfLink;
    /**
     * Find out what the symlink points at.  Will give error
     * (NS_ERROR_FILE_INVALID_PATH) if not a symlink.
     */
    readonly attribute string target;

    readonly attribute long long diskSpaceAvailable;  // maybe we should put this somewhere else.

    /**
     * Parent will be nsnull when this is at the top of the volume.
     */
    readonly attribute nsIFile parent;
    
    boolean exists();
    boolean isWritable();
    boolean isReadable();
    boolean isExecutable();
    boolean isHidden();
    boolean isDirectory();
    boolean isFile();
    boolean isSymlink();
    /**
     * Not a regular file, not a directory, not a symlink.
     */
    boolean isSpecial(); 
    
    /**
     *  Will determine if the inFile equals this.
     */
    boolean equals(in nsIFile inFile);
    
    /**
     * Will determine the file is a descendant of the parameter inFile.
     * If |recur| is true, it will descend subdirectories looking for 
     */
    boolean isContainedIn(in nsIFile inFile, in boolean recur);
};

%{C++
#define NS_FILE_PROGID "component://netscape/file"
#define NS_FILE_CLASSNAME "File Specification"

#define NS_ERROR_FILE_UNRECOGNIZED_PATH        NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 1)
#define NS_ERROR_FILE_UNRESOLVABLE_SYMLINK      NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 2)
#define NS_ERROR_FILE_EXECUTION_FAILED          NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 3)
#define NS_ERROR_FILE_UNKNOWN_TYPE              NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 4)
#define NS_ERROR_FILE_DESTINATION_NOT_DIR       NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 5)
#define NS_ERROR_FILE_TARGET_DOES_NOT_EXIST     NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 6)
#define NS_ERROR_FILE_COPY_OR_MOVE_FAILED       NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 7)
#define NS_ERROR_FILE_ALREADY_EXISTS            NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 8)
#define NS_ERROR_FILE_INVALID_PATH              NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 9)
#define NS_ERROR_FILE_DISK_FULL                 NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 10)
#define NS_ERROR_FILE_CORRUPTED                 NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_FILES, 11)
%}
