/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * The contents of this file are subject to the Netscape Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/NPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is Mozilla Communicator client code, 
 * released March 31, 1998. 
 *
 * The Initial Developer of the Original Code is Netscape Communications 
 * Corporation.  Portions created by Netscape are
 * Copyright (C) 1998-1999 Netscape Communications Corporation. All
 * Rights Reserved.
 *
 * Contributor(s): 
 *     Doug Turner <dougt@netscape.com>
 */


// This is the only correct cross-platform way to specify a file.
// Strings are not such a way. If you grew up on windows or unix, you
// may think they are. Welcome to reality.

#include "nsISupports.idl"
interface nsISimpleEnumerator;

[scriptable, uuid(c8c0a080-0868-11d3-915f-d9d889d48e3c)]
interface nsIFile : nsISupports
{
    /**
     *   Create Types
     *
     *   NORMAL_FILE_TYPE - A normal file.  
     *   DIRECTORY_TYPE   - A directory/folder.
     */
    const unsigned long NORMAL_FILE_TYPE = 0;
    const unsigned long DIRECTORY_TYPE   = 1;
     
    /**
     *  appendPath
     *
     *  This function is used for constructing a descendant of the
     *  current nsIFile.  
     *
     *  @param relativePath    
     *      A string which is intented to be a child node of the 
     *      nsIFile.  
     */
    void append([const] in string node);

    /**
     * Normalize the pathName (e.g. removing .. and . components on Unix).
     */
    void normalize();

    /**
     *  create
     *
     *  This function will create a new file or directory in the 
     *  file system. Any nodes that have not been created or 
     *  resolved, will be.  If the file or directory already 
     *  exists create() will return NS_ERROR_FILE_ALREADY_EXISTS.
     * 
     *   @param type
     *       This specifies the type of file system object
     *       to be made.  The only two types at this time
     *       are file and directory which are defined above.
     *       If the type is unrecongnized, we will return an
     *       error (NS_ERROR_FILE_UNKNOWN_TYPE).
     *
     *   @param permissions
     *       This unix style octal permissions.  This may
     *       be ignored on systems that do not need to do
     *       permissions.
     */
  
    void create(in unsigned long type, in unsigned long permissions);

    /**
     *   Accessor to the leaf name of the file itself. 
     */
    attribute string leafName;
    
    /**
     *  copyTo
     *
     *  This will copy this file to the specified newParentDir.  
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error 
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
     *  copyTo will NOT resolve aliases/shortcuts during the copy.
     *
     *   @param newParentDir
     *       This param is the destination directory. If the 
     *       newParentDir is nsnull, copyTo() will simply  
     *       rename the file. If the newParentDir is not 
     *       null and does not exists, an error will be 
     *       returned (NS_ERROR_FILE_DESTINATION_NOT_DIR)
     *
     *   @param newName
     *       This param allows you to specify a new name
     *       for the file to be copied.  This can be nsnull.
     *
     */
    void copyTo(in nsIFile newParentDir, [const] in string newName);
     
    /**
     *  copyToFollowingLinks
     *
     *  This function is identical to copyTo except it, as
     *  the name implies, follows symbolic links.
     */
    void copyToFollowingLinks(in nsIFile newParentDir, [const] in string newName);
    
    /**
     *  moveTo
     *
     *  This will move this file to the specified newParentDir.  
     *  If a newName is specified, the file will be renamed.
     *  If 'this' is not created we will return an error 
     *  (NS_ERROR_FILE_TARGET_DOES_NOT_EXIST).
     *
     *  moveTo will NOT resolve aliases/shortcuts during the copy.
     *  moveTo will do the right thing and allow copies across
     *  volumes.
     *
     *   @param newParentDir
     *       This param is the destination directory. If the 
     *       newParentDir is nsnull, moveTo() will simply  
     *       rename the file. If the newParentDir is not 
     *       null and does not exists, an error will be 
     *       returned (NS_ERROR_FILE_DESTINATION_NOT_DIR)
     *
     *   @param newName
     *       This param allows you to specify a new name
     *       for the file to be moved.  This can be nsnull.
     *
     */
    void moveTo(in nsIFile newParentDir, [const] in string newName);

    /**
     *  This will try to execute this file.  It will not block for
     *  execution.  'args' will be passed through on the command line
     *  if the OS supports that.
     */
    void spawn([const] in string args);
    
    /**
     *  This will try to delete this file.  The 'recursive' flag
     *  must be PR_TRUE to delete directories which are not empty.
     *
     *  This will not resolve any symlinks.
     */
    void delete(in boolean recursive);

    /**
     *  Attributes of nsIFile.
     */
    
    attribute unsigned long permissions;
    attribute unsigned long permissionsOfLink;
    
    attribute PRInt64 lastModificationDate;
    attribute PRInt64 lastModificationDateOfLink;
    
    attribute PRInt64 fileSize;
    readonly attribute PRInt64 fileSizeOfLink;
    
    /**
     *  target & path
     *
     *  Accessor to the string path.  These strings are
     *  not guaranteed to be a usable path to pass to NSPR 
     *  or the C stdlib.  There are problem which affects 
     *  platforms in which a path does not fully specify a 
     *  file, because two volumes can have the same name.  
     *  This is solved by holding a "private" native data.  
     *  This data is lost when you convert to a string. 
     *
     *      DO NOT PASS TO USE WITH NSPR OR STDLIB.
     *
     *  target:
     *      Find out what the symlink points at.  Will give error
     *      (NS_ERROR_FILE_INVALID_PATH) if not a symlink.
     *
     *  path:
     *      Find out what the nsIFile points at.
     */

    readonly attribute string target;
    readonly attribute string path;
    
    boolean exists();
    boolean isWritable();
    boolean isReadable();
    boolean isExecutable();
    boolean isHidden();
    boolean isDirectory();
    boolean isFile();
    boolean isSymlink();
    /**
     * Not a regular file, not a directory, not a symlink.
     */
    boolean isSpecial(); 
    
    /**
      * clone()
      *
      * This function will allocate and initialize a nsIFile object to the
      * exact location of the |this| nsIFile.
      * 
      *   @param file
      *          A nsIFile which this object will be initialize
      *          with.
      *
      */
    nsIFile clone();

    /**
     *  Will determine if the inFile equals this.
     */
    boolean equals(in nsIFile inFile);
    
    /**
     * Will determine the inFile is a descendant
     * If |recur| is true, it will descend subdirectories looking for 
     */
    boolean isContainedIn(in nsIFile inFile, in boolean recur);

    /**
     * Parent will be nsnull when this is at the top of the volume.
     */
    readonly attribute nsIFile parent;

    /**
     * Returns an enumeration of the elements in a directory. Each
     * element in the enumeration is an nsIFile. 
     *
     *   @return NS_ERROR_FILE_NOT_DIRECTORY if the current nsIFile does
     *           not specify a directory.
     */ 
    readonly attribute nsISimpleEnumerator directoryEntries;
};

%{C++
#define NS_FILE_PROGID "component://netscape/file"
#define NS_FILE_CLASSNAME "File Specification"

////////////////////////////////////////////////////////////////////////////////
// Special Directories

#include "nsIServiceManager.h"
#include "nsIProperties.h"
#include "nsCOMPtr.h"

#define NS_DIRECTORY_SERVICE_CID                     \
{ /* f00152d0-b40b-11d3-8c9c-000064657374 */         \
    0xf00152d0,                                      \
    0xb40b,                                          \
    0x11d3,                                          \
    {0x8c, 0x9c, 0x00, 0x00, 0x64, 0x65, 0x73, 0x74} \
}

inline nsresult
NS_GetSpecialDirectory(const char* specialDirName, nsIFile* *result)
{
    nsresult rv;
    static NS_DEFINE_CID(kDirectoryServiceCID, NS_DIRECTORY_SERVICE_CID);
    NS_WITH_SERVICE(nsIProperties, serv, kDirectoryServiceCID, &rv);
    if (NS_FAILED(rv)) return rv;
    
    nsCOMPtr<nsISupports> dir;
    rv = serv->Get(specialDirName, NS_GET_IID(nsIFile), getter_AddRefs(dir));
    if (NS_FAILED(rv)) return rv;

    *result = (nsIFile*)dir.get();
    return NS_OK;
}

%}
