/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 *
 * The contents of this file are subject to the Netscape Public License
 * Version 1.0 (the "NPL"); you may not use this file except in
 * compliance with the NPL.  You may obtain a copy of the NPL at
 * http://www.mozilla.org/NPL/
 *
 * Software distributed under the NPL is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the NPL
 * for the specific language governing rights and limitations under the
 * NPL.
 *
 * The Initial Developer of this code under the NPL is Netscape
 * Communications Corporation.  Portions created by Netscape are
 * Copyright (C) 1998 Netscape Communications Corporation.  All Rights
 * Reserved.
 */

// This is the only correct cross-platform way to specify a file.
// Strings are not such a way. If you grew up on windows or unix, you
// may think they are. Welcome to reality.

#include "nsISupports.idl"

%{C++
#include "nscore.h" // for NS_BASE

// Start commenting out the C++ versions of the below in the output header
#if 0
%}
[ref]   native nsStringRef(nsString);
native StandardFilterMask(nsIFileSpec::StandardFilterMask);
%{C++
// End commenting out the C++ versions of the above in the output header
#endif
%}

interface nsIFileURL;
interface nsIFilePath;

[scriptable, uuid(d8c0a080-0868-11d3-915f-d9d889d48e3c)]
interface nsIFileSpec : nsISupports
{
	void fromFileSpec([const] in nsIFileSpec original);
%{C++
// File Widget stuff depends on widget/public/nsIWidget.h
// Until the following is moved out of xpcom/ ifdeffing it
// out.
%}
%{C++
	//
	// The "choose" functions present the file picker UI in order to set the
	// value of the file spec.
%}
	void chooseOutputFile(in string windowTitle, in string suggestedLeafName);

%{C++
	// The mask for standard filters is given as follows:
	enum StandardFilterMask
	{
		eAllReadable		= (1<<0)
	,	eHTMLFiles			= (1<<1)
	,	eXMLFiles			= (1<<2)
	,	eImageFiles			= (1<<3)
	,	eAllFiles			= (1<<4)
	
	// Mask containing all the above default filters
	,	eAllStandardFilters = (
							  eAllReadable
							| eHTMLFiles
							| eXMLFiles
							| eImageFiles
							| eAllFiles)
	
	// The "extra filter" bit should be set if the "extra filter"
	// is passed in to chooseInputFile.
	,   eExtraFilter        = (1<<31)
	};
	enum { kNumStandardFilters = 5 };
%}
	void chooseInputFile(
		in string title
	,	in StandardFilterMask standardFilterMask
	,	in string extraFilterTitle
	,	in string extraFilter
		);
	void chooseDirectory(in string title);
%{C++
%}

	attribute string URLString;
	attribute string UnixStyleFilePath;
	attribute string PersistentDescriptorString;
	attribute string NativePath;

	readonly attribute string NSPRPath;

	void error();

	boolean isValid();
	boolean failed();

	attribute string LeafName;

	readonly attribute nsIFileSpec Parent;

	void makeUnique();
	void makeUniqueWithSuggestedName(in string suggestedName);

	readonly attribute unsigned long ModDate;
	boolean modDateChanged(in unsigned long oldStamp);

	boolean isDirectory();
	boolean isFile();
	boolean exists();

	readonly attribute unsigned long FileSize;
	readonly attribute unsigned long DiskSpaceAvailable;

	void AppendRelativeUnixPath(in string relativePath);

	void createDir();
	void rename([const] in string newLeafName);
	void copyToDir([const] in nsIFileSpec newParentDir);
	void moveToDir([const] in nsIFileSpec newParentDir);
	void execute([const] in string args);
	
	void openStreamForReading();
	void openStreamForWriting();
	void openStreamForReadingAndWriting();
	void closeStream();
	boolean isStreamOpen();
	
	boolean eof();
	long read(inout string buffer, in long requestedCount);
	void readLine(inout string line, in long bufferSize, out boolean wasTruncated);
%{C++
                        // Check eof() before each call.
                        // CAUTION: false result only indicates line was truncated
                        // to fit buffer, or an error occurred (OTHER THAN eof).
%}	
	long write(in string data, in long requestedCount);
	void flush();
	
	void seek(in long offset);
	long tell();
	void endline();
	
};
	
[scriptable, uuid(d8c0a083-0868-11d3-915f-d9d889d48e3c)]
interface nsIDirectoryIterator : nsISupports
{
	void Init(in nsIFileSpec parent);
	boolean exists();
	void next();
	readonly attribute nsIFileSpec currentSpec;
};

%{C++
// Factory methods
NS_COM nsresult NS_NewFileSpec(nsIFileSpec** result);
NS_COM nsresult NS_NewDirectoryIterator(nsIDirectoryIterator** result);
%}
