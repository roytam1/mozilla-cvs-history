#include "testTypeInfo.h"
#include "test.h"

// this file will be generated by the IDL compiler

NS_DEFINE_IID(myTypeInfoIID, MY_TYPEINFO_IID);

nsresult testTypeInfo::QueryInterface(REFNSIID aIID, void** aInstancePtr)
{
	if (nsTypeInfo::QueryInterface(aIID, aInstancePtr) == NS_OK)
		return NS_OK;
	if (aIID.Equals(myTypeInfoIID)) {
		*aInstancePtr = (void*)this;
		NS_ADDREF_THIS();
		return NS_OK;
	}
	return NS_NOINTERFACE;
}

testTypeInfo::testTypeInfo(nsITypeLib* l) : nsTypeInfo(l,1,1)
{
	tattr.guid = myTypeInfoIID;
    tattr.lcid = -1;			// niu
	tattr.cbSizeInstance = sizeof(testI);
    tattr.typekind = TKIND_INTERFACE;
    tattr.cFuncs = 1;			// foo
    tattr.cVars = 1;            // x
    tattr.cImplTypes = 1;
    tattr.wTypeFlags = -1;		// niu
    tattr.wMajorVerNum = 1;
    tattr.wMinorVerNum = -1;	// niu
	fnames[0] = L"foo";
	fdesc[0].dispid = 0;		// foo
	paramdesc[0] = new nsVARTYPE[2];
	paramdesc[0][0] = VT_I4;
	paramdesc[0][1] = VT_WSTR;
	fdesc[0].paramDesc = paramdesc[0];
    fdesc[0].invkind = INVOKE_FUNC;
    fdesc[0].cParams = 2;
    fdesc[0].retDesc = VT_I4;
    fdesc[0].dispid = 0;
	vnames[0] = L"x";
	vdesc[0].varType = VT_I4;
    vdesc[0].dispid = tattr.cFuncs;  // next is 1+ and so on.
}

testTypeInfo::~testTypeInfo()
{
	delete paramdesc[0];
}

nsresult testTypeInfo::Invoke( 
	void *pvInstance,
	nsDISPID memid,
	nsDISPATCHKIND dispKind,
	nsDISPPARAMS *pDispParams,
	nsVARIANT *pVarResult,
	nsEXCEP *pExcepInfo,
	PRInt32 *puArgErr)
{
	PRInt32 res;
	testI* ti = (testI*)pvInstance;
	PRInt32 v, *vp;
	nsresult nr;

	if ((nr = InvokeCheck(memid, dispKind, pDispParams, puArgErr)) != NS_OK)
		return nr;
	switch (dispKind) {
	case DISPATCH_FUNC:
		nsSTR s;
		switch (memid) {
		case 0:						// foo
			v = pDispParams->argv[0].u.lVal;
			s = pDispParams->argv[1].u.wstrVal;
			res = ti->foo(v,s);		// ignore exception for now
			if (pVarResult != NULL) {
				pVarResult->kind = fdesc[0].retDesc;
				pVarResult->u.lVal = res;
			}
			return NS_OK;
		default:
			return NS_NOSUCH_INDEX;
		}
	case DISPATCH_PROPERTYGET:
		switch (memid-tattr.cVars) {
		case 0:                     // x
			vp = pDispParams->argv[0].u.plVal;
			res = ti->get_x(vp);
			if (pVarResult != NULL) {
				pVarResult->kind = fdesc[0].retDesc;
				pVarResult->u.lVal = res;
			}
			return NS_OK;
		default:
			return NS_NOSUCH_INDEX;
		}
	case DISPATCH_PROPERTYPUT:
		switch (memid-tattr.cVars) {
		case 0:                     // x
			v = pDispParams->argv[0].u.lVal;
			res = ti->set_x(v);
			if (pVarResult != NULL) {
				pVarResult->kind = fdesc[0].retDesc;
				pVarResult->u.lVal = res;
			}
			return NS_OK;
		default:
			return NS_NOSUCH_INDEX;
		}
	default:
		return NS_DISPATCH_MISMATCH;
	}
}

nsresult testTypeInfo::CreateInstance( 
	nsISupports *delegate,
	REFNSIID riid,
	void **ppvObj)
{
	if (delegate != NULL) {
		return NS_ERROR_NO_AGGREGATION;
	}
	return CheckInstance(CreateTestI(),riid,ppvObj);
}
