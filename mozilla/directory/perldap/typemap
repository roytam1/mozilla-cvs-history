#############################################################################
# $Id$
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is PerLDAP. The Initial Developer of the Original
# Code is Netscape Communications Corp. and Clayton Donley. Portions
# created by Netscape are Copyright (C) Netscape Communications
# Corp., portions created by Clayton Donley are Copyright (C) Clayton
# Donley. All Rights Reserved.
#
# Contributor(s):	Leif Hedstrom <leif@perldap.org>
#			Kevin McCarthy <kevin@perldap.org>
# DESCRIPTION
#    Typemap to declare XSUB data types.
#
# Notes:
# These are how the typemaps work within API.xs.   Most are straightforward,
# but a few require special explanation, so if you hack API.xs you don't
# cause a memory leak (or can fix one)
#
# char *:
#    INPUT:
#       Changed the standard T_PV INPUT mapping to translate "undef"
#       (PL_sv_undef) to NULL.  I don't know if this will screw anything
#       up - this needs to be tested CAREFULLY.
#    OUTPUT:
#       Most the of functions returning a char * malloc() the char *
#       and return it.  char * is mapped to a SvPv * on the way out.
#       This *copies* the data from the char * to a new char *.
#       These cases need to be freed in the CLEANUP section.
#       Free the char * by calling ldap_memfree().
#
# char **:
#    INPUT:
#       When an avref of SvPv's is passed in, this is converted to a
#       char **.  The char ** as well as all the char * are malloc()ed
#       inside avref2charptrptr().
#       Therefore, you need to free this memory in the CLEANUP section.
#       Do this by calling ldap_value_free().
#    OUTPUT:
#       No work is required.  charptrptr2avref calls ldap_value_free for you.
#
# LDAPControl **:
#    INPUT:
#       When a SV or RV is passed in, the LDAPControl ** is malloc()ed.
#       The LDAPControl * in the array are _not_ malloc()ed  though - they
#       are copied from the SvIv entries (which are pointers).
#       Therefore, you need to free only the LDAPControl ** in the CLEANUP.
#       Do this by calling Safefree()
#    OUTPUT:
#       No work required, the function calls Safefree() for you.
#
# struct berval:
#   NOTE TODO:
#    The input typemap for this currently uses na, which is a global
#    variable, to hold the length of the string.  This isn't threadsafe - 
#    needs to be changed eventually.
#    INPUT:
#       struct berval is directly translated to a SvPv variable in Perl.
#       Although many functions expect a parameter of struct berval *, we
#       are passing in a struct berval.  It makes no sense to malloc()
#       a struct berval just to have the parameter type of the XS function
#       be struct berval *, therefore we use   &var  in the function
#       declaration.  This is 'cheating' but allows us to avoid malloc()ing
#       and having to free the struct berval.
#    OUTPUT:
#       We do not use this for output.  All functions seem to want
#       to work with only struct berval *, so that is used for output
#
# struct berval *:
#    INPUT:
#       Don't use this for type input.  Use struct berval &var  instead.
#    OUTPUT:
#       All the functions returning a struct berval * seem take a parameter
#       of type struct berval ** and modify the pointer.  Therefore we
#       have to convert this to a SvPv using the function.  This function
#       takes care of freeing the struct berval * using ber_bvfree().
#
# struct berval **:
#    A few functions return struct berval ** - we don't have typemaps for
#    those though.  We use the macro RET_BVPP to convert it to an
#    array of SvPv and return them on the stack.  The original author of
#    API.xs had some typemaps, but they aren't used so I deleted them.
#
# FriendlyMap:
#    FriendlyMap is a typedef to a pointer.  Therefore we treat it like
#    a pointer.
#    The two functions using this are ldap_friendly_name() and
#    ldap_free_friendlymap().
#    Both use a parameter of type FriendlyMap * in the API, however
#    we use type FriendlyMap in API.xs and use "pass by reference" using the
#    &map.  This is appropriate for ldap_friendly_map() - it returns the
#    map, but seems wrong for ldap_free_friendlymap().  It is NOT wrong
#    for ldap_free_friendlymap() though because the Perl variable we are
#    passing in contains a FriendlyMap, not a FriendlyMap *.
#
# LDAPVirtualList *
#    INPUT:
#       This converts either a RvAV or a RvHV to a LDAPVirtualList *.
#       The LDAPVirtualList * is malloc()ed inside the function.
#       Call Safefree() in the CLEANUP section to free this memory.
#
# LDAPMod **
#    INPUT:
#       This is _manually_ converted in the API.xs code by calling
#       hash2mod($arg, 0:1, "$func_name")
#       The typemap is not used!
#       Why?  To change the second parameter based on whether this is
#       an add function or not.
#       You need to free the return value using ldap_mods_free()
#
#############################################################################

const int		T_IV
char *			T_PV
const char *		T_PV
char **			T_charptrptr
LDAP *			T_PTR
LDAPMessage *		T_PTR
BerElement *		T_PTR
LDAPControl *		T_PTR
LDAPControl **		T_ldapcontrolptrptr
LDAPVersion *		T_PTR
struct berval 		T_berval
struct berval *		T_bervalptr
FriendlyMap		T_PTR
LDAPsortkey **		T_PTR
LDAPVirtualList *	T_ldapvirtuallistptr
LDAPURLDesc *		T_PTR
LDAPFiltDesc *		T_PTR
LDAPFiltInfo *		T_PTR
LDAPMemCache *		T_PTR
struct ldap_thread_fns *	T_PTR
LDAPMod **		T_PTR
LDAP_CMP_CALLBACK *	T_PTR
LDAP_REBINDPROC_CALLBACK *	T_PTR
struct timeval		T_timeval

#########
INPUT
T_PV
	if ( $arg  == &PL_sv_undef )
           $var = NULL;
	else
	   $var = ($type)SvPV($arg,PL_na)
T_timeval
	$var.tv_sec = atof((char *)SvPV($arg,PL_na));
	$var.tv_usec = 0
T_berval
	$var.bv_val = (char *)SvPV($arg,PL_na);
	$var.bv_len = PL_na
T_charptrptr
        $var = (char **)avref2charptrptr($arg)
T_ldapcontrolptrptr
	$var = sv2ldapcontrolptrptr($arg)
T_ldapvirtuallistptr
	$var = sv2ldapvirtuallistptr($arg)
OUTPUT
T_charptrptr
	$arg = charptrptr2avref($var);
T_bervalptr
	$arg = berptr2svpv($var);
T_ldapcontrolptrptr
	$arg = ldapcontrolptrptr2avref($var);
